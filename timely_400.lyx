#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
% for: LaTeX DogWagger version=`4.0.1' fileTarget=`dummy.txt' startComment=`#' noWarn=`yes'
%========================================================================
% LaTeX Dogwagger takes LaTeX files and pulls out verbatim comments,    %
% concatenating the text enclosed in these verbatim comments            %
% into executable code. Copyright (C) J van Schalkwyk, 2005.            %
% LaTeX Dogwagger is made available under the GNU Public Licence (GPL). %
% To NOT include a particular verbatim section, a comment line          %
%   containing the text: DogWagger dogsAllowed=`no' must precede *ANY*  %
%   line containing the text \begin{verbatim} !                         %
%===============================================================
%
%\usepackage[dvipsnames]{color} % clashes
% \PassOptionsToPackage{dvipsnames}{color} % Gray fails too
%
\usepackage[compact]{titlesec}
\hyphenation{data-base time-stamps}
\titleformat{\chapter}{\Huge\sffamily}{\thesection}{0.5em}{}
\titleformat{\section}{\LARGE\sffamily}{\thesection}{0.4em}{}
\titleformat{\subsection}{\large\sffamily}{\thesubsection}{0.3em}{}
\titleformat{\subsubsection}{\large\sffamily}{\thesubsubsection}{0.5em}{}

%%%%%%%%%%%%
% Modify format of Table Of Contents:
\usepackage[]{tocloft}

\renewcommand{\cfttoctitlefont}{\hfill\huge\sf}  % Big "Contents" title
\renewcommand{\cftaftertoctitle}{\hfill} % and hfill * 2 centres title. 


\renewcommand{\cftchapfont}{\sf\Large}
\renewcommand{\cftsecfont}{\sf\large}        % section titles in SF, Large.
\renewcommand{\cftsubsecfont}{\sf}             % subsections are SF.
\renewcommand{\cftsubsecpagefont}{\sf}    % page numbers in sans serif

\newlength{\mylen}
\setlength{\mylen}{0.5em}
\addtolength{\cftchapnumwidth}{\mylen}
% \setlength{\cftchapnumwidth}{2em} % chap number in TOC: 2012-04-04
\addtolength{\cftsecindent}{\mylen}


%%% end TOC modification

%%http://en.wikibooks.org/wiki/LaTeX/Internationalization 

% also check out: shorttoc
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children no
\language british
\language_package auto
\inputencoding utf8
\fontencoding auto
\font_roman "default" "Noto Serif"
\font_sans "default" "Noto Sans"
\font_typewriter "default" "DejaVu Sans Mono"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 88
\font_tt_scale 100 80
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\float_alignment class
\paperfontsize 10
\spacing single
\use_hyperref true
\pdf_bookmarks false
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 0
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\boxbgcolor #c8c8c8
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title

\family sans
\size giant
Timely
\family default
\size larger

\begin_inset VSpace bigskip
\end_inset


\begin_inset Newline newline
\end_inset


\family sans
\size normal
A time zone module
\begin_inset Newline newline
\end_inset


\size scriptsize
 Version 4,000,000
\end_layout

\begin_layout Author

\family sans
J.
 M.
 van Schalkwyk
\end_layout

\begin_layout Standard

\size large
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Find perl modules:
\end_layout

\begin_layout Plain Layout
https://stackoverflow.com/questions/1557959/how-can-i-find-out-where-a-perl-module-is-installed
\end_layout

\begin_layout Plain Layout
whichpm:
 https://raw.githubusercontent.com/mklement0/whichpm/stable/bin/whichpm
\end_layout

\begin_layout Plain Layout
== 
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
A time zone module
\end_layout

\begin_layout Standard
This Perl module is fairly general in its scope,
 but designed to be used with two specific programs.
 The first is an intialisation/testing program written in Perl (
\emph on
small.pl
\emph default
);
 the second is a much larger Perl program called 
\family sans
vector seekwell
\family default
 that is used to interrogate and reconcile multiple ODBC data sources (and CSV files).
 To work,
 either usage demands a MySQL database modelled on my free electronic health record ( 
\series bold
\emph on
f
\emph default
ehr
\series default
).
 The intent is simple:
 make and use an SQL table called 
\series bold
timely
\series default
 that contains all of the time zone relationships in the Olson (tz) database maintained by IANA.
 This database is rule-based,
 but can with difficulty be translated into a single SQL table (with some supporting tables).
 
\end_layout

\begin_layout Standard
The basic concept is simple:
 rather than using the somewhat arcane rule-based translation of a local (wall) time within a time zone to a standardised timestamp—
and back—
simply use a table of transitions for the translation.
 In the same package we also obtain other functionality:
 access to the relevant SQL table,
 compensation for leap seconds,
 and a format that ticks monotonically:
 proleptic GPS time,
 which avoids the issues with leap seconds that intermittently jump back in both UTC and Unix time.
 
\end_layout

\begin_layout Standard
The following is all a bit quixotic,
 as in 2019 
\begin_inset CommandInset href
LatexCommand href
name "RFC 8536"
target "https://datatracker.ietf.org/doc/html/rfc8536"
literal "false"

\end_inset

 finally documented the TZif `time Zone Information Format',
 which shows how to store consistent data on universal time offsets,
 daylight saving (DST),
 and leap second adjustments for given zones.
 The format was originally introduced in the 1980s.
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that TZif uses UTC,
 with the attendant leap second issues.
 
\end_layout

\end_inset

 So if (for example) on your Linux system you say:
\end_layout

\begin_layout Quote

\family typewriter
ls /usr/share/zoneinfo
\end_layout

\begin_layout Standard
\SpecialChar ldots
 then you'll obtain a set of directories.
 To identify specific zones,
 try e.g.
 
\end_layout

\begin_layout Quote

\family typewriter
ls /usr/share/zoneinfo/Pacific 
\end_layout

\begin_layout Standard
If we now wish to pull out the actual transitions,
 we can say:
 
\end_layout

\begin_layout Quote

\family typewriter
zdump -v -c 2020,2030 /usr/share/zoneinfo/Pacific/Auckland
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
You'll get something along these lines:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement document
alignment document
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UT timestamp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NZ timestamp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DST
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Offset
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Sat Apr  4 13:59:59 2020
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Sun Apr  5 02:59:59 2020 NZDT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
isdst=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
gmtoff=46800
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
  Sat Apr  4 14:00:00 2020
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Sun Apr  5 02:00:00 2020 NZST
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
isdst=0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
gmtoff=43200
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
  Sat Sep 26 13:59:59 2020
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Sun Sep 27 01:59:59 2020 NZST
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
isdst=0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
gmtoff=43200
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
  Sat Sep 26 14:00:00 2020
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Sun Sep 27 03:00:00 2020 NZDT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
isdst=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
gmtoff=46800
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
  Sat Apr  3 13:59:59 2021
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Sun Apr  4 02:59:59 2021 NZDT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
isdst=1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\nospellcheck off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
gmtoff=46800
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Transitions (partial)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
My approach obsessively works through the original tz rules,
 applies them,
 and translates the values obtained into the 
\series bold
timely
\series default
 table,
 defined as follows:
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger dogsAllowed=`no' 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

CREATE TABLE timely
\end_layout

\begin_layout Plain Layout

( timekey integer 
\end_layout

\begin_layout Plain Layout

    ,
 constraint timely_pk PRIMARY KEY(timekey)
\end_layout

\begin_layout Plain Layout

  ,region BIGINT
\end_layout

\begin_layout Plain Layout

    ,constraint timely_region_fk FOREIGN KEY (region)
\end_layout

\begin_layout Plain Layout

      references PLACES(place)
\end_layout

\begin_layout Plain Layout

  ,
 year integer
\end_layout

\begin_layout Plain Layout

  ,
 transition BIGINT
\end_layout

\begin_layout Plain Layout

  ,
 zone_offset BIGINT
\end_layout

\begin_layout Plain Layout

  ,
 dst BIGINT
\end_layout

\begin_layout Plain Layout

  ,
 ignored integer default 0
\end_layout

\begin_layout Plain Layout

  ,
 ver integer default 0
\end_layout

\begin_layout Plain Layout

  ,
 chk int
\end_layout

\begin_layout Plain Layout

)CHARACTER SET=utf8mb4 
\end_layout

\begin_layout Plain Layout

    COLLATE=utf8mb4_unicode_ci;SHOW WARNINGS;DESCRIBE timely;
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The database structure is explored in detail in the document 
\emph on
small_time_400.lyx
\emph default
,
 which provides full source code that includes all of the ancillary tables.
 But you could `simply' populate the table by accessing each of the TZif data files,
 and translating the timestamps.
 
\end_layout

\begin_layout Section
Some history
\end_layout

\begin_layout Standard
Initially,
 all of the initialisation and testing was done within the .pm module.
 This code was written more than a decade ago.
 In December 2025 I extracted command-line routines from the earlier timely_300.lyx document and moved them to 
\emph on
small_time_400.lyx
\emph default
.
 The current module in 
\emph on
timely_400.lyx
\emph default
 provides just the basic functionality required.
 
\end_layout

\begin_layout Standard
I agonized a bit about some of the contents of this module.
 On the one hand,
 it seems clunky and just plain wrong to have a built-in (but crude) Perl command-line interface for loading and checking the importation of tz;
 and similarly,
 it seems a bit of a stretch to build the ODBC functionality and core SQL queries into this module.
 Surely just do one thing (importation of tz) and do it well.
 Conversely,
 there is a natural fit,
 it is in a sense `complete',
 and building a lot of this functionality into either the front end or separate modules seems a bit crazy.
 It is what it is.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Full details of installation are contained in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Setup"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 but the basics involve downloading a recent copy of tz,
 and if your version of seek.pl is in the subdirectory 
\emph on
seekwell/perl
\emph default
,
 then placing the unzipped tz data in 
\emph on
perl/tz
\emph default
.
 In addition to installing the key 
\series bold
\emph on
f
\emph default
ehr
\series default
 tables,
 you'll also need to create the two tz_ tables described in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Setup"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
The module has three main areas of function:
 
\end_layout

\begin_layout Enumerate
Provides ODBC access,
 as a convenience;
 
\end_layout

\begin_layout Enumerate
Deals with multiple aspects of time zone data,
 including conversion between Julian
\begin_inset space \thinspace{}
\end_inset

 and Gregorian timestamps.
 The zones supported are those in tz.
 
\end_layout

\begin_layout Enumerate
Reads,
 tests and reconciles its own internal algorithms with the tz data in the Perl DateTime module.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following text describes the available options.
 The key feature that distinguishes Timely is that it provides a single SQL table of time zone transitions,
 in contrast to the arcane rules within tz;
 it also translates the latter into the former.
 By default Timely uses the rules it reads in to plan future transitions for all countries until 2035,
 based on the value in 
\family typewriter
$TOPYEAR
\family default
.
\end_layout

\begin_layout Section
Functions
\end_layout

\begin_layout Standard
The full list of exported functions is in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Exports"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 which also lists internal functions that are not immediately accessible externally.
 These fall into several main categories,
 as shown below.
 As hinted above,
 we have SQL functionality,
 core time-zone functions,
 and some handling of errors and warnings.
 
\end_layout

\begin_layout Subsection
SQL requests
\end_layout

\begin_layout Standard
The main idea is that we use ODBC to execute SQL statements,
 executing SQL code and retrieving the results of SQL queries.
 
\end_layout

\begin_layout Description
GetSQL
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:GetSQL"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) Retrieve a single SQL row for a supplied query.
 
\end_layout

\begin_layout Description
DoSQL
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Do-SQL"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) Execute an SQL statement that doesn't return a query value 
\end_layout

\begin_layout Description
SQLManySQL
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Retrieve-mutiple-SQL-SQLManySQL"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) Retrieve an array of SQL data—
many rows
\end_layout

\begin_layout Description
AppendSQLConstraint
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Append-SQL-constraint"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) Add another constraint (pending) to a query
\end_layout

\begin_layout Description
ClearSQLConstraint
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SQL-constraint-manipulation-clear"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) Remove all pending constraints
\end_layout

\begin_layout Description
FetchManyKeys
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Fetch-multiple-keys-Fetchmanykeys"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) Fetch keys (one or more) for new rows to insert.
 
\end_layout

\begin_layout Subsection
Time & Timezone functions
\end_layout

\begin_layout Standard
The core Timely functions.
 
\end_layout

\begin_layout Description
FindRegion
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Find-region"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[?
 naming]
\end_layout

\end_inset

 Locate a zone.
 This returns several values,
 including the first match (if present) and the number of hits.
 When printing to the console,
 submitting a `?' anywhere will result in multiple matches being printed to the console.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[explore exporting this functionality in a reasonable way]
\end_layout

\end_inset


\end_layout

\begin_layout Description
SetRegion
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Set-region"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) This is a clumsy legacy transformed into an important routine.
 Originally,
 it simply allowed storage within the module of both the current region name and its corresponding database code;
 but its current function makes more sense:
 load all of the database transition points for this region,
 and retain these as an array that will permit easy interconversion of Julian
\begin_inset space \thinspace{}
\end_inset

 and Gregorian times for the current region.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Takes over from SetOneZoneData
\begin_inset space ~
\end_inset

()
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
[EXPLORE,
 RECONCILE WITH BeginTimely,
 or *remove*] Currently just sets the submitted region code and name (both must be supplied) but logically we should both check these and instantiate a local list of region transitions,
 for future use
\begin_inset Note Note
status open

\begin_layout Plain Layout
[fix me!]
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Timely
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Timely"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) Invoke the command-line `Timely' interface,
 used to check fidelity in an interactive way,
 and 
\emph on
to load or re-load new data from the tz specification,
 
\emph default
located within the directory 
\emph on

\begin_inset Newline newline
\end_inset

~/w/seekwell/perl/tz
\emph default
 or its equivalent
\end_layout

\end_inset


\end_layout

\begin_layout Description
GetLocalTime
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Local-time-Getlocaltime"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) Get local wall time into standard Gregorian format
\end_layout

\begin_layout Description
Julian
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Julian"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
(formerly JulianFromGregorian)
\end_layout

\end_inset

 Given a Gregorian time,
 convert to Julian
\begin_inset space \thinspace{}
\end_inset

 microseconds
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
HugeDate
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:HugeDate"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) Convert Julian
\begin_inset space \thinspace{}
\end_inset

 time in days (float) to microseconds 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[dodgy,
 examine,
 likely slay ]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
Gregorian
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Gregorian"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) Convert a Julian
\begin_inset space \thinspace{}
\end_inset

 time in microseconds to Gregorian.
 Note that the seconds are rendered as 
\family typewriter
ss.ffffff
\family default
,
 which may cause consternation in some databases,
 notably older versions of MS SQL Server.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[explore] 
\end_layout

\end_inset


\end_layout

\begin_layout Description
FormatDate
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rejig-Date"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) Reformat a date from one of a variety of formats to standard Gregorian 
\family typewriter
YYYY-MM-DD hh:mm:ss.ffffff
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
More fiddly are the following,
 which should be used sparsely if at all.
 
\end_layout

\begin_layout Description
GpsJulian
\begin_inset space ~
\end_inset

() Given Gregorian date,
 convert to Julian and then apply GPS adjustment.
\end_layout

\begin_layout Description
InternalJulian
\begin_inset space ~
\end_inset

() Given a Gregorian date specific to a given zone,
 find the internal (GPS) rendition of the date.
\end_layout

\begin_layout Description
ModTimeNow
\begin_inset space ~
\end_inset

() Return 
\emph on
current
\emph default
 seconds in the Unix Epoch,
 vulnerable with signed 32 bits.
 
\end_layout

\begin_layout Description
JulianFromUnix
\begin_inset space ~
\end_inset

() Given Unix time,
 convert to GPS Julian in seconds
\end_layout

\begin_layout Description
Greg
\begin_inset space ~
\end_inset

() Given Julian time in seconds,
 local offset and DST likewise,
 render Gregorian date string.
 
\end_layout

\begin_layout Description
J2G
\begin_inset space ~
\end_inset

() Given a speedup value (qic),
 a zone and a JD value using GPS time in seconds,
 produce an array of values needed to eventually make a Gregorian date string (adjusted for zone and DST).
 The array comprises Y,M,D h,m,s delta zone,
 delta DST,
 a groundhog value,
 as well as extra delta zone and delta DST values if a groundhog `shadow' is present,
 cf.
 Anomalous
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Handle-anomalies"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

).
 
\end_layout

\begin_layout Description
G2J
\begin_inset space ~
\end_inset

() Given speedup $qik together with $zone,
 $YY,
 $MM,
 $DD,
 $h,
 $m,
 $s,
 produce a Julian value in microseconds (text representation as Perl is/was unreliable here).
 
\end_layout

\begin_layout Description
ToJulian
\begin_inset space ~
\end_inset

() Revised Julian that takes $YY,
 $MM,
 $DD,
 $h,
 $m,
 $s,
 $fff,
 $Zoff,
 $Dst.
 
\end_layout

\begin_layout Description
ApplyGps
\begin_inset space ~
\end_inset

() Given that a Gregorian date has been converted correctly to the corresponding Julian day number,
 adjust to GPS by adding the relevant leap seconds.
\end_layout

\begin_layout Description
HugeToJ
\begin_inset space ~
\end_inset

() Convert integer microseconds (as string) to seconds.
 
\end_layout

\begin_layout Description
FullGregorian
\begin_inset space ~
\end_inset

() Take jd,
 LCL,
 DST and isgps (is it proleptic) return a list of year,
 month,
 day,
 hours,
 minutes and seconds.
 
\end_layout

\begin_layout Description
PrettyDate
\begin_inset space ~
\end_inset

() Generate Gregorian date string from $isT,
 $YYYY,$M,$D,$h,$m,$s,
 but if $isT is true,
 then use 'T' as separator rather than a space.
 
\end_layout

\begin_layout Subsection
Errors and Warnings
\end_layout

\begin_layout Description
Warn
\begin_inset space ~
\end_inset

() Issue a warning 
\end_layout

\begin_layout Description
ListWarnings
\begin_inset space ~
\end_inset

() Return text summary of the warnings 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[nasty,
 an array would be better,
 surely] 
\end_layout

\end_inset


\end_layout

\begin_layout Description
ClearWarnings
\begin_inset space ~
\end_inset

() Clear the warning count
\end_layout

\begin_layout Description
GetNewWarnings
\begin_inset space ~
\end_inset

() Return the number of new warnings
\begin_inset Note Note
status open

\begin_layout Plain Layout
—
will be cleared once instruction is complete [EXPLORE]
\end_layout

\end_inset


\end_layout

\begin_layout Description
TooBig Clumsy check that we haven't been forced from integer notation to exponential.
 If needed,
 return as integer string.
  
\begin_inset Note Note
status open

\begin_layout Plain Layout
[nasty,
 needs fixing,
 explore resuscitating bignum use]
\end_layout

\end_inset


\end_layout

\begin_layout Description
SetOffender
\begin_inset space ~
\end_inset

() Store offending line 
\end_layout

\begin_layout Description
Eek
\begin_inset space ~
\end_inset

() Force death —
 with documentation of the problem.
 
\end_layout

\begin_layout Subsection
Configuration & servicing
\end_layout

\begin_layout Standard
Utility functions.
 
\end_layout

\begin_layout Description
BeginTimely
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Setup-Beginzone"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) 
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is a misnomer and should be changed 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[FIX ME]
\end_layout

\end_inset

 to e.g.
 BeginTimely
\begin_inset space ~
\end_inset

() as it
\end_layout

\end_inset

 Initialise Timely.
 
\end_layout

\begin_layout Description
SetTzDatabase
\begin_inset space ~
\end_inset

() Store the internal 
\series bold
\emph on
f
\emph default
ehr
\series default
 source identifier (for src field) locally.
 
\end_layout

\begin_layout Description
EndTimely
\begin_inset space ~
\end_inset

() Terminates certain variables (closes off prior to exit).
 
\end_layout

\begin_layout Description
SetMaxKeyFetch
\begin_inset space ~
\end_inset

() Maximum number of keys that can be retrieved in one go—
see 
\series bold
FetchManyKeys
\series default

\begin_inset space ~
\end_inset

()
\end_layout

\begin_layout Description
ErrorThresholdGet
\begin_inset space ~
\end_inset

() Get current error threshold
\end_layout

\begin_layout Description
SetErrorThreshold
\begin_inset space ~
\end_inset

() Set current error threshold
\end_layout

\begin_layout Description
SetWarnMax
\begin_inset space ~
\end_inset

() Set maximum warnings (for various levels)
\end_layout

\begin_layout Description
SetUserId
\begin_inset space ~
\end_inset

() Set ID to use as 
\begin_inset Quotes eld
\end_inset

current user
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
SetParsingScript
\begin_inset space ~
\end_inset

() 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[CHECK THIS]
\end_layout

\end_inset

 Set description/characterisation of script currently being parsed.
 
\end_layout

\begin_layout Description
XPrint
\begin_inset space ~
\end_inset

() Print to console AND log file.
 
\end_layout

\begin_layout Subsection
Miscellaneous
\end_layout

\begin_layout Description
CheckOS
\begin_inset space ~
\end_inset

() Check operating system and return one of Mac | Windows | Linux | Unknown (at present).
 
\end_layout

\begin_layout Description
FetchKey
\begin_inset space ~
\end_inset

() Generate a brand new key.
 Use with caution.
 
\end_layout

\begin_layout Section
How tz works
\begin_inset CommandInset label
LatexCommand label
name "sec:How-tz-works"

\end_inset


\end_layout

\begin_layout Standard
This is adequately described in Wikipedia
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Tz_database"
target "https://en.wikipedia.org/wiki/Tz_database"
literal "false"

\end_inset


\end_layout

\end_inset

 but the definitive reference is in the tz source at 
\begin_inset CommandInset href
LatexCommand href
name "https://www.iana.org/time-zones"
target "https://www.iana.org/time-zones"
literal "false"

\end_inset

,
 notably the included document 
\emph on
theory.html
\emph default
.
 An excellent overview is 
\begin_inset CommandInset href
LatexCommand href
name "https://data.iana.org/time-zones/tz-how-to.html"
target "https://data.iana.org/time-zones/tz-how-to.html"
literal "false"

\end_inset

.
 It's important (and confusing) to realise that zone specifications designate an end date (i.e.
 the relevant line applies UNTIL the specified date,
 i.e.
 retrospectively) while rule specifications state the point at which a rule changes (they apply prospectively,
 until the next rule).
 Things are made more complex by the potential to specify a time as Universal Time,
 zone time,
 or wall time.
 The basics:
 
\end_layout

\begin_layout Enumerate
A a time zone is any national region where local clocks have all agreed since 1970 (the start of UNIX time).
 The zones are listed in the file 
\emph on
zone.tab
\emph default
 and 
\emph on
zone1970.tab
\emph default
;
 the former is simpler.
 This table maps country codes (2-character) to TZ zones.
 It also contains coordinates (North+East) that localise the TZ entry on the surface of the planet.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[Also see:
 http://cldr.unicode.org/ for local name mapping ]
\end_layout

\end_inset

 TZ names are usually named after large cities (names of which are generally more stable than those of countries).
 
\end_layout

\begin_layout Enumerate
Multiple text files are named after continents and oceans:
 each file describes several time zones in multiple lines per zone;
\end_layout

\begin_layout Enumerate
There are some standard suffixes applied to dates:
\end_layout

\begin_deeper
\begin_layout Description
s local standard time = wall time 
\emph on
without
\emph default
 DST!
\end_layout

\begin_layout Description
g GMT 
\end_layout

\begin_layout Description
u UTC,
 the same as GMT
\end_layout

\begin_layout Description
z nautical time zone,
 also = GMT 
\end_layout

\begin_layout Description
w Wall clock time—
a usage that causes a lot of pain in translation.
 
\end_layout

\begin_layout Description
\begin_inset space ~
\end_inset

 If there is no suffix,
 this is the same as the 
\series bold
w
\series default
 suffix
\end_layout

\end_deeper
\begin_layout Enumerate
Comments start with 
\family typewriter
# 
\family default
;
 blank lines are allowed.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Comments can occur at the end of a valid line
\end_layout

\begin_layout Enumerate
Some lines will have whitespace (tabs etc) followed by a comment and nothing else.
 
\end_layout

\end_deeper
\begin_layout Enumerate
The first line of a time zone specifies the name—
continuation lines have blank name fields.
 Names generally are in the format AREA/LOCATION but some are further qualified e.g.
 America/Indiana/Petersburg.
 There are fairly clearly-defined rules for choosing these names,
 but some legacies and exceptions exist.
 Certain zone names also have abbreviations like EST.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
The maximum length of a zone name is 14 characters,
 and some zone names have been modified to accommodate this.
 Generally a tab character will separate zone name and STDOFF,
 but with a sufficiently long name,
 the tab will be replaced by a single space.
 e.g.
 Africa/Abidjan is followed by a tab,
 but Atlantic/Cape_Verde by a space.
 Each zone line also has:
\end_layout

\begin_layout Enumerate
STDOFF:
 a GMT (UTC) offset along the lines of 
\family typewriter
0:12:12
\family default
 or 
\family typewriter
1:00
\family default
 (This may be negative)
\end_layout

\begin_layout Enumerate
RULES:
 The applicable rule e.g.
 
\family typewriter
Algeria
\family default
 ;
 this may also be a dash 
\family typewriter
-
\family default
 or a time like 
\family typewriter
1:00
\family default
 
\end_layout

\begin_layout Enumerate
FORMAT:
 The format e.g.
 LMT | WE%sT | CE%sT | WET | CET | -02 | -01 | WAST | +04/+05 | %s | BST | GMT/BST | MSK/MSD | EE%sT etc.
 The %s within some of these names is replaced by the LETTER field from the relevant rule!
\end_layout

\begin_layout Enumerate
[UNTIL] an end time e.g.
 
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
1882
\family default
 or 
\end_layout

\begin_layout Enumerate

\family typewriter
1981 May
\family default
 or 
\end_layout

\begin_layout Enumerate

\family typewriter
1977 Oct 21
\family default
 or 
\end_layout

\begin_layout Enumerate

\family typewriter
1940 Feb 25 2:00
\family default
 or 
\end_layout

\begin_layout Enumerate

\family typewriter
1912 Jan 1 1:00u
\family default
 or 
\end_layout

\begin_layout Enumerate

\family typewriter
1940 May 20 2:00s
\family default
 \SpecialChar ldots
 or even
\end_layout

\begin_layout Enumerate

\family typewriter
lastFri
\family default
 !
\end_layout

\begin_layout Standard
This is the precise time at which the rule ends (unless it still continues to now,
 in which case the rule is blank
\end_layout

\end_deeper
\begin_layout Enumerate
An optional comment starting with # 
\end_layout

\end_deeper
\begin_layout Enumerate
The rules can be complex,
 with potentially multiple lines for a single rule.
 A rule definition line contains the name of the rule followed by (in order):
 NAME FROM TO TYPE IN ON AT SAVE LETTER/S
\end_layout

\begin_deeper
\begin_layout Enumerate
FROM starting year e.g.
 
\family typewriter
1958
\family default
 (always 
\backslash
d{4} )
\end_layout

\begin_layout Enumerate
TO end year eg.
 
\family typewriter
1959
\family default
 OR 
\family typewriter
only
\family default
 Options:
\end_layout

\begin_deeper
\begin_layout Enumerate
max
\end_layout

\begin_layout Enumerate
1995 etc.
 (always 
\backslash
d{4} )
\end_layout

\begin_layout Enumerate
only 
\end_layout

\end_deeper
\begin_layout Enumerate
A TYPE,
 usually just a dash 
\family typewriter
-
\family default
 
\end_layout

\begin_layout Enumerate
IN :
 something like Mar —
 always a month 
\family typewriter

\begin_inset Note Note
status open

\begin_layout Plain Layout

\family typewriter
[?]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
ON:
 something like lastSun or perhaps Sun>=8 The options are:
\end_layout

\begin_deeper
\begin_layout Enumerate
a day of month like 
\family typewriter
1
\family default
 or 
\family typewriter
14
\family default
 
\end_layout

\begin_layout Enumerate
A day of week with qualifier like 
\family typewriter
Sun>=1
\family default
 or 
\family typewriter
Sat>=16
\family default
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
What about ??:
 Rule Zion 2005 2012 - Apr Fri<=1 2:00 1:00 D 
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
A 
\begin_inset Quotes eld
\end_inset

last
\begin_inset Quotes erd
\end_inset

 value like 
\family typewriter
lastThu
\family default
 or 
\family typewriter
lastSun
\family default
 (of the month)
\end_layout

\end_deeper
\begin_layout Enumerate
AT:
 A start time with two possible formats:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
23:00
\family default
 or 
\family typewriter
7:00
\family default
 (etc) ie 
\backslash
d
\backslash
d?:
\backslash
d
\backslash
d The value may also be 
\family typewriter
00:00
\family default
 or 
\family typewriter
24:00
\family default
 (!) 
\end_layout

\begin_layout Enumerate

\family typewriter
23:00s
\family default
 or 
\family typewriter
7:00s
\family default
 Likewise for 
\family typewriter
00:00s
\family default
 or 
\family typewriter
24:00s
\family default
 (!) 
\end_layout

\begin_layout Enumerate

\family typewriter
1:00u
\family default
 or 
\family typewriter
17:00u
\family default
 Likewise for 00/24 as above.
 
\end_layout

\end_deeper
\begin_layout Enumerate
SAVE:
 The amount of daylight saving applicable,
 along the lines of:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
0
\family default
 
\end_layout

\begin_layout Enumerate

\family typewriter
1:00
\family default
 
\end_layout

\begin_layout Enumerate

\family typewriter
-1:00
\family default
 
\end_layout

\end_deeper
\begin_layout Enumerate
LETTERS that signify various things,
 e.g.
 W for War,
 P for Peace.
 Options are S | - | M | WAT | CAT | +01 (etc i.e.
 +
\backslash
dd ) | D | W | P | MST | MMT | MDST | MSK etc.
 
\end_layout

\begin_layout Enumerate
This may be followed by a #comment.
 
\end_layout

\end_deeper
\begin_layout Enumerate
What about Link fields e.g.
 
\family typewriter
Link Africa/Abidjan Africa/Bamako # Mali
\family default
 ?
 This starts with 
\begin_inset Quotes eld
\end_inset

Link
\begin_inset Quotes erd
\end_inset

 and then has the LINK-FROM and LINK-TO entries.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
The LINK-FROM entry must be a NAME of a Zone;
 
\end_layout

\begin_layout Enumerate
The LINK-TO entry is simply an alternate name (alias) for that zone.
\end_layout

\end_deeper
\begin_layout Section
How tz 
\emph on
should
\emph default
 work
\end_layout

\begin_layout Standard
You have just started plumbing the insane depths of tz.
 Here's how things might work a bit better,
 based on accepted time zones:
\end_layout

\begin_layout Enumerate
Have each transition for a given zone marked as a point on a standard time scale that ticks with monotonous regularity;
\end_layout

\begin_layout Enumerate
At the transition,
 state the rules that apply 
\begin_inset Note Note
status open

\begin_layout Plain Layout
before the transition ?!
 or AFTER?
\end_layout

\end_inset

 in terms of:
\end_layout

\begin_deeper
\begin_layout Description
Z offset from the standard (reference point:
 UTC or equivalent)
\end_layout

\begin_layout Description
DST daylight saving that applies,
 if present.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
That should be it,
 but you also need rules that disambiguate (or accommodate) the gap or `groundhog interval' that occurs when DST is applied or removed.
 You need to do two further things:
\end_layout

\begin_layout Itemize
Translate an invalid wall time (time in the gap) either forward or back to a valid time.
 You might do this with or without an offset,
 too.
 
\end_layout

\begin_layout Itemize
Signal that a wall time that falls in a groundhog interval is ambiguous—
e.g.
 append a star,
 or something.
 
\end_layout

\begin_layout Subsection
How does Timely work?
\end_layout

\begin_layout Enumerate
The monotonically ticking scale is GPS time,
 extended backwards in time—
proleptically—
to accommodate times before the start of January 6,
 1980,
 with weeks beginning on Sunday.
 
\end_layout

\begin_layout Enumerate
The above transition details are recorded in an SQL table called 
\series bold
timely
\series default
,
 which maps each zone against a transition,
 z and d.
 For convenience,
 the year is recorded and a prosthetic `hint' documents the status at the end of the year—
both are convenient in calculation.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[NEED TO DESCRIBE BACKWARDS VS FORWARDS and predictive implications]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Note that at present,
 UTC does not tick monotonically;
 nor does Unix time:
 there are leap seconds.
 We need to accommodate these leap seconds in translating between GPS time and UTC.
 
\end_layout

\begin_layout Subsection
How can we translate from tz to Timely?
\end_layout

\begin_layout Standard
This is explored and demonstrated in 
\emph on
small_time_400.lyx
\emph default
.
 An interactive interface there creates,
 explores and tests.
 Timely is available from the command line by navigating to e.g.
 
\emph on
C:
\backslash
w
\backslash
seekwell
\backslash
perl
\backslash

\emph default
 (or ~/smalltime/perl/ —
 wherever you've stored the program) and saying:
\end_layout

\begin_layout Quote

\family typewriter
perl small.pl 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
See 
\emph on
small_time_400.lyx
\emph default
 for details.
 Conversions between Julian
\begin_inset space \thinspace{}
\end_inset

 and Gregorian should use Peter Baum's algorithms.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
cf.
 
\begin_inset CommandInset href
LatexCommand href
name "cf. https://www.researchgate.net/publication/316558298_Date_Algorithms "
target "cf. https://www.researchgate.net/publication/316558298_Date_Algorithms "
literal "false"

\end_inset

.
 
\end_layout

\end_inset

 Note that the default database is called smalltime,
 as described in small_time_400.lyx,
 but you can use another target database e.g.
 fehr by saying something like:
 
\end_layout

\begin_layout Quote

\family typewriter
perl small.pl db=fehr 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
There are a few other command line arguments,
 described in 
\emph on
small_time_400.lyx
\emph default
 too.
 Invocations of Timely::
 are also present in the source code for vector seekwell.
 
\end_layout

\begin_layout Section
The main file 
\begin_inset CommandInset label
LatexCommand label
name "sec:The-main-file"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
THE FOLLOWING HAVE BEEN REMOVED:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
Later we will also need the following in the main program,
 but not in this module.
 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  &CsvRestoreBackups();
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Here we set up GLOBAL codes used in checking rules within the TZ specification.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  my $DELTAdst     = 3;
    # DST offset changed
\end_layout

\begin_layout Plain Layout

  my $NEWend       = 4;
    # end timestamp changed
\end_layout

\begin_layout Plain Layout

#  my $NOstart      = 5;
    # DST start not specified (but ended),
 usually minor
\end_layout

\begin_layout Plain Layout

  my $UPside       = 6;
    # inverted North
\end_layout

\begin_layout Plain Layout

  my $inVERTED     = 7;
    # inverted South
\end_layout

\begin_layout Plain Layout

  my $DOUBLEstart  = 8;
    # duplicate DST start
\end_layout

\begin_layout Plain Layout

  my $DUPLIcation  = 9;
    # DST already active
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We require the Perl subdirectory in the directory in which the \SpecialChar LyX
 files are stored,
 normally ~/smalltime/perl/ or a Windows equivalent.
 This must contain a 
\emph on
lib
\emph default
 subdirectory.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "3pt"

\end_inset


\end_layout

\begin_layout Standard
The file is 
\emph on
perl/lib/Timely.pm
\emph default
;
 the module is Timely.pm.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger newTarget=`perl/lib/Timely.pm' startComment=`# ' noWarn=`yes'
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

#!/usr/local/bin/perl -w
\end_layout

\begin_layout Plain Layout

package Timely;
\end_layout

\begin_layout Plain Layout

use strict;
\end_layout

\begin_layout Plain Layout

use warnings;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

use feature 'unicode_strings';
    # UTF-8 usage
\end_layout

\begin_layout Plain Layout

use utf8;
                         #
\end_layout

\begin_layout Plain Layout

use open ':encoding(utf8)';
       #
\end_layout

\begin_layout Plain Layout

binmode(STDOUT,
 ":utf8");
         # 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

binmode(STDOUT,
 ":utf8");
  # or:
   use open qw/:std :utf8/;
\end_layout

\begin_layout Plain Layout

  # also cf:
 binmode(STDIN,
 ":encoding(utf8)");
  
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Exports
\begin_inset CommandInset label
LatexCommand label
name "sec:Exports"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Also check out:
\end_layout

\begin_layout Plain Layout
https://perlmaven.com/how-to-create-a-perl-module-for-code-reuse
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

# Formerly:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

use vars qw($VERSION @ISA @EXPORT @EXPORT_OK );
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## use vars qw($VERSION @ISA @EXPORT_OK @EXPORT %EXPORT_TAGS );
 # prefer _OK to @EXPORT # cf.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We export a variety of symbols.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

use Exporter qw(import);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

our $VERSION = 4000000;
          # 4.0.0 e.g.
 1024000=1.24.0
\end_layout

\begin_layout Plain Layout

our @ISA = qw(Exporter);
\end_layout

\begin_layout Plain Layout

our @EXPORT = qw( BeginTimely );
 
\end_layout

\begin_layout Plain Layout

our @EXPORT_OK = qw( GetSQL DoSQL SQLManySQL AppendSQLConstraint ClearSQLConstraint 
\end_layout

\begin_layout Plain Layout

  FindRegion SetRegion Timely GetLocalTime Julian Gregorian 
\end_layout

\begin_layout Plain Layout

  FormatDate QuickJ2G GetUtcCode SetUtcCode ExGps FetchTzDate 
\end_layout

\begin_layout Plain Layout

  GetNewWarnings Eek TooBig SetOffender SetMaxKeyFetch ClearWarnings 
\end_layout

\begin_layout Plain Layout

  EndTimely SetUserId SetTzDatabase SetParsingScript  
\end_layout

\begin_layout Plain Layout

  XPrint Warn ListWarnings FetchManyKeys ErrorThresholdGet SetErrorThreshold 
\end_layout

\begin_layout Plain Layout

  SetWarnMax CheckOS GpsJulian InternalJulian ModTimeNow JulianFromUnix 
\end_layout

\begin_layout Plain Layout

  Greg J2G Padding FetchKey ToJulian ApplyGps HugeToJ FullGregorian PrettyDate G2J 
\end_layout

\begin_layout Plain Layout

  );
 
\end_layout

\begin_layout Plain Layout

  # ^ DO NOT put comment in qw list.
 Note Padding() is a bit niche.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## WE CURRENTLY DO *not* export the following but they are still accessible using Timely::
\end_layout

\begin_layout Plain Layout

## ValidatePath() SetFehrOdbc()FetchLeapData() BigApplyGps() 
\end_layout

\begin_layout Plain Layout

## BumpNewWarnings() LogError() Converter() DoubleDigit() Lead() 
\end_layout

\begin_layout Plain Layout

## Greg() ClipFractionalSeconds() Anomalous() Signum() Biggen() JulianDay() 
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Uses
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
## dependencies [?
 explore this]
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#use File::Copy qw(move);
 # more 'compatible' than rename
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 # high-resolution timing [also see nanosleep!]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

use Time::HiRes qw(gettimeofday usleep);
  # high-resolution timing 
\end_layout

\begin_layout Plain Layout

use POSIX qw(floor);
 
\end_layout

\begin_layout Plain Layout

use Term::ReadKey;
  # only used to interrupt long loops by pressing Esc
\end_layout

\begin_layout Plain Layout

              # 
\end_layout

\begin_layout Plain Layout

  ReadMode 1;
 # normal read mode.
 [should this be in invoker?] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

use DateTime;
 # this may give trouble if you're behind a corporate firewall
\end_layout

\begin_layout Plain Layout

              # For Windows DateTime version:
  perl -M"DateTime 9999" 
\end_layout

\begin_layout Plain Layout

              # 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
DateTime documentation is at 
\begin_inset CommandInset href
LatexCommand href
name "https://metacpan.org/pod/DateTime"
target "https://metacpan.org/pod/DateTime"
literal "false"

\end_inset

.
 It does not unfortunately seem to provide a method that says which version of tz is currently being used.
 If however you explore your local Perl installation under Linux (eg 
\emph on
/usr/local/share/perl/
\emph default
 in Ubuntu) you should be able to locate a DateTime/TimeZone/ subdirectory in which there are .pm files.
 These should contain an Olson version number along the lines of:
\end_layout

\begin_layout Quote

\family typewriter
our $VERSION = '2.66';
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
You can also say:
\end_layout

\begin_layout Quote

\family typewriter
cpan -D DateTime::TimeZone
\end_layout

\begin_layout Standard
This will not only provide the version,
 but also tell you the most recent one.
 To update,
 say:
\end_layout

\begin_layout Quote

\family typewriter
sudo cpanm DateTime::TimeZone
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Under Windows,
 you may be a bit more crippled.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
On your local machine,
 the Perl DateTime menu will likely be in your Perl64 directory under 
\emph on
/site/lib/auto
\emph default
 with data under 
\emph on
/site/lib/DateTime/
\emph default
.
\begin_inset Foot
status open

\begin_layout Plain Layout
Notably 
\emph on
/site/lib/DateTime/TimeZone
\end_layout

\end_inset

 If you examine the pm modules there like 
\emph on
Africa/Windhoek.pm
\emph default
,
 you'll find that the data are hard-coded from the relevant version of the Olson data,
 which is unfortunate—
it would seem that you can't upgrade the 
\begin_inset Quotes eld
\end_inset

data
\begin_inset Quotes erd
\end_inset

 component without upgrading the DateTime version,
 which may be tricky where e.g.
 ActivePerl lags development.
 For Linux installation,
 see e.g.
 
\begin_inset CommandInset href
LatexCommand href
name "https://zoomadmin.com/HowToInstall/UbuntuPackage/libdatetime-perl"
target "https://zoomadmin.com/HowToInstall/UbuntuPackage/libdatetime-perl"
literal "false"

\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Check out:
 
\series bold
https://stackoverflow.com/questions/20676921/perl-datetime-incorrect-timezone-offset
\end_layout

\begin_layout Plain Layout
cf.
 http://man.he.net/man5/tzfile 
\end_layout

\begin_layout Plain Layout
https://metacpan.org/pod/DateTime%3a%3aTimeZone%3a%3aTzfile
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

You can use your systems tzfile(5),
 using DateTime::TimeZone::Tzfile.
 Not only does it perform better than DateTime::TimeZone it also removes the need to have redundant data that needs to be in sync.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$tz = DateTime::TimeZone::Tzfile->new('/etc/localtime');
\end_layout

\begin_layout Plain Layout

$dt = DateTime->now(time_zone => $tz);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Constants
\begin_inset CommandInset label
LatexCommand label
name "subsec:Constants"

\end_inset


\end_layout

\begin_layout Standard
Some constant values.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In the following,
 
\family typewriter
GREGORIANEPSILON
\family default
 is used to adjust for numerical imprecision that occurs with date calculations,
 even with double-precision calculations,
 resulting in rounding errors.
 For more details see FullGregorian
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Full-Gregorian"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

).
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

use constant HUGE_INT => 999999999999999;
      # if GT,
 has exponent in Perl
\end_layout

\begin_layout Plain Layout

use constant HUGE_NEGATIVE_INT => -(HUGE_INT);
 # similarly...
\end_layout

\begin_layout Plain Layout

use constant EPSILONSECONDS => 0.010;
     # [clumsy] 
\end_layout

\begin_layout Plain Layout

use constant  PART_EMPTY => '__';
  # 
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

my $TICK  = 
\begin_inset Quotes eld
\end_inset

✔
\begin_inset Quotes erd
\end_inset

;
 # or '_/' if no Utf8.
 
\end_layout

\begin_layout Plain Layout

my $FETCHTIMEOUT = 2;
           # seconds
\end_layout

\begin_layout Plain Layout

my $TOPCOUNTRY = 999;
           # max in PLACES table.
 *DO NOT* fiddle!
 
\end_layout

\begin_layout Plain Layout

                                # don't make it a constant (interpolated).
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The value of 
\family typewriter
$TOPCOUNTRY
\family default
 is constant but rendered as a variable for easy interpolation.
 It assumes that the 
\series bold
PLACES
\series default
 SQL table has a list of countries (See 
\emph on
small_time_400.lyx
\emph default
) with appropriate codes < this value.
 
\end_layout

\begin_layout Subsection
Clumsy variables
\end_layout

\begin_layout Standard
These are global within the module;
 most are global constants that should never be fiddled with.
 In several cases,
 $ variables are used rather than the clumsy Perl 
\family typewriter
use constant
\family default
 specification,
 to permit easier interpolation in strings.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

my $SQLCONSTRAINT = '';
 
\end_layout

\begin_layout Plain Layout

my $LOGFILE;
\end_layout

\begin_layout Plain Layout

my $ERRORFILE;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

my @WARNMAX =   (200,
 500,
 1000,
 10000);
 # maximum warnings displayed in each category 
\end_layout

\begin_layout Plain Layout

my @WARNCOUNT = (  0,
   0,
    0,
     0);
 # actual number of warnings recorded for this run.
\end_layout

\begin_layout Plain Layout

my $NEWWARNINGS = 0;
                     # new warnings during recent stmt execution 
\end_layout

\begin_layout Plain Layout

my $ERRORTHRESHOLD = 8;
                  # &XPrint_() logs statements if < threshold
\end_layout

\begin_layout Plain Layout

my $OFFENDING_LINE;
\end_layout

\begin_layout Plain Layout

my $MAXIMUM_KEY_FETCH = 5000000;
         # can fetch 5M keys at a time (limit)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

my $DB_MAIN;
                             # THE HANDLE OF THE MAIN (normally,
 fehr) DATABASE 
\end_layout

\begin_layout Plain Layout

my $TZDATABASE;
                          # a source (src,
 SOURCES table) ID used in src fields.
 
\end_layout

\begin_layout Plain Layout

my $USERID;
                              # MAIN SYSTEM 'superuser'
\end_layout

\begin_layout Plain Layout

my $UTCCODE;
                             # 'Global' code (to fill in)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

my $SQLOK = 0;
                           #
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

my $USE_DBI;
                             # if 1,
 then are using DBI::
 and not Win32::ODBC.
\end_layout

\begin_layout Plain Layout

my $MY_DBI_HANDLE;
                       # undefined,
 initially  
\end_layout

\begin_layout Plain Layout

my $PARSING_SCRIPT = '';
                 # Identifies script currently being parsed.
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Under Windows,
 to render the tick in the DOS console install font from:
 
\begin_inset CommandInset href
LatexCommand href
name "https://math.berkeley.edu/~serganov/ilyaz.org/software/fonts/ "
target "https://math.berkeley.edu/~serganov/ilyaz.org/software/fonts/ "
literal "false"

\end_inset

,
 in the console say:
 
\family typewriter
\series bold
chcp 65001
\family default
\series default
 and then right-click on the top bar | Properties | Font | Deja vu Sans Mono unifont.
 
\end_layout

\begin_layout Standard
The $USE_DBI is something of a legacy for the time when Win32::ODBC was a thing.
 A strong case can be made for removing all of the code that depends on Win32::ODBC.
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:initial-code-for-TZ"

\end_inset

initial code for TZ
\end_layout

\begin_layout Standard
Time-zone conversion related.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

## internal storage for Timely rows relevant to current zone choice:
\end_layout

\begin_layout Plain Layout

my $MYTIMELY;
 
\end_layout

\begin_layout Plain Layout

my $MYZONE = 0;
          #
\end_layout

\begin_layout Plain Layout

my @LEAPDATA;
            # Stores leap second transitions.
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Instantiate
\end_layout

\begin_layout Section
S
\series bold
etup
\begin_inset CommandInset label
LatexCommand label
name "sec:Setup-Beginzone"

\end_inset


\end_layout

\begin_layout Standard
Create a log,
\begin_inset Note Note
status open

\begin_layout Plain Layout
 load various constants into an associative array,
\end_layout

\end_inset

 and get Julian
\begin_inset space \thinspace{}
\end_inset

 timestamp.
 Must be called first.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub BeginTimely #
\end_layout

\begin_layout Plain Layout

{ my($dbh,
 $usedbi) = @_;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  &SetFehrOdbc($dbh,
 $usedbi);
 
\end_layout

\begin_layout Plain Layout

  # $LOGFILE,
 $ERRORFILE are globals in this module
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (!
 &ValidatePath('log'))
\end_layout

\begin_layout Plain Layout

   { die "Directory 'log' does not exist";
\end_layout

\begin_layout Plain Layout

   };
 
\end_layout

\begin_layout Plain Layout

  my($tim) = ' ' .
 localtime;
 # NB leading space (scalar context).
 
\end_layout

\begin_layout Plain Layout

  $tim =~ s/[
\backslash
s:]/_/mg;
 
\end_layout

\begin_layout Plain Layout

  my($logfile) = "log/EDLOG$tim.txt";
 ## [might wish to remove spaces?] 
\end_layout

\begin_layout Plain Layout

open ($LOGFILE,
 ">$logfile") or die
\end_layout

\begin_layout Plain Layout

     "*CRASH* Could not open LOG $logfile :$!
\backslash
n";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($errfile) = "log/ERRORS.txt";
  # must *append* not overwrite!
\end_layout

\begin_layout Plain Layout

open ($ERRORFILE,
 ">>$errfile") or die
\end_layout

\begin_layout Plain Layout

     "*CRASH* Couldn't open ERROR file $errfile :$!
\backslash
n";
\end_layout

\begin_layout Plain Layout

  ClearSQLConstraint();
 
\end_layout

\begin_layout Plain Layout

  @LEAPDATA = &FetchLeapData();
\end_layout

\begin_layout Plain Layout

  return(@LEAPDATA);
 ## hmm,
 check this 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Takes and establishes the database handle $dbh and whether DBI is used (
\family typewriter
$usedbi
\family default
).
\begin_inset Note Note
status open

\begin_layout Plain Layout
There is limited value in the legacy use of Win32::ODBC and it seems reasonable even to remove that option.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Set UTC code
\end_layout

\begin_layout Standard
Local storage of the internal database PLACES code for `UTC'.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SetUtcCode
\end_layout

\begin_layout Plain Layout

{ my($utc) = @_;
  
\end_layout

\begin_layout Plain Layout

  $UTCCODE = $utc;
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Load leap-second-adjustment data
\end_layout

\begin_layout Standard
From the 
\series bold
\emph on
f
\emph default
ehr
\series default
 database,
 load leap second data from the 
\series bold
leapseconds 
\series default
table.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub FetchLeapData
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  my($handDB) = $DB_MAIN;
  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($q) = "SELECT gpstime,
 utctime,
 toffset FROM leapseconds " 
\end_layout

\begin_layout Plain Layout

   .
 "order by leapsecond DESC";
  # topmost is first
\end_layout

\begin_layout Plain Layout

  my(@LEAPS) = &SQLManySQL($handDB,
 $q,
 'get leap data');
\end_layout

\begin_layout Plain Layout

  return(@LEAPS);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
2025-02-17:
 replaced 
\series bold
offset
\series default
 above with 
\series bold
toffset
\series default
 ;
 (reserved word now)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The caller will (and must) store the returned array in the global 
\family typewriter
@LEAPDATA
\family default
.
\end_layout

\begin_layout Subsection
fehr odbc
\end_layout

\begin_layout Standard
Store the handle of the `ODBC' connection as $DB_MAIN,
 and the obsolete boolean integer value for $USE_DBI.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SetFehrOdbc #
\end_layout

\begin_layout Plain Layout

{ my($dbh,
 $usedbi) = @_;
 
\end_layout

\begin_layout Plain Layout

  $DB_MAIN = $dbh;
 
\end_layout

\begin_layout Plain Layout

  $USE_DBI = $usedbi;
 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Set parsing
\end_layout

\begin_layout Standard
Only used to represent the current script being parsed within vector seekwell.
 Useful in debugging (alone).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SetParsingScript #
\end_layout

\begin_layout Plain Layout

{ my($b) = @_;
 
\end_layout

\begin_layout Plain Layout

  $PARSING_SCRIPT = $b;
 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
max key fetch
\begin_inset CommandInset label
LatexCommand label
name "subsec:max-key-fetch"

\end_inset


\end_layout

\begin_layout Standard
The maximum number of new (sequentially generated) keys that can be retrieved at one time.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SetMaxKeyFetch #
\end_layout

\begin_layout Plain Layout

{ my($i) = @_;
 
\end_layout

\begin_layout Plain Layout

  $MAXIMUM_KEY_FETCH = $i;
 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Exceeding this will force an error.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
unused:
 
\end_layout

\begin_layout Subsection
Country
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SetCountry #
\end_layout

\begin_layout Plain Layout

{ my($i);
\end_layout

\begin_layout Plain Layout

    ($i) = @_;
 
\end_layout

\begin_layout Plain Layout

  $COUNTRY = $i;
 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
UserId
\begin_inset CommandInset label
LatexCommand label
name "subsec:UserId-set"

\end_inset


\end_layout

\begin_layout Standard
The ID of the responsible user.
 Used in generating temporary locks while retrieving new row keys.
 See usage.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SetUserId #
\end_layout

\begin_layout Plain Layout

{ my($i) = @_;
 
\end_layout

\begin_layout Plain Layout

  $USERID = $i;
 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
TzDatabase
\begin_inset CommandInset label
LatexCommand label
name "subsec:TzDatabase-set"

\end_inset


\end_layout

\begin_layout Standard
The database that contains the TZ tables.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SetTzDatabase #
\end_layout

\begin_layout Plain Layout

{ my($i) = @_;
 
\end_layout

\begin_layout Plain Layout

  $TZDATABASE = $i;
 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Close Zone
\begin_inset CommandInset label
LatexCommand label
name "subsec:Close-Zone"

\end_inset


\end_layout

\begin_layout Standard
End off,
 closing the error and log files.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub EndTimely #
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  close $LOGFILE;
\end_layout

\begin_layout Plain Layout

  close $ERRORFILE;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Various
\begin_inset Note Note
status open

\begin_layout Plain Layout
[clean up]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Check OS
\begin_inset CommandInset label
LatexCommand label
name "subsec:Check-OS"

\end_inset


\end_layout

\begin_layout Standard
Check operating system:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub CheckOS # 
\end_layout

\begin_layout Plain Layout

{ my $Os = 'Unknown' ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($^O =~ /darwin/i)
\end_layout

\begin_layout Plain Layout

  { $Os = 'Mac';
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

elsif($^O =~ /linux/i)
\end_layout

\begin_layout Plain Layout

  { $Os = 'Linux';
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

elsif($^O =~ /win/i)
\end_layout

\begin_layout Plain Layout

  { $Os = 'Windows';
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return($Os);
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A crude check that distinguishes just Mac/Linux/Windows,
 at present.
 Uses the Perl 
\family typewriter
$^O
\family default
 (capital O,
 not zero).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
–
\end_layout

\begin_layout Subsection
Clear screen
\begin_inset CommandInset label
LatexCommand label
name "subsec:Clear-screen"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Cls # 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

if(CheckOS() eq 'Windows') # or use $OPERATING_SYSTEM [?] 
\end_layout

\begin_layout Plain Layout

  { system 'cls';
 
\end_layout

\begin_layout Plain Layout

  } else
\end_layout

\begin_layout Plain Layout

  { system 'clear';
 
\end_layout

\begin_layout Plain Layout

  };
   # or simply and obscurely:
   system $^O eq 'MSWin32' ?
 'cls' :
 'clear';
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Cls # 
\end_layout

\begin_layout Plain Layout

{ print "
\backslash
033[2J";
    #clear the screen
\end_layout

\begin_layout Plain Layout

  print "
\backslash
033[0;0H";
  #jump to 0,0
\end_layout

\begin_layout Plain Layout

if($OPERATING_SYSTEM eq 'Windows') # global :(
\end_layout

\begin_layout Plain Layout

  { `CLS`;
 # doesn't work 
\end_layout

\begin_layout Plain Layout

    # and something like this forces use Wind32::Console
\end_layout

\begin_layout Plain Layout

    #
\end_layout

\begin_layout Plain Layout

    # system $^O eq 'MSWin32' ?
 'cls' :
 'clear';
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    system 'cls';
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # require Win32::Console;
 # would need to install 
\end_layout

\begin_layout Plain Layout

    # my($OUT) = Win32::Console->new(STD_OUTPUT_HANDLE);
 
\end_layout

\begin_layout Plain Layout

    # $OUT->Cls;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ## playing:
 
\end_layout

\begin_layout Plain Layout

    #require Term::ANSIScreen;
  # would need to install
\end_layout

\begin_layout Plain Layout

    #my $clear_screen = cls();
\end_layout

\begin_layout Plain Layout

    #print $clear_screen;
\end_layout

\begin_layout Plain Layout

    # 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
General subroutines
\end_layout

\begin_layout Section
Error-related
\begin_inset CommandInset label
LatexCommand label
name "sec:Error-related-offend-threshold"

\end_inset


\end_layout

\begin_layout Standard
Higher error threshold values mean that the corresponding message won't be printed,
 provided it's above the threshold.
 Set threshold.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SetErrorThreshold #
\end_layout

\begin_layout Plain Layout

{ my($i);
\end_layout

\begin_layout Plain Layout

    ($i)=@_;
\end_layout

\begin_layout Plain Layout

  $ERRORTHRESHOLD = $i;
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Retrieve threshold.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub ErrorThresholdGet #
\end_layout

\begin_layout Plain Layout

{ return($ERRORTHRESHOLD);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Retain offending line:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SetOffender #
\end_layout

\begin_layout Plain Layout

{ my($offal);
\end_layout

\begin_layout Plain Layout

    ($offal)=@_;
\end_layout

\begin_layout Plain Layout

  $OFFENDING_LINE = $offal;
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Death
\begin_inset CommandInset label
LatexCommand label
name "sec:Death-Eek"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
There is a conflict between the usage of Eek
\begin_inset space ~
\end_inset

() in 
\emph on
timely_400.lyx
\emph default
 and in 
\emph on
seek_400.lyx
\emph default
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[THIS NEEDS FIXING]
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die,
 logging error.
 Can be invoked externally.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Eek #
\end_layout

\begin_layout Plain Layout

{ my($msg,
 $prefix,
 $erk,
 $line);
\end_layout

\begin_layout Plain Layout

    ($msg,
 $prefix,
 $erk,
 $line)=@_;
\end_layout

\begin_layout Plain Layout

  my($ln) = '';
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(length $prefix > 0)
\end_layout

\begin_layout Plain Layout

  { $prefix .= "
\backslash
n  Warnings=" .
 join("
\backslash
t",@WARNCOUNT) .
 "
\backslash
n"  ;
 
\end_layout

\begin_layout Plain Layout

    $prefix .= "  at Perl source line $line ";
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  my($out) = "$prefix$msg $ln
\backslash
n";
\end_layout

\begin_layout Plain Layout

if( (defined $OFFENDING_LINE) # SEE allocation
\end_layout

\begin_layout Plain Layout

  &&(ref($OFFENDING_LINE) eq 'ARRAY')
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  { $out = "$out < @{$OFFENDING_LINE} >";
 
\end_layout

\begin_layout Plain Layout

    undef($OFFENDING_LINE);
 # undefine so not used twice if caught!
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

if(length $PARSING_SCRIPT > 0)
\end_layout

\begin_layout Plain Layout

  { $out = "$out <bad script line near:
 '$PARSING_SCRIPT' >";
 
\end_layout

\begin_layout Plain Layout

    $PARSING_SCRIPT = '';
 # neat.
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  &LogError($out);
 # 'permanent' record 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # also helpful print,
 to accommodate debugging of EITHER [explore this]
\end_layout

\begin_layout Plain Layout

if(  $erk 
\end_layout

\begin_layout Plain Layout

  &&($ERRORTHRESHOLD > 10)
\end_layout

\begin_layout Plain Layout

  ) # arbitrary choice of 10 [explore]
\end_layout

\begin_layout Plain Layout

  { my($dud) = $out;
 
\end_layout

\begin_layout Plain Layout

    $dud =~ s/[
\backslash
r
\backslash
n]//mg;
 
\end_layout

\begin_layout Plain Layout

    ## &XPrint(0,
 "
\backslash
n*   RECOVERY <$dud>");
  # clumsy
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ## &XPrint(0,
 $out);
 
\end_layout

\begin_layout Plain Layout

  die $out ;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Aagh
\end_layout

\begin_layout Standard
Internal to this module,
 a wrapper for Eek
\begin_inset space ~
\end_inset

(),
 which is not itself otherwise invoked from within the module.
 Eek
\begin_inset space ~
\end_inset

() takes a second,
 auxiliary parameter and (weirdly enough) is also only referenced once by 
\emph on
seek_400.lyx
\emph default
,
 by the Aagh
\begin_inset space ~
\end_inset

() routine there!
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Aagh #
\end_layout

\begin_layout Plain Layout

{ my($msg,
 $line,
 $foo);
\end_layout

\begin_layout Plain Layout

    ($msg,
 $line,
 $foo)=@_;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  &Eek($msg,
 '',
 $foo,
 $line);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Path validation
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub ValidatePath
\end_layout

\begin_layout Plain Layout

{ my @pth;
\end_layout

\begin_layout Plain Layout

  my $wholep = "";
\end_layout

\begin_layout Plain Layout

 ($_) = @_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if ( /^
\backslash
/(.*)$/ ) # if starting slash
\end_layout

\begin_layout Plain Layout

     { $wholep = "/";
\end_layout

\begin_layout Plain Layout

       $_ = $1;
\end_layout

\begin_layout Plain Layout

     };
\end_layout

\begin_layout Plain Layout

  @pth = split /
\backslash
//;
\end_layout

\begin_layout Plain Layout

#  print "
\backslash
n Debug:
 path components @pth";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my $p;
\end_layout

\begin_layout Plain Layout

  foreach $p (@pth)
\end_layout

\begin_layout Plain Layout

    { $wholep = "$wholep$p";
\end_layout

\begin_layout Plain Layout

      if (!
 (-e $wholep) )
\end_layout

\begin_layout Plain Layout

         { # print "
\backslash
n Debug:
 bad path $wholep";
\end_layout

\begin_layout Plain Layout

           return 0;
 # fail
\end_layout

\begin_layout Plain Layout

         };
\end_layout

\begin_layout Plain Layout

      $wholep = "$wholep/";
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

  return 1;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Time-related utilities
\end_layout

\begin_layout Subsection
Modified time value
\end_layout

\begin_layout Standard
Use of 
\family typewriter
gettimeofday
\family default
 in scalar context would return a single number that includes fractional seconds;
 for our purposes here,
 we simply return the seconds in the Unix Epoch.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This will be problematic on some systems when Unix time is stored as a signed integer,
 running out at 03:14:07 UTC on 19 January 2038.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub ModTimeNow
\end_layout

\begin_layout Plain Layout

{ my($epochseconds,
 $microseconds);
\end_layout

\begin_layout Plain Layout

  ($epochseconds,
 $microseconds) = gettimeofday;
\end_layout

\begin_layout Plain Layout

  $epochseconds;
     # use seconds for 32-bit system [?] 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Subsubsection
and the microtimer:
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://www.seancolombo.com/2010/03/24/quick-tip-clone-of-phps-microtime-function-as-a-perl-subroutine/
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# Clone of PHP's microtime.
 - from http://seancolombo.com
\end_layout

\begin_layout Plain Layout

# call microtime(1) to get float-formatted seconds/microseconds
\end_layout

\begin_layout Plain Layout

# 
\end_layout

\begin_layout Plain Layout

sub microtime
\end_layout

\begin_layout Plain Layout

{ my $asFloat = 0;
\end_layout

\begin_layout Plain Layout

if(@_)
\end_layout

\begin_layout Plain Layout

  { $asFloat = shift;
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  (my $epochseconds,
 my $microseconds) = gettimeofday;
\end_layout

\begin_layout Plain Layout

if($asFloat)
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  while(length("$microseconds") < 6)
\end_layout

\begin_layout Plain Layout

    { $microseconds = "0$microseconds";
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  $microtime = "$epochseconds.$microseconds";
\end_layout

\begin_layout Plain Layout

  } else 
\end_layout

\begin_layout Plain Layout

  { $microtime = "$epochseconds $microseconds";
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  return $microtime;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Padding
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[Hmm,
 cf.
 &Pad
\begin_inset space ~
\end_inset

()
\end_layout

\end_inset

 Generate string of length $n comprising repeated character $ch.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Padding
\end_layout

\begin_layout Plain Layout

{ my($ch,
 $n) = @_;
\end_layout

\begin_layout Plain Layout

  return( $ch x int($n) );
 # funny old Perl 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
DoubleDigit
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub DoubleDigit # 
\end_layout

\begin_layout Plain Layout

{ my($i) = @_;
\end_layout

\begin_layout Plain Layout

  return(&Lead($i,2));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Leading zeroes
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[Clumsy.
 fix this with &Padding
\begin_inset space ~
\end_inset

() ] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a number $i,
 preprend zeroes to make it up to the $target length.
 If longer,
 simply return.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Lead #
\end_layout

\begin_layout Plain Layout

{ my($i,
 $target) = @_;
\end_layout

\begin_layout Plain Layout

while(length $i < $target)
\end_layout

\begin_layout Plain Layout

  { $i = "0$i";
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  return($i);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sign
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[clumsy]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Sign # 
\end_layout

\begin_layout Plain Layout

{ my($n) = @_;
\end_layout

\begin_layout Plain Layout

if($n < 0)
\end_layout

\begin_layout Plain Layout

  { return('-');
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  return('+');
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Signum
\begin_inset Note Note
status open

\begin_layout Plain Layout
[needs resolution]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Returns 0,1 or -1 depending on sign of its single argument;
 0 returns zero 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Signum
\end_layout

\begin_layout Plain Layout

{ my($n);
\end_layout

\begin_layout Plain Layout

    ($n)=@_;
\end_layout

\begin_layout Plain Layout

 return( $n <=> 0);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Biggen
\end_layout

\begin_layout Standard
If a number is just below a positive value,
 round up to that positive value and return an integer;
 similarly round 
\emph on
down
\emph default
 if just above a negative value!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Biggen # 
\end_layout

\begin_layout Plain Layout

{ my($n) = @_;
\end_layout

\begin_layout Plain Layout

  return(  int( $n + EPSILONSECONDS*&Signum($n) )  );
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Perl big issues
\begin_inset CommandInset label
LatexCommand label
name "sec:Perl-big-issues-Toobig"

\end_inset


\end_layout

\begin_layout Standard
Any number over about 
\family typewriter
HUGE_INT
\family default
 will be rendered in exponential notation.
 This is baad.
 At present we 'sacrifice the precision' (it's already sacrificed) but retain a facsimile of an integer by converting back to a string.
\end_layout

\begin_layout Standard
Subsequently,
 I added the $soft option,
 where if this is set,
 we don't issue a warning.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
 [Nasty,
 but Perl bigint library in my past experience stuffed up other things:
 one can ameliorate its effects on large floats etc.
 by adding more functionality,
 but at a cost.]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub TooBig #
\end_layout

\begin_layout Plain Layout

{ my($n,
 $soft) = @_;
\end_layout

\begin_layout Plain Layout

if($n < HUGE_INT && $n > HUGE_NEGATIVE_INT)
\end_layout

\begin_layout Plain Layout

  { return($n);
 
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

if(!
 $soft)
\end_layout

\begin_layout Plain Layout

  { &Warn(1,
 "Large integer $n.
 Likely precision loss");
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  return( int($n/1000) .
 '000' );
 # [ugh]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is invoked by Transform
\begin_inset space ~
\end_inset

()—
used within DoAlter;
 Intg
\begin_inset space ~
\end_inset

(
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\end_layout

\end_inset

)—
thus also within ALTER,
 ResolveValue,
 ResolveIntegerValue;
 DefiniteInteger
\begin_inset space ~
\end_inset

(
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\end_layout

\end_inset

)—
SetDebug
\begin_inset space ~
\end_inset

() and DoShowData
\begin_inset space ~
\end_inset

();
 and Value
\begin_inset space ~
\end_inset

()—
thus Resolve,
 ResolveTextValue,
 ExResolveTextValue and SQLResolve.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Pad
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Pad #
\end_layout

\begin_layout Plain Layout

{ my($s,
 $L) = @_;
\end_layout

\begin_layout Plain Layout

while(length $s < $L)
\end_layout

\begin_layout Plain Layout

  { $s = "$s ";
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

 return($s);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
XPrint
\begin_inset CommandInset label
LatexCommand label
name "sec:XPrint"

\end_inset


\end_layout

\begin_layout Standard
A general purpose printing routine that may also print to the log file.
 Only prints if the threshold is right.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub XPrint #
\end_layout

\begin_layout Plain Layout

{ my($level,
 $msg) = @_;
\end_layout

\begin_layout Plain Layout

if($level < $ERRORTHRESHOLD) # global test
\end_layout

\begin_layout Plain Layout

  { print $msg;
  # clumsy
\end_layout

\begin_layout Plain Layout

  if($LOGFILE->opened())
\end_layout

\begin_layout Plain Layout

    { print $LOGFILE $msg;
 # and keep a copy,
 will *fail* if no $LOGFILE [explore]
\end_layout

\begin_layout Plain Layout

    } else 
\end_layout

\begin_layout Plain Layout

    { print 
\begin_inset Quotes eld
\end_inset

  *** BUGGER handle is closed
\backslash
n
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Issue warning
\begin_inset CommandInset label
LatexCommand label
name "subsec:Issue-warning"

\end_inset


\end_layout

\begin_layout Standard
This is more general.
 It counts the number of warnings issued in a given class,
 and calls it quits if that number has been exceeded,
 still however printing to the log file if indicated.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Warn #
\end_layout

\begin_layout Plain Layout

{ my($level,
 $msg) = @_;
\end_layout

\begin_layout Plain Layout

if($level > 3)
\end_layout

\begin_layout Plain Layout

  { $level = 3;
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  &BumpNewWarnings($level);
 # short-term record first
\end_layout

\begin_layout Plain Layout

  $WARNCOUNT[$level] ++;
 # bump warning count
\end_layout

\begin_layout Plain Layout

  my($stars) = '*' x $level;
  # Perl x operator
\end_layout

\begin_layout Plain Layout

if($WARNCOUNT[$level] < $WARNMAX[$level]) # if not too many warnings:
 
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    my($W) = 'WARNING';
\end_layout

\begin_layout Plain Layout

  if($level == 0) # minor
\end_layout

\begin_layout Plain Layout

    { $W = 'NOTE';
 
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

    &XPrint(0,
 "
\backslash
n  $stars $W $stars $msg");
 # reactivated,
 2021-03-12 
\end_layout

\begin_layout Plain Layout

    return;
\end_layout

\begin_layout Plain Layout

  } else
\end_layout

\begin_layout Plain Layout

  { # still print to log file!
 [ 2021-03-13 ]
\end_layout

\begin_layout Plain Layout

  if($level < $ERRORTHRESHOLD) # global test
\end_layout

\begin_layout Plain Layout

    { print $LOGFILE 
\begin_inset Quotes eld
\end_inset


\backslash
n$stars $msg
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

if($WARNCOUNT[$level] == $WARNMAX[$level])
\end_layout

\begin_layout Plain Layout

  { &XPrint(0,
 "
\backslash
n...suppressing level $level warnings ($WARNCOUNT[$level],
 too many)" );
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  # otherwise just ignore.
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Set Warning max
\begin_inset CommandInset label
LatexCommand label
name "subsec:Set-Warning-max-Setwarnmax"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SetWarnMax #
\end_layout

\begin_layout Plain Layout

{ my($i,
 $K) = @_;
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  $WARNMAX[$i] = $K;
 # might have sanity check on value [explore]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Summarise warnings
\begin_inset CommandInset label
LatexCommand label
name "subsec:Summarise-warnings"

\end_inset


\end_layout

\begin_layout Standard
Provide an array of the warning counts.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub ListWarnings #
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  # &XPrint(0,
 "
\backslash
nWarning counts:
 
\backslash
n -
\backslash
t*
\backslash
t**
\backslash
t***
\backslash
n " .
 join("
\backslash
t",@WARNCOUNT) );
 
\end_layout

\begin_layout Plain Layout

  return(@WARNCOUNT);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Short-term warning counts
\end_layout

\begin_layout Standard
Very simple at present,
 but we should consider recording the changes for the different levels,
 and not just a global count [explore].
 
\end_layout

\begin_layout Subsubsection
Clear the count
\begin_inset CommandInset label
LatexCommand label
name "subsec:Clear-the-count-warnings"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub ClearWarnings #
\end_layout

\begin_layout Plain Layout

{ $NEWWARNINGS = 0;
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Bump new warning
\end_layout

\begin_layout Standard
Used internally to increase warning count.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub BumpNewWarnings #
\end_layout

\begin_layout Plain Layout

{ my($level) = @_;
 # unused at present
\end_layout

\begin_layout Plain Layout

  $NEWWARNINGS ++;
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Get new warnings
\begin_inset CommandInset label
LatexCommand label
name "subsec:Get-new-warnings"

\end_inset


\end_layout

\begin_layout Standard
Note that once the
\emph on
 current instruction
\emph default
 is over,
 the value in 
\family typewriter
$NEWWARNINGS
\family default
 should be cleared
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
—
currently this is not however the case [explore]
\begin_inset Note Note
status open

\begin_layout Plain Layout
,
 after transfer to the pseudolocal $LOCALS{'wArnings'
\end_layout

\end_inset

}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub GetNewWarnings #
\end_layout

\begin_layout Plain Layout

{ return($NEWWARNINGS);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Log but don't print
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Log #
\end_layout

\begin_layout Plain Layout

{ my($msg) = @_;
\end_layout

\begin_layout Plain Layout

  print $LOGFILE $msg;
 # and keep a copy
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Log error
\end_layout

\begin_layout Standard
Much more selective —
 log severe errors:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub LogError #
\end_layout

\begin_layout Plain Layout

{ my($msg) = @_;
\end_layout

\begin_layout Plain Layout

  print $ERRORFILE "
\backslash
n$VERSION :
 $msg";
 # Keep a copy.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Database
\end_layout

\end_inset

Database Routines
\end_layout

\begin_layout Section
Fetch a new key
\end_layout

\begin_layout Standard
Generate a brand new key,
 with semaphore to prevent collisions.
 The auto-commit usual to MySQL has been turned off.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub FetchKey 
\end_layout

\begin_layout Plain Layout

{ my($tbl,
 $tag) = @_;
\end_layout

\begin_layout Plain Layout

  # NB.
 $USERID = global.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($handDB) = $DB_MAIN;
  # global too.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($count) = 0;
\end_layout

\begin_layout Plain Layout

while($count < 2000)  # arbitrary MAX
\end_layout

\begin_layout Plain Layout

  { $count ++;
\end_layout

\begin_layout Plain Layout

    my($now) = &ModTimeNow();
 # seconds 
\end_layout

\begin_layout Plain Layout

    my($later) = $now + $FETCHTIMEOUT;
 # seconds,
 unless a 64-bit system
\end_layout

\begin_layout Plain Layout

    my($q) = "UPDATE SKEYS 
\end_layout

\begin_layout Plain Layout

         SET klock = $later,
\end_layout

\begin_layout Plain Layout

             kuser = $USERID,
\end_layout

\begin_layout Plain Layout

             kValue = kValue + 1
\end_layout

\begin_layout Plain Layout

         WHERE kName = '$tbl' AND klock = 0";
\end_layout

\begin_layout Plain Layout

    my($ok) = &DoSQL($handDB,
 $q,
 $tag);
  # returns number of rows affected!
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that in the following SQL query,
 I cast the (BIGINT) result to a string.
\begin_inset Foot
status open

\begin_layout Plain Layout
MySQL won't cast to varchar,
 so use CHAR.
\end_layout

\end_inset

 This is solely to accommodate 32-bit systems,
 and if the user knows that the target system supports 64-bit integers 
\emph on
and
\emph default
 that a 64-bit compiler was used,
 then the cast can be removed.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  if($ok > 0)
\end_layout

\begin_layout Plain Layout

    { my($qget) = "SELECT kValue FROM SKEYS 
\end_layout

\begin_layout Plain Layout

               WHERE kName ='$tbl' 
\end_layout

\begin_layout Plain Layout

                 AND kuser=$USERID
\end_layout

\begin_layout Plain Layout

                 AND klock=$later";
\end_layout

\begin_layout Plain Layout

      my($j) = &GetSQL($handDB,
 $qget,
 
\begin_inset Quotes eld
\end_inset

GET '$tag'
\begin_inset Quotes erd
\end_inset

);
 
\end_layout

\begin_layout Plain Layout

      my($qput) = "UPDATE SKEYS SET klock = 0 
\end_layout

\begin_layout Plain Layout

               WHERE kName = '$tbl'
\end_layout

\begin_layout Plain Layout

                 AND kuser=$USERID
\end_layout

\begin_layout Plain Layout

                 AND klock = $later";
\end_layout

\begin_layout Plain Layout

      my($ok2) = &DoSQL($handDB,
 $qput,
 
\begin_inset Quotes eld
\end_inset

PUT '$tag'
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Plain Layout

    if($ok2 < 1)
\end_layout

\begin_layout Plain Layout

      { &XPrint(0,
  "Failed at reset of semaphore($tbl)
\backslash
n" );
  # [explore this]
\end_layout

\begin_layout Plain Layout

      };
\end_layout

\begin_layout Plain Layout

    if(!
 $j)
\end_layout

\begin_layout Plain Layout

      { &Aagh("Oops.
 Bad key generation ($j),
 matrix $tbl ($qget)",
 __LINE__,
 0 );
 
\end_layout

\begin_layout Plain Layout

        return;
 
\end_layout

\begin_layout Plain Layout

      };
 # must NOT return null key.
\end_layout

\begin_layout Plain Layout

       return($j);
  # success
\end_layout

\begin_layout Plain Layout

    } else 
\end_layout

\begin_layout Plain Layout

    { # check lock time:
\end_layout

\begin_layout Plain Layout

      my($qbad) = "SELECT klock FROM SKEYS WHERE kName ='$tbl'";
\end_layout

\begin_layout Plain Layout

      my($lck) = &GetSQL($handDB,
 $qbad,
 'get lock');
\end_layout

\begin_layout Plain Layout

    if(!
 $lck)
\end_layout

\begin_layout Plain Layout

      { &Aagh("Error.
 Bad key on $tbl ($qbad)",
 __LINE__,
 0 );
 
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

      };
\end_layout

\begin_layout Plain Layout

    # NB.
 klock value may now be ZERO!
\end_layout

\begin_layout Plain Layout

    if( ($lck < $now)
\end_layout

\begin_layout Plain Layout

       &&($lck > 0)
\end_layout

\begin_layout Plain Layout

      )    # if timed out AND not fixed
\end_layout

\begin_layout Plain Layout

      { my($qfix) = "UPDATE SKEYS SET klock = 0
\end_layout

\begin_layout Plain Layout

          WHERE kName = '$tbl' AND klock=$lck";
\end_layout

\begin_layout Plain Layout

        my($ok3) = &DoSQL($handDB,
 $qfix,
 
\begin_inset Quotes eld
\end_inset

UPDATE $tag
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Plain Layout

      if($ok3 < 1)
\end_layout

\begin_layout Plain Layout

        { &XPrint(0,
 "
\backslash
nBad semaphore fix $tbl($lck)");
 # [explore]
\end_layout

\begin_layout Plain Layout

        };
\end_layout

\begin_layout Plain Layout

        &XPrint(0,
 "
\backslash
nFETCH *FIX* debug SUCCESS");
 # [remove this line]
\end_layout

\begin_layout Plain Layout

      };
\end_layout

\begin_layout Plain Layout

      usleep( int(rand(10000)) );
 # microsleep up to 10ms
\end_layout

\begin_layout Plain Layout

    };
 # end else
\end_layout

\begin_layout Plain Layout

  };
  # end while
\end_layout

\begin_layout Plain Layout

  die("Error with key fetch on matrix $tbl");
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Fetch multiple keys
\begin_inset CommandInset label
LatexCommand label
name "subsec:Fetch-multiple-keys-Fetchmanykeys"

\end_inset


\end_layout

\begin_layout Standard
Similar to FetchKey
\begin_inset space ~
\end_inset

(),
 but returns 
\family typewriter
$j
\family default
,
 the topmost value in a sequence of keys,
 as requested in 
\family typewriter
$N
\family default
.
 It's the duty of the caller to generate keys from 
\family typewriter
$j
\family default
 downwards,
 of length 
\family typewriter
$N
\family default
.
 As &FetchKey
\begin_inset space ~
\end_inset

() is simply a special case of this,
 it should be made redundant or simply call this routine.
 
\emph on

\begin_inset Note Note
status open

\begin_layout Plain Layout

\emph on
[fix me]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub FetchManyKeys #
\end_layout

\begin_layout Plain Layout

{ my($tbl,
 $N);
\end_layout

\begin_layout Plain Layout

    ($tbl,
 $N)=@_;
\end_layout

\begin_layout Plain Layout

  # NB.
 $USERID = global.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($handDB) = $DB_MAIN;
  
\end_layout

\begin_layout Plain Layout

  my($tag) = 'fetch many';
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if( ($N > $MAXIMUM_KEY_FETCH)
\end_layout

\begin_layout Plain Layout

  ||($N < 1)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  { &Aagh("Can't fetch $N keys,
 max:
 $MAXIMUM_KEY_FETCH",
 __LINE__,
 0 );
 
\end_layout

\begin_layout Plain Layout

    return;
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($count) = 0;
\end_layout

\begin_layout Plain Layout

while($count < 200)  # arbitrary MAX number of tries
\end_layout

\begin_layout Plain Layout

  { $count ++;
\end_layout

\begin_layout Plain Layout

    my($now) = &ModTimeNow();
\end_layout

\begin_layout Plain Layout

    my($later) = $now + $FETCHTIMEOUT;
 # seconds,
 unless a 64-bit system
\end_layout

\begin_layout Plain Layout

    my($q) = "UPDATE SKEYS 
\end_layout

\begin_layout Plain Layout

         SET klock = $later,
\end_layout

\begin_layout Plain Layout

             kuser = $USERID,
\end_layout

\begin_layout Plain Layout

             kValue = kValue + $N
\end_layout

\begin_layout Plain Layout

         WHERE kName = '$tbl' AND klock = 0";
 # atomic
\end_layout

\begin_layout Plain Layout

    my($ok) = &DoSQL($handDB,
 $q,
 $tag);
  # returns number of rows affected!
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that in the following SQL query,
 I cast the (BIGINT) result to a string.
\begin_inset Foot
status open

\begin_layout Plain Layout
MySQL won't cast to varchar,
 so use CHAR.
\end_layout

\end_inset

 This is solely to accommodate 32-bit systems,
 and if the user knows that the target system supports 64-bit integers,
 then the cast can be removed.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  if($ok > 0)
\end_layout

\begin_layout Plain Layout

    { my($qget) = "SELECT kValue FROM SKEYS 
\end_layout

\begin_layout Plain Layout

               WHERE kName ='$tbl' 
\end_layout

\begin_layout Plain Layout

                 AND kuser=$USERID
\end_layout

\begin_layout Plain Layout

                 AND klock=$later";
\end_layout

\begin_layout Plain Layout

      my($j) = &GetSQL($handDB,
 $qget,
 'get top key');
 
\end_layout

\begin_layout Plain Layout

      my($qput) = "UPDATE SKEYS SET klock = 0 
\end_layout

\begin_layout Plain Layout

               WHERE kName = '$tbl'
\end_layout

\begin_layout Plain Layout

                 AND kuser=$USERID
\end_layout

\begin_layout Plain Layout

                 AND klock = $later";
 # release semaphore
\end_layout

\begin_layout Plain Layout

      my($ok2) = &DoSQL($handDB,
 $qput,
 'many put');
\end_layout

\begin_layout Plain Layout

    if($ok2 < 1)
\end_layout

\begin_layout Plain Layout

      { &XPrint(0,
  "Bad multiple key retrieval on semaphore($tbl)
\backslash
n" );
 
\end_layout

\begin_layout Plain Layout

      };
\end_layout

\begin_layout Plain Layout

    if(!
 $j)
\end_layout

\begin_layout Plain Layout

      { &Aagh("Oops.
 Bad multikey make ($j) for $tbl ($qget)",
 __LINE__,
 0 );
 
\end_layout

\begin_layout Plain Layout

        return;
 
\end_layout

\begin_layout Plain Layout

      };
 # must NOT return null key.
\end_layout

\begin_layout Plain Layout

       return($j);
  # success
\end_layout

\begin_layout Plain Layout

    } else 
\end_layout

\begin_layout Plain Layout

    { # check lock time:
\end_layout

\begin_layout Plain Layout

      my($qbad) = "SELECT klock FROM SKEYS WHERE kName ='$tbl'";
\end_layout

\begin_layout Plain Layout

      my($lck) = &GetSQL($handDB,
 $qbad,
 'get lock');
\end_layout

\begin_layout Plain Layout

    if(!
 $lck)
\end_layout

\begin_layout Plain Layout

      { &Aagh("Error.
 Bad key on $tbl ($qbad)",
 __LINE__,
 0);
 
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

      };
\end_layout

\begin_layout Plain Layout

     # NB.
 klock value may now be ZERO!
\end_layout

\begin_layout Plain Layout

    if( ($lck < $now)
\end_layout

\begin_layout Plain Layout

       &&($lck > 0)
\end_layout

\begin_layout Plain Layout

      )    # if timed out AND not fixed
\end_layout

\begin_layout Plain Layout

      { my($qfix) = "UPDATE SKEYS SET klock = 0
\end_layout

\begin_layout Plain Layout

          WHERE kName = '$tbl' AND klock=$lck";
\end_layout

\begin_layout Plain Layout

        my($ok3) = &DoSQL($handDB,
 $qfix,
 'many fix');
\end_layout

\begin_layout Plain Layout

      if($ok3 < 1)
\end_layout

\begin_layout Plain Layout

        { &XPrint(0,
 "
\backslash
nBad semaphore fix $tbl($lck)");
 # [hmm ?
 die] 
\end_layout

\begin_layout Plain Layout

        };
\end_layout

\begin_layout Plain Layout

        # &XPrint(0,
 "
\backslash
nFETCH *FIX* debug SUCCESS");
 # [?
 in production code]
\end_layout

\begin_layout Plain Layout

      };
\end_layout

\begin_layout Plain Layout

      usleep( int(rand(10000)) );
 # microsleep up to 10ms
\end_layout

\begin_layout Plain Layout

    };
 # end else
\end_layout

\begin_layout Plain Layout

  };
  # end while
\end_layout

\begin_layout Plain Layout

  &Aagh("Error with key fetch on matrix $tbl",
 __LINE__,
 0 );
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
GetSQL
\begin_inset CommandInset label
LatexCommand label
name "sec:GetSQL"

\end_inset


\end_layout

\begin_layout Standard
Given:
\end_layout

\begin_layout Description
myODBC the ODBC handle
\end_layout

\begin_layout Description
$Query an SQL query
\end_layout

\begin_layout Description
$tag a label used in error messages
\end_layout

\begin_layout Standard
Return a row of data from the query.
 There is no ordering of data—
SQL simply returns the first row encountered.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[ In the following,
 far more sensible would be to return the DBI_HANDLE from DoSQL
\begin_inset space ~
\end_inset

() and use iff DBI ] The global is truly dreadful.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub GetSQL #
\end_layout

\begin_layout Plain Layout

{ my($myODBC,
 $Query,
 $tag) = @_;
\end_layout

\begin_layout Plain Layout

  $SQLOK = 1;
\end_layout

\begin_layout Plain Layout

  if (&DoSQL($myODBC,
 $Query,
 $tag) < 0)  # failed
\end_layout

\begin_layout Plain Layout

     { # &XPrint(0,
 "SQL statement failed ($Query)" );
 
\end_layout

\begin_layout Plain Layout

       die 
\begin_inset Quotes eld
\end_inset

SQL statement failed '$tag'
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

       return "";
 # fail 
\end_layout

\begin_layout Plain Layout

     };
\end_layout

\begin_layout Plain Layout

  my(@newrow);
\end_layout

\begin_layout Plain Layout

  @newrow = ();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($USE_DBI)  # [explore $dbh->selectrow_array($stmt) ] 
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if(!
 defined $MY_DBI_HANDLE)
\end_layout

\begin_layout Plain Layout

    { print 
\begin_inset Quotes eld
\end_inset

Missing DBI handle for GetSQL,
 '$tag'
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

      undef @newrow;
 
\end_layout

\begin_layout Plain Layout

    } else
\end_layout

\begin_layout Plain Layout

    { @newrow = $MY_DBI_HANDLE->fetchrow_array();
 
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

  if( (!
 @newrow)
\end_layout

\begin_layout Plain Layout

    ||(scalar @newrow < 1)
\end_layout

\begin_layout Plain Layout

    ||($MY_DBI_HANDLE->err)
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

    { ## print 
\begin_inset Quotes eld
\end_inset

Debug GetSQL:
 <$Query> oops '$tag'
\backslash
n
\begin_inset Quotes erd
\end_inset

;
  
\end_layout

\begin_layout Plain Layout

      $SQLOK = 0;
\end_layout

\begin_layout Plain Layout

      @newrow = ();
 
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

  } else
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if ( $myODBC->FetchRow() )
\end_layout

\begin_layout Plain Layout

     { @newrow = $myODBC->Data();
 #first data row
\end_layout

\begin_layout Plain Layout

       ## print "
\backslash
n SQL debug:
 @newrow";
 
\end_layout

\begin_layout Plain Layout

     } else
\end_layout

\begin_layout Plain Layout

     { $SQLOK = 0;
\end_layout

\begin_layout Plain Layout

     };
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  return (@newrow);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Do SQL
\begin_inset CommandInset label
LatexCommand label
name "subsec:Do-SQL"

\end_inset


\end_layout

\begin_layout Standard
Given:
\end_layout

\begin_layout Description
myODBC the ODBC handle
\end_layout

\begin_layout Description
$Query an SQL query
\end_layout

\begin_layout Description
$tag a label used in error messages
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Execute an SQL statement that 
\emph on
does not
\emph default
 return a result.
 The main code:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://www.perlhowto.com/dbi_get_the_number_of_rows_affected_by_a_sql_statement
\end_layout

\begin_layout Plain Layout
DBI:
 
\end_layout

\begin_layout Plain Layout
hmm.
\end_layout

\begin_layout Plain Layout
my $rows = $dbh->do("DELETE FROM table WHERE count < '?'",
 undef,
 25);
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
\begin_inset Note Note
status open

\begin_layout Plain Layout

\emph on
[Note:
 http://stackoverflow.com/questions/93128/mysql-error-1153-got-a-packet-bigger-than-max-allowed-packet-bytes
\end_layout

\begin_layout Plain Layout
Must set max_allowed_packet to eg.
 100MB,
 but also parameterise output in writing,
 get rid of giant string]
\end_layout

\begin_layout Plain Layout

\series bold
\emph on
== also:
\end_layout

\begin_layout Plain Layout
http://blog.webyog.com/2009/08/10/mysql-server-has-gone-away-part-1-max_allowed_packet/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub DoSQL #
\end_layout

\begin_layout Plain Layout

{ $SQLOK=0;
 # default 'fail'
\end_layout

\begin_layout Plain Layout

  my($myODBC,
 $Query,
 $tag) = @_;
\end_layout

\begin_layout Plain Layout

  my($retcode) = 0;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(!
 defined $myODBC)
\end_layout

\begin_layout Plain Layout

  { die 
\begin_inset Quotes eld
\end_inset

Can't find handle '$tag'
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($USE_DBI)
\end_layout

\begin_layout Plain Layout

  { #NOT generally:
 $retcode = $myODBC->do($Query);
 
\end_layout

\begin_layout Plain Layout

    $MY_DBI_HANDLE = eval { $myODBC->prepare($Query) } or undef $MY_DBI_HANDLE;
 
\end_layout

\begin_layout Plain Layout

  if(defined $MY_DBI_HANDLE)
\end_layout

\begin_layout Plain Layout

    { $MY_DBI_HANDLE->execute() or $retcode = 1;
 
\end_layout

\begin_layout Plain Layout

           ## at present don't parameterize (no placeholders/bind values)
\end_layout

\begin_layout Plain Layout

    if($retcode) # [?
 also look into ->{Executed} attribute !]
\end_layout

\begin_layout Plain Layout

      { print 
\begin_inset Quotes eld
\end_inset

Debug:
 DBI error in DoSQL
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

        $retcode = $MY_DBI_HANDLE->err;
  # [hmm,
 ?
 rather use $h->state]
\end_layout

\begin_layout Plain Layout

      };
 
\end_layout

\begin_layout Plain Layout

    } else
\end_layout

\begin_layout Plain Layout

    { print 
\begin_inset Quotes eld
\end_inset

Woops!
 DBI cockup in DoSQL prepare stmt '$tag'.
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

      $retcode = $myODBC->err;
 # pick up error code
\end_layout

\begin_layout Plain Layout

      ## $retcode = $DBI::errstr;
\end_layout

\begin_layout Plain Layout

    if(!
 defined $retcode)
\end_layout

\begin_layout Plain Layout

      { print 
\begin_inset Quotes eld
\end_inset

No error code!
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

        $retcode = 1;
\end_layout

\begin_layout Plain Layout

      };
 
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

  } else # not using DBI:
 
\end_layout

\begin_layout Plain Layout

  { $retcode = $myODBC->Sql($Query);
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($retcode) # if problem 
\end_layout

\begin_layout Plain Layout

  { my($sqlErrors);
\end_layout

\begin_layout Plain Layout

  if($USE_DBI)
\end_layout

\begin_layout Plain Layout

    { $sqlErrors = $myODBC->errstr;
 
\end_layout

\begin_layout Plain Layout

    } else
\end_layout

\begin_layout Plain Layout

    { $sqlErrors = $myODBC->Error();
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    &XPrint(0,
 "
\backslash
n Oops!
 $sqlErrors code=$retcode ($tag):
 $Query");
 
\end_layout

\begin_layout Plain Layout

        # problem may be exceeding _max_allowed_packet rather than "has gone away"!
\end_layout

\begin_layout Plain Layout

  if($retcode < 1)
\end_layout

\begin_layout Plain Layout

    { # die "Woops!
 (Code=$retcode)";
   # [no,
 rely on caller to call &Aagh_() ]
\end_layout

\begin_layout Plain Layout

      return($retcode);
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

  if($sqlErrors !~ /
\backslash
[911
\backslash
].+
\backslash
[1
\backslash
].+
\backslash
[0
\backslash
]/ ) # NOT if 'no data' [911]
\end_layout

\begin_layout Plain Layout

        ## ^ the above will need revision for DBI.
 Explore.
 
\end_layout

\begin_layout Plain Layout

    { return(-1);
 # force failure
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

    return(0);
  # no data 
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # no problem,
 RETURN ROW COUNT
\end_layout

\begin_layout Plain Layout

  $SQLOK = 1;
\end_layout

\begin_layout Plain Layout

  if($USE_DBI)
\end_layout

\begin_layout Plain Layout

    { $retcode = $MY_DBI_HANDLE->rows;
       
\end_layout

\begin_layout Plain Layout

    } else
\end_layout

\begin_layout Plain Layout

    { $retcode = $myODBC->RowCount();
 
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

  ## &XPrint(0,
 "
\backslash
nDebug ($Query) rows affected=$retcode");
 
\end_layout

\begin_layout Plain Layout

if($retcode < 0)  # [hmm]
\end_layout

\begin_layout Plain Layout

  { $retcode = 0;
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  $retcode;
 # rows affected [?!]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
See http://www.roth.net/perl/odbc/docs/ODBC_Docs.htm#RowCount_
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Many SQL rows
\end_layout

\end_inset

Retrieve mutiple SQL rows
\begin_inset CommandInset label
LatexCommand label
name "sec:Retrieve-mutiple-SQL-SQLManySQL"

\end_inset


\end_layout

\begin_layout Standard
Arguments are:
\end_layout

\begin_layout Description
myODBC the ODBC handle
\end_layout

\begin_layout Description
$Query an SQL query
\end_layout

\begin_layout Description
$tag a label used in error messages
\end_layout

\begin_layout Standard
This returns multiple data rows,
 styled as a Perl array-of-arrays,
 with all of the associated legerdemain:
\begin_inset Note Note
status open

\begin_layout Plain Layout
[NB.
 In some versions of SQL Server at least,
 retrieval of float 0.000 results in <.000> for some reason] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SQLManySQL # 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

  my($myODBC,
 $Query,
 $tag) = @_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # introduce SQL constraint of CONSTRAIN:
\end_layout

\begin_layout Plain Layout

if(length $SQLCONSTRAINT > 0)
\end_layout

\begin_layout Plain Layout

  { $Query .= $SQLCONSTRAINT;
 # append.
 
\end_layout

\begin_layout Plain Layout

    # [Would not work if no 'WHERE' or is ORDER/GROUP clause]
\end_layout

\begin_layout Plain Layout

    ## print "
\backslash
n
\backslash
n
\backslash
n
\backslash
nDEBUGGING --CONSTRAINT-- <$Query>
\backslash
n
\backslash
n
\backslash
n";
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  # NO.
 do not say:
  $SQLCONSTRAINT = '';
 # once only
\end_layout

\begin_layout Plain Layout

  #     as then _direct_ will be affected under constraint.
 
\end_layout

\begin_layout Plain Layout

  #  CALLER MUST SAY:
 ClearSQLConstraint() when appropriate!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if( &DoSQL ( $myODBC,
 $Query,
 $tag ) < 0)
\end_layout

\begin_layout Plain Layout

  { &Aagh("Multiple retrieval failed ($Query)",
 __LINE__,
 0);
 
\end_layout

\begin_layout Plain Layout

    return;
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  my(@BIGARRAY) = ();
\end_layout

\begin_layout Plain Layout

  my(@big);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($USE_DBI)
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if(!
 defined $MY_DBI_HANDLE)
\end_layout

\begin_layout Plain Layout

    { print 
\begin_inset Quotes eld
\end_inset

Missing DBI handle for SQLManySQL,
 '$tag'
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

    } else
\end_layout

\begin_layout Plain Layout

    { @big = $MY_DBI_HANDLE->fetchrow_array();
 
\end_layout

\begin_layout Plain Layout

    while (  @big
\end_layout

\begin_layout Plain Layout

          && scalar @big > 0
\end_layout

\begin_layout Plain Layout

          && !
 $MY_DBI_HANDLE->err )
\end_layout

\begin_layout Plain Layout

      { push(@BIGARRAY,
 [ @big ]);
 # reference!
\end_layout

\begin_layout Plain Layout

        @big = $MY_DBI_HANDLE->fetchrow_array();
 
\end_layout

\begin_layout Plain Layout

      };
 
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

  } else
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  while ( $myODBC->FetchRow() )     #
\end_layout

\begin_layout Plain Layout

    { @big = $myODBC->Data();
     #get data
\end_layout

\begin_layout Plain Layout

      # @BIGARRAY = (@BIGARRAY,
 @big);
\end_layout

\begin_layout Plain Layout

      # NO!
 make an array of arrays:
\end_layout

\begin_layout Plain Layout

      push (@BIGARRAY,
 [ @big ]);
   # [] makes a reference!
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  return( @BIGARRAY);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Subsection
Sanitise string
\end_layout

\begin_layout Plain Layout
Clean up code so that e.g.
 quotes don't mess with SQL:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SanitiseString
\end_layout

\begin_layout Plain Layout

 { my($n);
\end_layout

\begin_layout Plain Layout

     ($n) = @_;
\end_layout

\begin_layout Plain Layout

  $n =~ s/[^!-~
\backslash
s]//g;
      # at present keep to ASCII [explore,
 NB.
 HMAC code gave trouble with fancy characters (why?)]
\end_layout

\begin_layout Plain Layout

  $n =~ s/'/''/g;
   # duplicate quote marks (better would be to parameterise) [FIX ME!]
\end_layout

\begin_layout Plain Layout

  $n =~ s/;/:/;
     # don't like semicolons
\end_layout

\begin_layout Plain Layout

  $n =~ s/[
\backslash
n
\backslash
r]/ /mg;
  # no carriage returns or line feeds
\end_layout

\begin_layout Plain Layout

  return($n);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
SQL constraint manipulation
\begin_inset CommandInset label
LatexCommand label
name "subsec:SQL-constraint-manipulation-clear"

\end_inset


\end_layout

\begin_layout Standard
Clear any existing constraint.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub ClearSQLConstraint #
\end_layout

\begin_layout Plain Layout

{ $SQLCONSTRAINT = '';
 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Append
\begin_inset CommandInset label
LatexCommand label
name "subsec:Append-SQL-constraint"

\end_inset


\end_layout

\begin_layout Standard
Multiple constrains can be ANDed together.
 There is currently no check that the constraint makes sense—
but in any case,
 keep this simple and avoid silly modifications.
 Some common sense is required in using this function.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub AppendSQLConstraint # 
\end_layout

\begin_layout Plain Layout

{ my($txt) = @_;
 
\end_layout

\begin_layout Plain Layout

  $SQLCONSTRAINT .= $txt;
 # if length > 0,
 constrains an SQL retrieval (WHERE clause)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Headline routines
\begin_inset CommandInset label
LatexCommand label
name "chap:Time-routines-headline"

\end_inset


\end_layout

\begin_layout Standard
The following `headline' routines are all externally available (exported).
 
\end_layout

\begin_layout Section
Timely
\begin_inset CommandInset label
LatexCommand label
name "sec:Timely"

\end_inset

 [REMOVED]
\end_layout

\begin_layout Standard
This functionality is now contained within 
\emph on
small_time_400.lyx
\emph default
.
 
\end_layout

\begin_layout Section
Find region
\begin_inset CommandInset label
LatexCommand label
name "subsec:Find-region"

\end_inset


\end_layout

\begin_layout Standard
Accepts:
\end_layout

\begin_layout Description
rgname The text name of the region e.g.
 Pacific/Auckland.
 This may be partial.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The values returned are the region code,
 the associated description (like `Pacific/Auckland') and the number of matches,
 relevant if a partial string was matched.
 The first value encountered in the database is returned as code and description.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[explore]
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
The database handle is obtained from the global 
\series bold
\emph on
f
\emph default
ehr
\series default
 handle $DB_MAIN.
 The addition of 
\family typewriter
AND reason > -1
\family default
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
2020-12-05
\end_layout

\end_inset

allows suppression of obsolete places.
 A further amendment 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
[7/12/2020]
\end_layout

\end_inset

 allows 
\family typewriter
$rgname
\family default
 to be the region number (as text)
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
[Perl doesn't care]
\end_layout

\end_inset

,
 in which case description is returned with that region,
 if found!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub FindRegion # 
\end_layout

\begin_layout Plain Layout

{ my($rgname) = @_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($handDB) = $DB_MAIN;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($q);
 
\end_layout

\begin_layout Plain Layout

  my($rgn,
 $desc) = (0,
 '');
 
\end_layout

\begin_layout Plain Layout

  my($hits);
 
\end_layout

\begin_layout Plain Layout

  my($showall) = 0;
 
\end_layout

\begin_layout Plain Layout

  my($exact) = 0;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($rgname =~ /
\backslash
?/ )  # contained ?
 means 'search and then show all names!' 
\end_layout

\begin_layout Plain Layout

  { $showall = 1;
\end_layout

\begin_layout Plain Layout

    $rgname =~ s/
\backslash
?//g;
 # remove the '?'s 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # use single or double quotes for exact match:
 e.g.
 for 'MST' EST EET and MET 
\end_layout

\begin_layout Plain Layout

if($rgname =~ /['
\begin_inset Quotes erd
\end_inset

]/ )  # contained ?
 means 'search and then show all names!' 
\end_layout

\begin_layout Plain Layout

  { $exact = 1;
\end_layout

\begin_layout Plain Layout

    $rgname =~ s/['
\begin_inset Quotes erd
\end_inset

]//g;
 # remove the quotes [imprecise but ok]
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($rgname =~ /^
\backslash
s*(
\backslash
d+)
\backslash
s*$/ )
\end_layout

\begin_layout Plain Layout

  { $q = "SELECT place,
 description FROM PLACES 
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Plain Layout

         .
 
\begin_inset Quotes eld
\end_inset

WHERE p_amended BETWEEN 1 and $TOPCOUNTRY "
\end_layout

\begin_layout Plain Layout

         .
 
\begin_inset Quotes eld
\end_inset

AND reason > -1 
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Plain Layout

         .
 "AND place = $1";
 
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

elsif( $rgname =~ /^
\backslash
s*([
\backslash
w
\backslash
/]+)
\backslash
s*$/ )
\end_layout

\begin_layout Plain Layout

  { $rgname = $1;
 
\end_layout

\begin_layout Plain Layout

  if($exact)
\end_layout

\begin_layout Plain Layout

    { $q = "SELECT place,
 description FROM PLACES 
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Plain Layout

         .
 
\begin_inset Quotes eld
\end_inset

WHERE p_amended BETWEEN 1 and $TOPCOUNTRY "
\end_layout

\begin_layout Plain Layout

         .
 
\begin_inset Quotes eld
\end_inset

AND reason > -1 
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Plain Layout

         .
 "AND description = '$rgname'";
 # exact match!
 
\end_layout

\begin_layout Plain Layout

    } else
\end_layout

\begin_layout Plain Layout

    { $q = "SELECT place,
 description FROM PLACES 
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Plain Layout

         .
 
\begin_inset Quotes eld
\end_inset

WHERE p_amended BETWEEN 1 and $TOPCOUNTRY "
\end_layout

\begin_layout Plain Layout

         .
 
\begin_inset Quotes eld
\end_inset

AND reason > -1 
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Plain Layout

         .
 "AND description LIKE '
\backslash
%$rgname
\backslash
%' ORDER BY description";
 #incl 1 = UTC
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

  { print 
\begin_inset Quotes eld
\end_inset

Bad search string '$rgname'
\backslash
n
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Plain Layout

        .
 
\begin_inset Quotes eld
\end_inset

Name can contain a-z A-Z _ and /
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

    return(0,'',0);
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my(@M) = &SQLManySQL($handDB,
 $q,
 'find multiple name matches');
 
\end_layout

\begin_layout Plain Layout

  $hits = scalar @M;
 
\end_layout

\begin_layout Plain Layout

if($hits)
\end_layout

\begin_layout Plain Layout

  { ($rgn,
 $desc) = ($M[0][0],
 $M[0][1]);
 # only use first row values 
\end_layout

\begin_layout Plain Layout

  if($showall)
\end_layout

\begin_layout Plain Layout

    { my($str) = '';
 
\end_layout

\begin_layout Plain Layout

      my($i) = 0;
 
\end_layout

\begin_layout Plain Layout

    while($i < $hits)
\end_layout

\begin_layout Plain Layout

      { $str .= $M[$i][1] .
 ' ';
 
\end_layout

\begin_layout Plain Layout

        $i ++;
 
\end_layout

\begin_layout Plain Layout

      };
\end_layout

\begin_layout Plain Layout

      print 
\begin_inset Quotes eld
\end_inset

Matches:
 $str
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  return($rgn,
 $desc,
 $hits);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Set region
\begin_inset CommandInset label
LatexCommand label
name "sec:Set-region"

\end_inset


\end_layout

\begin_layout Standard
From a primitive storage routine,
 this is now more sophisticated,
 from v 2.
 We:
\end_layout

\begin_layout Enumerate
Validate the region code and name;
\end_layout

\begin_layout Enumerate
retrieve all transition times from the 
\series bold
timely
\series default
 table,
 in order,
 and store these within 
\family typewriter
$MYTIMELY
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
For usage of 
\family typewriter
$MYTIMELY
\family default
,
 see QuickBetween
\begin_inset space ~
\end_inset

().
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

CREATE TABLE timely
\end_layout

\begin_layout Plain Layout

( timekey integer 
\end_layout

\begin_layout Plain Layout

    ,
 constraint timely_pk PRIMARY KEY(timekey)
\end_layout

\begin_layout Plain Layout

  ,region BIGINT
\end_layout

\begin_layout Plain Layout

    ,constraint timely_region_fk FOREIGN KEY (region)
\end_layout

\begin_layout Plain Layout

      references PLACES(place)
\end_layout

\begin_layout Plain Layout

  ,
 year integer
\end_layout

\begin_layout Plain Layout

  ,
 transition BIGINT
\end_layout

\begin_layout Plain Layout

  ,
 zone_offset BIGINT
\end_layout

\begin_layout Plain Layout

  ,
 dst BIGINT
\end_layout

\begin_layout Plain Layout

  ,
 ignored integer default 0
\end_layout

\begin_layout Plain Layout

  ,
 ver integer default 0
\end_layout

\begin_layout Plain Layout

  ,
 chk int
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub SetRegion #
\end_layout

\begin_layout Plain Layout

{ my($rgn) = @_;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # first,
 deal with UTC:
\end_layout

\begin_layout Plain Layout

if($rgn == $UTCCODE)
\end_layout

\begin_layout Plain Layout

  { undef($MYTIMELY);
 # <gosh>
\end_layout

\begin_layout Plain Layout

    $MYZONE = $rgn;
\end_layout

\begin_layout Plain Layout

    return;
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($handDB) = $DB_MAIN;
  
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Retrieve and save all 
\series bold
timely
\series default
 rows for this region:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  my ($qa) = 
\begin_inset Quotes eld
\end_inset

SELECT year,
 transition,
 dst,
 zone_offset,
 ignored 
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Plain Layout

           .
 
\begin_inset Quotes eld
\end_inset

FROM timely WHERE region = $rgn ORDER BY transition
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

  my(@TM) = &SQLManySQL( $handDB,
 $qa,
 
\begin_inset Quotes eld
\end_inset

fetch region ($rgn) details
\begin_inset Quotes erd
\end_inset

);
 # 
\end_layout

\begin_layout Plain Layout

if(scalar @TM < 1)
\end_layout

\begin_layout Plain Layout

  { &Aagh(
\begin_inset Quotes eld
\end_inset

Failed to retrieve region data for $rgn
\begin_inset Quotes erd
\end_inset

,
 __LINE__,
 0);
   # severe.
 
\end_layout

\begin_layout Plain Layout

    return;
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  $MYTIMELY = 
\backslash
@TM;
 # [?
 make this less clunky][fix me!] 
\end_layout

\begin_layout Plain Layout

  $MYZONE = $rgn;
 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
GetUtcCode
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub GetUtcCode #
\end_layout

\begin_layout Plain Layout

{ return($UTCCODE);
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Quick between
\begin_inset CommandInset label
LatexCommand label
name "subsec:Quick-between"

\end_inset


\end_layout

\begin_layout Standard
Given low and high years,
 quickly retrieves all rows that match,
 from 
\family typewriter
$MYTIMELY
\family default
,
 paring them down to the following columns,
 in order:
\end_layout

\begin_layout Quote
transition,
 dst,
 zone_offset,
 ignored.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Note that 
\family typewriter
$MYTIMELY
\family default
 is already sorted by SetRegion
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Set-region"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) in ascending order based on timekey,
 and that the only additional column is 
\series bold
year
\series default
.
 So the source columns with their indices are:
\end_layout

\begin_layout Description
0 year
\end_layout

\begin_layout Description
1 transition,
 proleptic Julian GPS microseconds 
\end_layout

\begin_layout Description
2 dst,
 microseconds
\end_layout

\begin_layout Description
3 zone_offset,
 microseconds
\end_layout

\begin_layout Description
4 ignored (0/1)
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
If there is no match,
 an empty array will be returned.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub QuickBetween # 
\end_layout

\begin_layout Plain Layout

{ my($lowY,
 $hiY) = @_;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my(@TM) = @{$MYTIMELY};
 # dereference [check efficiency ??][explore] 
\end_layout

\begin_layout Plain Layout

  my(@OUT) = ();
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($L) = scalar @TM;
 
\end_layout

\begin_layout Plain Layout

  ## print 
\begin_inset Quotes eld
\end_inset

Debug:
 number of rows in QuickBetween_() is $L
\backslash
n
\begin_inset Quotes eld
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($i) = 0;
 
\end_layout

\begin_layout Plain Layout

  my($thisY) = 0;
 
\end_layout

\begin_layout Plain Layout

  # this can be made faster by using a binary search to find low value.
 
\end_layout

\begin_layout Plain Layout

while( ($thisY <= $hiY) 
\end_layout

\begin_layout Plain Layout

     &&($i < $L) 
\end_layout

\begin_layout Plain Layout

     )
\end_layout

\begin_layout Plain Layout

  { my(@LN) = @{ $TM[$i] };
 # get row
\end_layout

\begin_layout Plain Layout

    $thisY = $LN[0];
 
\end_layout

\begin_layout Plain Layout

    ## print 
\begin_inset Quotes eld
\end_inset

[check:
 $thisY $lowY $hiY]
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

  if( ($thisY >= $lowY)
\end_layout

\begin_layout Plain Layout

    &&($thisY <= $hiY)
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

    { my(@F) = @LN[1..4];
 
\end_layout

\begin_layout Plain Layout

      ## print 
\begin_inset Quotes eld
\end_inset

ok!
 @F 
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

      push(@OUT,
 
\backslash
@F);
 # push the reference,
 ordered.
 Can't say 
\backslash
@LN[1..4] BTW.
 
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    $i ++;
 
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return(@OUT);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Local time
\begin_inset CommandInset label
LatexCommand label
name "subsec:Local-time-Getlocaltime"

\end_inset


\end_layout

\begin_layout Standard
Takes no arguments,
 but returns the current local (wall) time,
 retrieved from the system.
 The format is YYYY-MM-DD hh:mm:ss,
 as a string.
 The year is four decimal digits long,
 and if any other numeric value has under 2 digits,
 it's left-padded with a zero,
 for example 0 is rendered as 
\begin_inset Quotes eld
\end_inset

00
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub GetLocalTime # 
\end_layout

\begin_layout Plain Layout

{ my($sec,
 $min,
 $hour,
\end_layout

\begin_layout Plain Layout

      $mday,
 $mon,
 $year,
\end_layout

\begin_layout Plain Layout

      $wday,
 $yday,
 $isdst);
\end_layout

\begin_layout Plain Layout

  ($sec,
 $min,
 $hour,
\end_layout

\begin_layout Plain Layout

      $mday,
 $mon,
 $year,
\end_layout

\begin_layout Plain Layout

      $wday,
 $yday,
 $isdst) = CORE::localtime(time);
\end_layout

\begin_layout Plain Layout

  $year += 1900;
      #fix y2k :)
\end_layout

\begin_layout Plain Layout

  $sec  = &DoubleDigit($sec );
\end_layout

\begin_layout Plain Layout

  $min  = &DoubleDigit($min );
\end_layout

\begin_layout Plain Layout

  $hour = &DoubleDigit($hour);
\end_layout

\begin_layout Plain Layout

  $mday = &DoubleDigit($mday);
\end_layout

\begin_layout Plain Layout

  $mon  = &DoubleDigit($mon );
\end_layout

\begin_layout Plain Layout

  $mon ++;
            #january is zero!
\end_layout

\begin_layout Plain Layout

  return ("$year-$mon-$mday $hour:$min:$sec");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Julian
\begin_inset CommandInset label
LatexCommand label
name "sec:Julian"

\end_inset


\end_layout

\begin_layout Standard
Convert local,
 Gregorian time to Julian
\begin_inset space \thinspace{}
\end_inset

 microseconds.
 Accepts:
 
\end_layout

\begin_layout Description
$handDB The fehr database handle 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[No!
 make this internal!!] 
\end_layout

\end_inset


\end_layout

\begin_layout Description
$d a string in the format YYYY-MM-DD hh:mm:ss.ffffff
\end_layout

\begin_layout Standard
The returned value is a big integer in microseconds after the start of Julian
\begin_inset space \thinspace{}
\end_inset

 time,
 as proleptic GPS time rather than UTC,
 because the former ticks monotonically.
 Note that as fractional seconds do not depend on Julian
\begin_inset space \thinspace{}
\end_inset

 or Gregorian time,
 they should simply be retained.
 There is also an issue of what to do with the second value returned,
 the 
\begin_inset Quotes eld
\end_inset

shadow
\begin_inset Quotes erd
\end_inset

,
 which is:
\end_layout

\begin_layout Description
0 for normal values;
\end_layout

\begin_layout Description
-ve if the date supplied was invalid because it fell into a `limbo' period where daylight saving or zone time jumped forward.
 The size of the negative number indicates the duration of limbo;
 
\end_layout

\begin_layout Description
+ve if there is a second,
 equally valid Julian
\begin_inset space \thinspace{}
\end_inset

 time because daylight saving or zone has jumped back—
a `groundhog' hour.
 In this case (unlike tz) the first time is always returned,
 and the second can be obtained by adding the shadow value.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[explore the .ffffff ] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Julian # 
\end_layout

\begin_layout Plain Layout

{ my($d) = @_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(!
 $MYZONE)  # 0 is taken as an error
\end_layout

\begin_layout Plain Layout

  { &Aagh(
\begin_inset Quotes eld
\end_inset

For Julian_() you must first choose a region
\begin_inset Quotes erd
\end_inset

,
 __LINE__,
 0);
\end_layout

\begin_layout Plain Layout

    return;
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  my($zone) = $MYZONE;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(!defined $d)
\end_layout

\begin_layout Plain Layout

  { return(0);
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

if($d !~ /(
\backslash
d{4})-(
\backslash
d{2})-(
\backslash
d{2})[ T](
\backslash
d{2}):(
\backslash
d{2}):(
\backslash
d{2})
\backslash
.?(
\backslash
d*)/ )  # strict 
\end_layout

\begin_layout Plain Layout

  { return(0);
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  my($yyyy,
 $mm,
 $dd,
 $h,
 $m,
 $s,
 $ffffff) = ($1,
 $2,
 $3,
 $4,
 $5,
 $6,
 $7);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($JD,
 $shadow) = &G2J(1,
 $zone,
 $yyyy,
 $mm,
 $dd,
 $h,
 $m,
 $s);
  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # fix up the float:
\end_layout

\begin_layout Plain Layout

  my($micros) = &MicroSecs($ffffff);
 # not fractional;
 truncated not rounded.
 
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  return( $JD .
 $micros,
 $shadow );
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
MicroSecs
\end_layout

\begin_layout Standard
Given text digits 
\begin_inset Quotes eld
\end_inset

after the decimal point
\begin_inset Quotes erd
\end_inset

,
 convert to microseconds.
 Should always be six digits,
 right-padded if necessary,
 so for example 
\begin_inset Quotes eld
\end_inset

5
\begin_inset Quotes erd
\end_inset

 becomes 500000;
 
\begin_inset Quotes eld
\end_inset

003
\begin_inset Quotes erd
\end_inset

 becomes 
\begin_inset Quotes eld
\end_inset

003000
\begin_inset Quotes erd
\end_inset

;
 
\begin_inset Quotes eld
\end_inset

1234575
\begin_inset Quotes erd
\end_inset

 becomes 
\begin_inset Quotes eld
\end_inset

123457
\begin_inset Quotes erd
\end_inset

.
 Truncates fractional microseconds,
 doesn't round.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[What about the pathological [0.]0003005 ?
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub MicroSecs #
\end_layout

\begin_layout Plain Layout

{ my($d) = @_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($lF) = length $d;
 
\end_layout

\begin_layout Plain Layout

if($lF < 6) # will also deal with ''
\end_layout

\begin_layout Plain Layout

  { $d .= &Padding( '0',
 (6-$lF) );
  # we want 6 digits,
 even if zeroes.
 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

elsif($lF > 6)
\end_layout

\begin_layout Plain Layout

  { $d =~ substr($d,
 0,
 6);
 # truncate!
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  return($d);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Gregorian
\begin_inset CommandInset label
LatexCommand label
name "sec:Gregorian"

\end_inset


\end_layout

\begin_layout Standard
Given a Julian value in microseconds,
 turn into a Gregorian date for the current zone,
 with fractional seconds too.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Gregorian #
\end_layout

\begin_layout Plain Layout

{ my($JD) = @_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # zone:
\end_layout

\begin_layout Plain Layout

  my($zone) = $MYZONE;
 # global
\end_layout

\begin_layout Plain Layout

if(!
 $zone)
\end_layout

\begin_layout Plain Layout

  { &Aagh(
\begin_inset Quotes eld
\end_inset

Gregorian_() lacks zone
\begin_inset Quotes erd
\end_inset

,
 __LINE__,
 0);
 
\end_layout

\begin_layout Plain Layout

    return;
 
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # convert microseconds to seconds.
 
\end_layout

\begin_layout Plain Layout

  my($ffffff);
 
\end_layout

\begin_layout Plain Layout

if( $JD !~ /^(
\backslash
d+)(
\backslash
d{6})$/ )
\end_layout

\begin_layout Plain Layout

  { return('');
 # how do we fail ?
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  $JD = $1;
 # J2G_() requires seconds
\end_layout

\begin_layout Plain Layout

  $ffffff = $2;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($YYYY,$MM,$DD,
 $h,$m,$s,
 $dz,
 $dst,
 $hog,
 $deltz,
 $delds)
\end_layout

\begin_layout Plain Layout

     = &J2G(1,
 $zone,
 $JD);
 
\end_layout

\begin_layout Plain Layout

  return( &PrettyDate(0,$YYYY,$MM,$DD,
 $h,$m,$s) .
 
\begin_inset Quotes eld
\end_inset

.$ffffff
\begin_inset Quotes erd
\end_inset

 );
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Rejig Date
\begin_inset CommandInset label
LatexCommand label
name "subsec:Rejig-Date"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[Likely needs work,
 START WITH THE NAME!
 FormatDate
\begin_inset space ~
\end_inset

() ] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the date format is aberrant,
 try to fix this.
\end_layout

\begin_layout Quote
<YYYYMMDD> means split up and add 00:00:00,
 similar for
\end_layout

\begin_layout Quote
<YYYY-MM-DD> etc.
 
\end_layout

\begin_layout Standard
We also now permit:
\end_layout

\begin_layout Quote
<YYYY-MM-DD hh:mm>
\end_layout

\begin_layout Quote
<YYYY-MM-DD hh:mm:ss>
\end_layout

\begin_layout Quote
<DD/MM/YYYY hh:mm>
\end_layout

\begin_layout Quote
<DD/MM/YYYY hh:mm:ss>
\end_layout

\begin_layout Standard
Passing the entire string every time is inefficient,
 and a code might be used instead.
 Might even make a template regex where we intercalate 
\backslash
d for each Y M D (or even h m s).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub FormatDate
\end_layout

\begin_layout Plain Layout

{ my($template,
 $vlu) = @_;
\end_layout

\begin_layout Plain Layout

  my($YY,$MM,$DD);
\end_layout

\begin_layout Plain Layout

  my($h,$m,$s) = ('00','00','00');
 
\end_layout

\begin_layout Plain Layout

if($template eq 'YYYYMMDD')
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if($vlu !~ /(
\backslash
d{4})(
\backslash
d{2})(
\backslash
d{2})/)
\end_layout

\begin_layout Plain Layout

    { return('');
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    $YY = $1;
\end_layout

\begin_layout Plain Layout

    $MM = $2;
\end_layout

\begin_layout Plain Layout

    $DD = $3;
 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  # might insert variants on the above here,
 if required
\end_layout

\begin_layout Plain Layout

elsif($template eq 'MM-DD-YYYY')
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if($vlu !~ /(
\backslash
d{2})[.
\backslash
/-](
\backslash
d{2})[.
\backslash
/-](
\backslash
d{4})/ )
\end_layout

\begin_layout Plain Layout

    { return('');
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    $YY = $3;
\end_layout

\begin_layout Plain Layout

    $MM = $1;
\end_layout

\begin_layout Plain Layout

    $DD = $2;
 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

elsif($template eq 'DD-MM-YYYY')
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if($vlu !~ /(
\backslash
d{2})[.
\backslash
/-](
\backslash
d{2})[.
\backslash
/-](
\backslash
d{4})/)
\end_layout

\begin_layout Plain Layout

    { return('');
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    $YY = $3;
\end_layout

\begin_layout Plain Layout

    $MM = $2;
\end_layout

\begin_layout Plain Layout

    $DD = $1;
 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

elsif($template eq 'YYYY-MM-DD')
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if($vlu !~ /(
\backslash
d{4})[.
\backslash
/-](
\backslash
d{2})[.
\backslash
/-](
\backslash
d{2})/)
\end_layout

\begin_layout Plain Layout

    { return('');
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    $YY = $1;
\end_layout

\begin_layout Plain Layout

    $MM = $2;
\end_layout

\begin_layout Plain Layout

    $DD = $3;
 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Further formats.
 Note that although we 
\emph on
must 
\emph default
use the - separator in the 
\emph on
specification
\emph default
,
 the actual text can use '.',
 '-' or '/'.
 We ignore fractional seconds.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

elsif($template eq 'YYYY-MM-DD hh:mm:ss')
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if($vlu !~ /(
\backslash
d{4})[.
\backslash
/-](
\backslash
d{2})[.
\backslash
/-](
\backslash
d{2}) (
\backslash
d{2}):(
\backslash
d{2}):(
\backslash
d{2})/)
\end_layout

\begin_layout Plain Layout

    { return('');
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    $YY = $1;
\end_layout

\begin_layout Plain Layout

    $MM = $2;
\end_layout

\begin_layout Plain Layout

    $DD = $3;
 
\end_layout

\begin_layout Plain Layout

    $h = $4;
\end_layout

\begin_layout Plain Layout

    $m = $5;
\end_layout

\begin_layout Plain Layout

    $s = $6;
 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
no seconds:
 
\emph on

\begin_inset Note Note
status open

\begin_layout Plain Layout

\emph on
[consider making these optional —
 explore]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

elsif($template eq 'YYYY-MM-DD hh:mm')
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if($vlu !~ /(
\backslash
d{4})[.
\backslash
/-](
\backslash
d{2})[.
\backslash
/-](
\backslash
d{2}) (
\backslash
d{2}):(
\backslash
d{2})/)
\end_layout

\begin_layout Plain Layout

    { return('');
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    $YY = $1;
\end_layout

\begin_layout Plain Layout

    $MM = $2;
\end_layout

\begin_layout Plain Layout

    $DD = $3;
 
\end_layout

\begin_layout Plain Layout

    $h = $4;
\end_layout

\begin_layout Plain Layout

    $m = $5;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
UK/NZ dates:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

elsif($template eq 'DD-MM-YYYY hh:mm:ss')
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if($vlu !~ /(
\backslash
d{2})[.
\backslash
/-](
\backslash
d{2})[.
\backslash
/-](
\backslash
d{4}) (
\backslash
d{2}):(
\backslash
d{2}):(
\backslash
d{2})/)
\end_layout

\begin_layout Plain Layout

    { return('');
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    $DD = $1;
\end_layout

\begin_layout Plain Layout

    $MM = $2;
\end_layout

\begin_layout Plain Layout

    $YY = $3;
 
\end_layout

\begin_layout Plain Layout

    $h = $4;
\end_layout

\begin_layout Plain Layout

    $m = $5;
\end_layout

\begin_layout Plain Layout

    $s = $6;
 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
UK without seconds:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

elsif($template eq 'DD-MM-YYYY hh:mm')
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if($vlu !~ /(
\backslash
d{2})[.
\backslash
/-](
\backslash
d{2})[.
\backslash
/-](
\backslash
d{4}) (
\backslash
d{2}):(
\backslash
d{2})/)
\end_layout

\begin_layout Plain Layout

    { return('');
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    $DD = $1;
\end_layout

\begin_layout Plain Layout

    $MM = $2;
\end_layout

\begin_layout Plain Layout

    $YY = $3;
 
\end_layout

\begin_layout Plain Layout

    $h = $4;
\end_layout

\begin_layout Plain Layout

    $m = $5;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
US:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

elsif($template eq 'MM-DD-YYYY hh:mm:ss')
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if($vlu !~ /(
\backslash
d{2})[.
\backslash
/-](
\backslash
d{2})[.
\backslash
/-](
\backslash
d{4}) (
\backslash
d{2}):(
\backslash
d{2}):(
\backslash
d{2})/)
\end_layout

\begin_layout Plain Layout

    { return('');
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    $MM = $1;
\end_layout

\begin_layout Plain Layout

    $DD = $2;
\end_layout

\begin_layout Plain Layout

    $YY = $3;
 
\end_layout

\begin_layout Plain Layout

    $h = $4;
\end_layout

\begin_layout Plain Layout

    $m = $5;
\end_layout

\begin_layout Plain Layout

    $s = $6;
 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
US without seconds:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

elsif($template eq 'MM-DD-YYYY hh:mm')
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

  if($vlu !~ /(
\backslash
d{2})[.
\backslash
/-](
\backslash
d{2})[.
\backslash
/-](
\backslash
d{4}) (
\backslash
d{2}):(
\backslash
d{2})/)
\end_layout

\begin_layout Plain Layout

    { return('');
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

    $MM = $1;
\end_layout

\begin_layout Plain Layout

    $DD = $2;
\end_layout

\begin_layout Plain Layout

    $YY = $3;
 
\end_layout

\begin_layout Plain Layout

    $h = $4;
\end_layout

\begin_layout Plain Layout

    $m = $5;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\SpecialChar ldots
 or fail:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

  { &Aagh("Unknown _julian_ date format option <$template>",
 __LINE__,
 0);
 
\end_layout

\begin_layout Plain Layout

    return;
  # need smarter approach here,
 more options
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  return("$YY-$MM-$DD $h:$m:$s");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Core code
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Gregorian to Julian
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[NOTE THERE'S LIKELY AN ERROR IN THE DATE CALCULATIONS FOR THE START AND END OF YEAR IN THE DATABASE-POPULATING ROUTINES.
 THESE MUST REFER TO WALL TIME YEAR START AND END]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are some catches in turning a `conventional' Gregorian date to a Julian value:
 
\end_layout

\begin_layout Enumerate
Some apparently valid,
 DST-adjusted timestamps may not exist (There's a skipped interval at the start of DST;
 this is also potentially a problem where there's a transition in the zone offset);
\end_layout

\begin_layout Enumerate
There's a 
\begin_inset Quotes eld
\end_inset

groundhog hour
\begin_inset Quotes erd
\end_inset

 (or partial hour) at the end of DST,
 so a supplied timestamp may have two possible `candidate' Julian timestamps.
\end_layout

\begin_layout Enumerate
The conversion of the apparent Julian timestamp depends on GPS reference times,
 but in order to make this determination,
 you logically need to convert to GPS first!
\end_layout

\begin_layout Standard
We accommodate these as follows:
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[NBNBNB ARE THE YEARS IN THE DATABASE REALLY GPS YEARS OR UTC YEARS ?????????????????????????????????????]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Determine the year and zone,
 retrieve the relevant database row.
 As the year always refers to Gregorian wall time,
 this will be the correct row.
 
\end_layout

\begin_layout Enumerate
Convert the Gregorian date G to a Julian day number K.
 This date however may contain a non-zero zone offset,
 and a non-zero daylight saving time value.
 We need to get rid of these:
\end_layout

\begin_layout Enumerate
Create M = K - zone_offset,
 also clear the transition flag T = 0;
 
\end_layout

\begin_layout Enumerate
If 
\series bold
zone_transition
\series default
 is not zero,
 calculate N = K - zone_future:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
If M and N are both < zone_transition,
 use M;
\end_layout

\begin_layout Enumerate
else,
 if M and N are both >= zone_transition,
 set M = N and T =1;
\end_layout

\begin_layout Enumerate
else,
 they are discrepant.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
If M > zone transition then N must be less.
 This implies that at the transition,
 the Gregorian (wall) time skipped back,
 so we have a `groundhog' period.
 Retain M,
 but set T =1;
 [CHECK THE LOGIC HERE]
\end_layout

\begin_layout Enumerate
else,
 there must be have been a gap when we changed from zone_offset to zone_future,
 in other words,
 the Gregorian wall time represents an error.
 Signal this [Can we be sure that the specified time is in the gap?
 CHECK ME!]
\end_layout

\end_deeper
\begin_layout Enumerate
[THERE IS STILL A POTENTIAL PROBLEM WITH DST influencing the above.
 EXPLORE]
\end_layout

\end_deeper
\begin_layout Enumerate
Determine the existing DST offset D.
 Initially assume there's no DST active,
 so set D = 0:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if 
\series bold
dst_start
\series default
 and 
\series bold
dst_end
\series default
 are both zero,
 this D=0 assumption is valid;
\end_layout

\begin_layout Enumerate
else if 
\series bold
dst_start
\series default
 is zero,
 by (a) dst_end is non-zero,
 and we have carry over from the previous year to terminate DST at 
\series bold
dst_end
\series default
:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if M >= 
\series bold
dst_end
\series default
+
\series bold
prior_add
\series default
,
 then no DST (We add prior_add,
 as anything between dst_end and dst_end+prior add must be in the groundhog hour,
 so we just assume DST)
\end_layout

\begin_layout Enumerate
else D = 
\series bold
prior_add
\series default
.
\end_layout

\end_deeper
\begin_layout Enumerate
If 
\series bold
dst_end
\series default
 is zero,
 then we begin DST in this year,
 and continue to the next:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if M >= dst_start,
 then we are in DST,
 and D = dst_add;
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
else if M >= dst_start-dst_add,
 then report an error (no-go);
\end_layout

\begin_layout Enumerate
else leave D = 0.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
else if 
\series bold
dst_start
\series default
 < 
\series bold
dst_end
\series default
 we're in the northern hemisphere:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if M < 
\series bold
dst_start
\series default
,
 it is possible that M is in the 
\begin_inset Quotes eld
\end_inset

no-go
\begin_inset Quotes erd
\end_inset

 area which can't exist as DST would have been added:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if M is also < (dst_start - dst_add),
 then leave D=0,
 we're not in daylight saving;
\end_layout

\begin_layout Enumerate
Otherwise,
 report an error,
 as this time doesn't exist!
\end_layout

\end_deeper
\begin_layout Enumerate
if M >= 
\series bold
dst_end:
\series default

\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
If M is also >= (dst_end + dst_add),
 then leave D = 0,
 as we're definitely not in daylight saving;
\end_layout

\begin_layout Enumerate
Otherwise,
 there are two candidate Julian times that correspond to our Gregorian-esque value.
 Assume the earlier,
 i.e.
 D = 
\series bold
dst_add
\series default
.
 Practically,
 we can unite A.
 and B.
 into a test for M >= dst_end+dst_add,
 failing which D = dst_add.
\end_layout

\end_deeper
\begin_layout Enumerate
else D = 
\series bold
dst_add
\series default
;
\end_layout

\end_deeper
\begin_layout Enumerate
else we are in the S hemisphere:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if M < dst_end,
 we are in DST from the preceding year,
 and D = 
\series bold
prior_add
\series default
;
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if M < dst_end + prior_add,
 there are two candidates,
 as above.
 Assume D = 
\series bold
prior_add
\series default
.
 Practically,
 we can once more unite A and B into:
 if M < dst_end+prior_add,
 D=prior_add;
\end_layout

\end_deeper
\begin_layout Enumerate
else if M >= dst_start+dst_add,
 we are in DST starting in this year.
 D = 
\series bold
dst_add
\series default
;
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if however M >= dst_start,
 report an error,
 as this is a no-go time!
\end_layout

\end_deeper
\begin_layout Enumerate
Otherwise,
 leave D = 0.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Adjust M by 
\emph on
subtracting
\emph default
 D (which may be zero);
\end_layout

\begin_layout Enumerate
also adjust for leap seconds using the relevant UTC (leap-second-adjusted) leap time cutoff,
 calling this J.
 
\end_layout

\begin_layout Enumerate
If zone_transition is nonzero,
 re-check J against this value.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
If T == 0 and J < zone transition,
 ok;
\end_layout

\begin_layout Enumerate
If T == 1 and J >= zone_transition,
 ok;
\end_layout

\begin_layout Enumerate
Otherwise [EXPLORE THE PROBLEM,
 this is to accommodate the possibility that our interpretation of the cutoff was skewed by failing to accommodate DST.
 BUT NOTE that the DST criteria themselves may in turn have been affected by an erroneous value related to zone_transition.
 A mess.
 [fix me!] ]
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Problems with the above [check me]
\end_layout

\begin_layout Itemize
If the date is invalid (in the gap) ?
\end_layout

\begin_layout Itemize
If the date is potentially a duplicate (groundhog hour) ?
\end_layout

\begin_layout Itemize
When should we add U?
 Am I stuffing this up?
\end_layout

\begin_layout Itemize
NB.
 The cutoffs are based on GPS time
\end_layout

\begin_layout Itemize
Other?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
G2J
\end_layout

\begin_layout Standard
Using the internal 
\series bold
\emph on
f
\emph default
ehr
\series default
 database handle,
 take the supplied internal zone ID and Gregorian date (as components) and return two things:
 the corresponding Julian date,
 and a 
\begin_inset Quotes eld
\end_inset

Shadow
\begin_inset Quotes erd
\end_inset

 value,
 ordinarily zero,
 unless we're dealing with a 
\begin_inset Quotes eld
\end_inset

special case
\begin_inset Quotes erd
\end_inset

,
 of which there are two:
\end_layout

\begin_layout Enumerate
Because there is a gap (zone of limbo) after any point where delta T (
\begin_inset Formula $\Delta T$
\end_inset

),
 the sum of the change in zone offset (Z) and the daylight saving time (D),
 is over zero,
 some supplied Gregorian timestamps can be invalid.
\end_layout

\begin_layout Enumerate
There is a re-run of time (groundhog zone) around the time of a backwards transition—
where the sum of the above changes is less than zero.
 Therefore,
 one Gregorian timestamp will here correspond to two Julian times.
 Conventionally,
 tz software always returns the later of these two,
 when asked to discriminate.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
I thus:
\end_layout

\begin_layout Enumerate
Signal a limbo time (error) by returning the imputed Julian time accompanied by a 
\emph on
negative
\emph default
 
\begin_inset Formula $\Delta T$
\end_inset

 as the shadow value.
 
\end_layout

\begin_layout Enumerate
Signal a groundhog time by returning the 
\emph on
earlier
\emph default
 matching Julian time (not the later one,
 as tz software does),
 as well as a positive value in 
\begin_inset Formula $\Delta T$
\end_inset

,
 the returned shadow value.
 This allows resynthesis of both values.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Because of the vagaries of time zones and daylight saving,
 there are discontinuities at transitions.
 If DST or the zone offset Z decreases at the transition,
 then there will be a 
\begin_inset Quotes eld
\end_inset

groundhog hour
\begin_inset Quotes erd
\end_inset

 where the hour is played again;
 if either `springs ahead',
 then there will be a period within which there is no valid wall time.
\end_layout

\end_inset

In more detail:
\end_layout

\begin_layout Enumerate
Convert the Gregorian YYYY-MM-DD h:m:s to a corresponding UTC timestamp,
 expressed as Julian microseconds (not yet as GPS time)
\end_layout

\begin_deeper
\begin_layout Enumerate
Call this converted timestamp 
\begin_inset Quotes eld
\end_inset

JBIG
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Enumerate
If the desired zone is 
\begin_inset Quotes eld
\end_inset

UTC
\begin_inset Quotes erd
\end_inset

,
 simply return JBIG after converting to proleptic Julian GPS time a seconds,
 and adjusting for GPS.
 
\end_layout

\end_deeper
\begin_layout Enumerate
For the relevant zone,
 from the database retrieve all data for the years 
\begin_inset Quotes eld
\end_inset

around
\begin_inset Quotes erd
\end_inset

 the desired year.
 These data extend from the start of the previous year,
 to two years in the future,
 up to the last timestamp in December of that year.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Note that in the 
\series bold
timely
\series default
 table,
 we will always have at least one apparent transition per year,
 even if there is no formal transition,
 as one will have been intercalated for December 31 at 23:59:59,
 local (wall) time.
 Therefore there will be at least one timestamp prior to the current time,
 and because of the above sampling,
 there will be at least two for the period after the end of the target year.
\end_layout

\begin_layout Enumerate
All Z (zone offset) and DST (daylight saving) values in the database are signed,
 in microseconds.
 Each pair of values for a given row applies prior to the transition time (let's call this 
\begin_inset Quotes eld
\end_inset

tr
\begin_inset Quotes erd
\end_inset

),
 from the preceding transition.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Work upwards,
 examining each transition time in the database until JBIG is greater than tr.
 The logical approach is to compare tr with the JBIG,
 adjusted as follows:
 
\begin_inset Formula 
\[
J\mathrm{_{BIG}}-\left(Z\mathrm{_{tr}}+\mathrm{DST}\mathrm{_{tr}}\right)<\mathrm{tr}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
This removes the influence of these variables on the wall time,
 and should give us the corresponding UTC time.
 So with this adjustment,
 if the test holds,
 we have located the interval into which JBIG falls.
 
\end_layout

\end_deeper
\begin_layout Enumerate
This naive approach is however problematic because:
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Each transition time is in proleptic GPS Julian microseconds,
 but JBIG is not yet adjusted in the minor way needed for GPS;
 this is easily done.
\end_layout

\begin_layout Enumerate
The very fact that we use Z and DST implies that these are assumed to be valid—
but the values may change the interpretation of the result!
 
\end_layout

\begin_layout Enumerate
Transitions may follow rapidly after one another,
 even if we exclude the added complexity of the intercalated end-of-year transition.
 
\end_layout

\end_deeper
\begin_layout Enumerate
The following observations are thus relevant.
 First,
 assume that the adjusted timestamp is valid.
 Then check this assumption.
 There appear to be several not-completely-exclusive possibilities:
\end_layout

\begin_deeper
\begin_layout Enumerate
The 
\emph on
preceding
\emph default
 interval was correct.
 The problem with this option is that the antecedent calculation (we have that year at the start) did not show this to be the case;
 our refutation is wrong.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[CHECK THIS WITH AN EXAMPLE]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
The current 
\emph on
is 
\emph default
correct.
 This is quite possible,
 and does not exclude the possibility that there is a second valid wall time after the transition.
 For example,
 if daylight saving ends on 27 September at 02:00 (wall time),
 then two Julian dates will correspond to a wall time of 01:30 on that day,
 one before the transition,
 and one after.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
There is also the fairly trivial case where 
\begin_inset Formula $\left(Z'+\mathrm{DST}'\right)=\left(Z+\mathrm{DST}\right)$
\end_inset

.
 There are two sub-cases here:
\end_layout

\begin_deeper
\begin_layout Enumerate
The change in Z balances the change in DST.
 Time ticks monotonously,
 the adjustment is valid.
 
\end_layout

\begin_layout Enumerate
We're in the interval after a 
\begin_inset Quotes eld
\end_inset

December prosthetic
\begin_inset Quotes erd
\end_inset

 transition (Ordinarily there shouldn't be a proper 
\begin_inset Quotes eld
\end_inset

transition
\begin_inset Quotes erd
\end_inset

 if no change occurred).
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[EXPLORE IN DETAIL,
 especially 2 of the December buggers in a row.
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
A future timestamp may be correct but our calculated one isn't,
 in other words,
 the actual timestamp has been inappropriately 
\begin_inset Quotes eld
\end_inset

pulled back
\begin_inset Quotes erd
\end_inset

 before tr when we added Z and DST.
 Logically,
 this refutation can only have happened if we're close to tr,
 the sum of Z and DST is positive—
so that subtraction of this sum yanks things back before the transition—

\emph on
and
\emph default
 the sum of Z' and DST' (the adjustments for the 
\emph on
next
\emph default
 interval,
 tr') is less than the prior sum.
 As this all seems a bit speculative,
 consider the case where the 
\begin_inset Quotes eld
\end_inset

proper
\begin_inset Quotes erd
\end_inset

 timestamp is 1 minute after tr,
 and Z+DST for tr is 
\begin_inset Formula $60$
\end_inset

 minutes.
 This will indeed pull JBIG back before tr,
 as the positive value is subtracted.
 Next,
 assume that Z'+DST' is say,
 zero.
 But this implies that we have a 
\begin_inset Quotes eld
\end_inset

groundhog hour
\begin_inset Quotes erd
\end_inset

,
 so there will be two timestamps corresponding to the wall time,
 and tr will be pulled back,
 refuting the assumption that our calculated timestamp is invalid.
 This applies more generally than our example,
 whenever 
\begin_inset Formula $\left(Z'+\mathrm{DST}'\right)<\left(Z+\mathrm{DST}\right)$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
Finally,
 what of the case where our wall time is invalid—
it falls into a gap?
 This can only occur if there's a gap,
 in other words 
\begin_inset Formula $\left(Z'+\mathrm{DST}'\right)>\left(Z+\mathrm{DST}\right)$
\end_inset

.
 Let's assume that the spurious JBIG is invalid because it refers to a non-existent time 
\begin_inset Quotes eld
\end_inset

in limbo
\begin_inset Quotes erd
\end_inset

.
 A simple example is where Z is zero (or unchanged) and we start summer time,
 DST going from 0 to 60 minutes,
 at 02:00.
 A wall time of 02:01 is in limbo.
 Now how is this value treated before and after the transition?
 In the antecedent period,
 were the time valid,
 the usual 
\begin_inset Formula $J\mathrm{_{BIG}}-\left(Z\mathrm{_{tr}}+\mathrm{DST}\mathrm{_{tr}}\right)$
\end_inset

 adjustment would have put the time before tr,
 but with the same approach,
 the invalid time will appear to be after tr.
 However,
 in the new interval for tr',
 because of the above inequality,
 under the new rules the time will be moved 
\emph on
before
\emph default
 the transition,
 and also be invalid!
 
\end_layout

\end_deeper
\begin_layout Enumerate
A further problem might be where one transition rapidly follows another:
\begin_inset Note Note
status open

\begin_layout Plain Layout
[ANALYSE THIS HERE]
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
From the above logic,
 this should work:
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Work upwards,
 for each interval adjusting JBIG by subtracting 
\begin_inset Formula $\left(Z+\mathrm{DST}\right)$
\end_inset

.
 Call this adjusted value JX.
 
\end_layout

\begin_layout Enumerate
If this value is < tr,
 we have a potential winner:
\end_layout

\begin_deeper
\begin_layout Enumerate
If however the value is < the antecedent tr,
 the time is in limbo:
 signal this failure by returning JX and a 
\emph on
negative 
\emph default
second value (a `Negative Shadow',
 the magnitude of which is the size of the gap,
 i.e.
 
\begin_inset Formula $\left(Z+\mathrm{DST}\right)-\left(Z^{-1}+\mathrm{DST}^{-1}\right)$
\end_inset

 which will be negative).
 
\end_layout

\begin_layout Enumerate
Otherwise,
 determine Delta,
 i.e.
 
\begin_inset Formula $\left(Z+\mathrm{DST}\right)-\left(Z'+\mathrm{DST}'\right)$
\end_inset

 and add this `Shadow' value to JX.
 If this sum exceeds tr,
 then we have a groundhog value.
 Signal this by returning the unadjusted JX and the (positive) Shadow value.
 
\end_layout

\begin_layout Enumerate
If none of the above applies,
 return JX and a Shadow of zero.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Minor factors are the use of and adjustment for GPS time,
 and the fact that we wish to return both of our results as (Julian) seconds,
 not microseconds.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub G2J #
\end_layout

\begin_layout Plain Layout

{ my($qik,
 $zone,
 $YY,
 $MM,
 $DD,
 $h,
 $m,
 $s) = @_;
 # no fractional seconds 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  my($handDB) = $DB_MAIN;
  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if( $qik
\end_layout

\begin_layout Plain Layout

  &&($zone != $MYZONE) # check it's the right region,
 D'Oh!
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  { &Aagh(
\begin_inset Quotes eld
\end_inset

Can't do quick retrieval,
 mismatched zones:
 $zone|$MYZONE
\begin_inset Quotes erd
\end_inset

,
 __LINE__,
 0);
 
\end_layout

\begin_layout Plain Layout

    return;
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Retrieve the relevant database values into the array 
\family typewriter
@ROWS
\family default
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[must explore how we speed this]
\end_layout

\end_inset

 Formerly,
 we used to laboriously perform an SQL query;
 now we simply use the value in 
\family typewriter
$MYTIMELY
\family default
,
 instantiated by SetRegion
\begin_inset space ~
\end_inset

().
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  my(@ROWS);
\end_layout

\begin_layout Plain Layout

  my($hi) = 2 + int($YY);
  # high year limit
\end_layout

\begin_layout Plain Layout

  my($lo) =-1 + int($YY);
  # low year   
\end_layout

\begin_layout Plain Layout

if($qik)  # $zone is redundant 
\end_layout

\begin_layout Plain Layout

  { (@ROWS) = &QuickBetween($lo,
 $hi);
 # get tr,
 dst,
 zo,
 ignored from $MYTIMELY 
\end_layout

\begin_layout Plain Layout

  } else
\end_layout

\begin_layout Plain Layout

  { my($q) = "SELECT transition,
 dst,
 zone_offset,
 ignored from timely "
\end_layout

\begin_layout Plain Layout

      .
 "WHERE region = $zone AND year BETWEEN $lo AND $hi ORDER BY transition";
 # ASC 
\end_layout

\begin_layout Plain Layout

      # ENCOMPASSES year of interest!
\end_layout

\begin_layout Plain Layout

    (@ROWS) = &SQLManySQL($handDB,
 $q,
 'get all rows');
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Initial basics:
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  my($jraw) = &ToJulian($YY,
 $MM,
 $DD,
 $h,
 $m,
 $s,
 0,
 0,
 0);
 # no zone/DST yet
\end_layout

\begin_layout Plain Layout

  my($JBIG) = $jraw * 1000000;
 # microseconds,
 as in database.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($JX) = 0;
        # if no row applies,
 will fail,
 returning zero
\end_layout

\begin_layout Plain Layout

  my($shadow) = 0;
 
\end_layout

\begin_layout Plain Layout

  my($last_tr) = 0;
   # prior transition as error trigger
\end_layout

\begin_layout Plain Layout

  my($lastd) = 0;
     # dual usage as below
\end_layout

\begin_layout Plain Layout

  my($lastzo) = 0;
    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($zone == $UTCCODE)
\end_layout

\begin_layout Plain Layout

  { $JX = &BigApplyGps($JBIG);
  # GPS correction!
\end_layout

\begin_layout Plain Layout

    return( &HugeToJ($JX),
 0 );
  # return GPS-adjusted Julian value,
 no shadow.
 
\end_layout

\begin_layout Plain Layout

          # ^ [TEMP]
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Work through the rows:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

while(scalar @ROWS > 0)     # [clumsy] 
\end_layout

\begin_layout Plain Layout

  { my($r) = shift @ROWS;
\end_layout

\begin_layout Plain Layout

    my($tr,
 $d,
 $z,
 $ign) = @$r;
  # transition,
 DST,
 Z,
 all in microseconds.
 
\end_layout

\begin_layout Plain Layout

    $JX  = &BigApplyGps($JBIG - $z - $d);
  # final GPS correction!
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have a `winner',
 but first test for limbo:
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  if($JX < $tr) 
\end_layout

\begin_layout Plain Layout

    { 
\end_layout

\begin_layout Plain Layout

      # is this in limbo?
 
\end_layout

\begin_layout Plain Layout

    if($JX < $last_tr)
\end_layout

\begin_layout Plain Layout

      { $shadow = ( ($lastzo + $lastd) - ($z + $d) ) / 1000000;
 # negative,
 seconds
\end_layout

\begin_layout Plain Layout

   #     print 
\begin_inset Quotes eld
\end_inset

limbo warning:
 $JX ,
 $shadow
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 # debug 
\end_layout

\begin_layout Plain Layout

        return( &HugeToJ($JX),
 &Biggen($shadow) );
  # return GPS-adjusted Julian INT  
\end_layout

\begin_layout Plain Layout

      };
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      my($next_tr,
 $next_d,
 $next_z,
 $next_ign);
\end_layout

\begin_layout Plain Layout

    if(defined $r) # forestall problem with 31-12 23:59:59 
\end_layout

\begin_layout Plain Layout

      { ($next_tr,
 $next_d,
 $next_z,
 $next_ign) = @$r;
  # 
\end_layout

\begin_layout Plain Layout

      } else
\end_layout

\begin_layout Plain Layout

      { &Warn(3,
 "Next zone not found $zone / " .
 &Dat( &HugeToJ($tr) ) );
 # explore use of &TimeWarn_(
\end_layout

\begin_layout Plain Layout

        ($next_tr,
 $next_d,
 $next_z,
 $next_ign) = ($tr,
 $d,
 $z,
 0);
 
\end_layout

\begin_layout Plain Layout

      };
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next,
 do we have a groundhog value?
 Note the use of >= rather than > in the following,
 to accommodate the 
\begin_inset Quotes eld
\end_inset

start of the hour before the transition
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[ 2021-01-17 pm]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

      $r = shift @ROWS;
  # get NEXT entry 
\end_layout

\begin_layout Plain Layout

      my($next_tr,
 $next_d,
 $next_z,
 $next_ign) = @$r;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      my($Delta) = ($z + $d) - ($next_d + $next_z);
 
\end_layout

\begin_layout Plain Layout

    if($JX + $Delta >= $tr)  # yes,
 groundhog:
\end_layout

\begin_layout Plain Layout

      { $shadow = $Delta/1000000;
 # [assume integer] [hmm] 
\end_layout

\begin_layout Plain Layout

  #      print 
\begin_inset Quotes eld
\end_inset

groundhog note:
 $JX,
 $shadow
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 # debug.
 
\end_layout

\begin_layout Plain Layout

        return( &HugeToJ($JX),
 $shadow);
 
\end_layout

\begin_layout Plain Layout

      };
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otherwise,
 just a `winner':
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

      return( &HugeToJ($JX),
 0 );
  # return GPS-adjusted Julian value INTEGER.
 
\end_layout

\begin_layout Plain Layout

    };
 # end winner.
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Not a winner,
 continue:
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
WHAT ABOUT SPURIOUS TRANSITIONS??
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  else # else row did not apply
\end_layout

\begin_layout Plain Layout

    { $JX = 0;
           # clear
\end_layout

\begin_layout Plain Layout

    if($ign == 0)        #if a real transition
\end_layout

\begin_layout Plain Layout

      { $last_tr = $tr;
  # retain
\end_layout

\begin_layout Plain Layout

        $lastd = $d;
     
\end_layout

\begin_layout Plain Layout

        $lastzo = $z;
    
\end_layout

\begin_layout Plain Layout

      };
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

  };
     # end of while loop.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

    $last_tr = $tr;
  # retain
\end_layout

\begin_layout Plain Layout

    $lastd = $d;
     
\end_layout

\begin_layout Plain Layout

    $lastzo = $z;
    
\end_layout

\begin_layout Plain Layout

  };
     # end of while loop.
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
But we have a potential problem if application of the zone/dst flicks us forward past the transition point,
 and need to adjust the values.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  if($tr > $JBIG)  # if row applies [note:
 explore > vs >= ]
\end_layout

\begin_layout Plain Layout

    { 
\end_layout

\begin_layout Plain Layout

      $Jok = $JBIG - $z - $d;
 # now know apparent Z&D so adjust for these
\end_layout

\begin_layout Plain Layout

    if( ($Jok >= $tr) # if adjustment forces JBIG to above transition,
 then match is WRONG
\end_layout

\begin_layout Plain Layout

      &&($ign == 0)   # unless $ign == 1:
 then transition is simply year-end marker
\end_layout

\begin_layout Plain Layout

      )               # [BUT:
 EXPLORE CASE WHERE another transition is close!
 [fix me!]]
\end_layout

\begin_layout Plain Layout

      { # assume next interval applies.
 Would be bad if very short transition between intervals [check me!]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        $firsttr = $tr;
\end_layout

\begin_layout Plain Layout

        $firstdst = $d;
\end_layout

\begin_layout Plain Layout

        $firstzo = $z;
\end_layout

\begin_layout Plain Layout

      if(scalar @ROWS < 1)  # if nothing left ??
\end_layout

\begin_layout Plain Layout

        { &Log("
\backslash
n***FAIL*** Bad date top:
 $YY-$MM-$DD,
 $h:$m:$s for zone $zone");
 
\end_layout

\begin_layout Plain Layout

          $Jok = 0;
   # fail
\end_layout

\begin_layout Plain Layout

          $shadow = -1;
   # error type
\end_layout

\begin_layout Plain Layout

        } else
\end_layout

\begin_layout Plain Layout

        { $r = shift @ROWS;
   # repeat the above process
\end_layout

\begin_layout Plain Layout

          ($tr,
 $d,
 $z,
 $ign) = @$r;
  # DO NOT need to use $ign in the following [!
 CHECK THIS !]
\end_layout

\begin_layout Plain Layout

              # [BUT WHAT IF the transition is very close to the year end???
 [check me!]]
\end_layout

\begin_layout Plain Layout

          $Jok = $JBIG - $z - $d;
 
\end_layout

\begin_layout Plain Layout

        if($Jok >= $tr)  # very bad
\end_layout

\begin_layout Plain Layout

          { &Log("
\backslash
n***FAIL*** Bad date forward($Jok>=$tr):
 $YY-$MM-$DD,
 $h:$m:$s for zone $zone");
 
\end_layout

\begin_layout Plain Layout

            $shadow = -2;
\end_layout

\begin_layout Plain Layout

            $Jok = 0;
    # 
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        elsif($Jok < $firsttr)
\end_layout

\begin_layout Plain Layout

          { &Log("
\backslash
n***FAIL*** Bad date back($Jok<$firsttr):
 $YY-$MM-$DD,
 $h:$m:$s for zone $zone");
 
\end_layout

\begin_layout Plain Layout

            $Jok = 0;
    # 
\end_layout

\begin_layout Plain Layout

            $shadow = -3;
\end_layout

\begin_layout Plain Layout

          } else
\end_layout

\begin_layout Plain Layout

          {
\end_layout

\begin_layout Plain Layout

          };
\end_layout

\begin_layout Plain Layout

        };
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
A jump back
\end_layout

\begin_layout Plain Layout
What if application of z+d moves us 
\emph on
back
\emph default
?
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

 elsif(
\end_layout

\begin_layout Plain Layout

      )               # [BUT WHAT ABOUT THE EFFECT OF THE ZONE OFFSET ?????????????????????[EXPLORE]]
\end_layout

\begin_layout Plain Layout

      { &Log("
\backslash
n***FAIL*** Skipback ($Jok<$firsttr):
 $YY-$MM-$DD,
 $h:$m:$s for zone $zone");
 
\end_layout

\begin_layout Plain Layout

        $Jok = 0;
\end_layout

\begin_layout Plain Layout

        $shadow = -4;
  # signal the error
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
There's a different problem if we're 
\begin_inset Quotes eld
\end_inset

just after the (previous) transition
\begin_inset Quotes erd
\end_inset

,
 DST is now on,
 and removal of the DST now takes us back to before that transition!
 [ALSO EXPLORE CASE OF DOUBLE DST] This implies that the specified date is invalid —
 it must represent a local timestamp within the hour skipped as the clocks were set forward.
 The same stricture applies for a positive skip forward in the zone.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

 elsif( $d                   # if DST on and 
\end_layout

\begin_layout Plain Layout

      &&($Jok < $firsttr)    #   compensation moved DST before the transition
\end_layout

\begin_layout Plain Layout

      &&($ign == 0)          #   and a real transition (not to be ignored)
\end_layout

\begin_layout Plain Layout

      )               # [BUT WHAT ABOUT THE EFFECT OF THE ZONE OFFSET ?????????????????????[EXPLORE]]
\end_layout

\begin_layout Plain Layout

      { &Log("
\backslash
n***FAIL*** Skipback ($Jok<$firsttr):
 $YY-$MM-$DD,
 $h:$m:$s for zone $zone");
 
\end_layout

\begin_layout Plain Layout

        $Jok = 0;
\end_layout

\begin_layout Plain Layout

        $shadow = -4;
  # signal the error
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Next,
 if we're 
\emph on
just after 
\emph default
the transition and DST was turned off,
 we have a non-unique timestamp.
 We signal this by dst (seconds) in $shadow.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

 elsif(  ($d < $firstdst)          # if DST was 'turned off'
\end_layout

\begin_layout Plain Layout

       &&($Jok - $firstdst < $firsttr) # and in the groundhog hour ???
\end_layout

\begin_layout Plain Layout

       &&($ign == 0)
\end_layout

\begin_layout Plain Layout

      )                     # [????????????????????????????
 IS THIS CORRECT ????????????????]
\end_layout

\begin_layout Plain Layout

      { $shadow = int(0.5 + 86400 * &HugeToJ($firstdst)/86400);
  # seconds
\end_layout

\begin_layout Plain Layout

           # in shadow zone,
 but not an error [but WHAT ABOUT SUPER DST ???]
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

Even more interesting is where the zone offset decreased,
 similarly forcing a non-unique timestamp:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

 elsif( ($delta_z < 0)
\end_layout

\begin_layout Plain Layout

      &&($Jok + $delta_z < $firsttr)  # zone groundhog!
\end_layout

\begin_layout Plain Layout

      &&($ign == 0)
\end_layout

\begin_layout Plain Layout

      )                               # [?????????????
 is this correct ?????????????????]
\end_layout

\begin_layout Plain Layout

      { $shadow = int(0.5 + 86400 * &HugeToJ($delta_z)/86400);
  # seconds
\end_layout

\begin_layout Plain Layout

      };
  # else simply OK
\end_layout

\begin_layout Plain Layout

      @ROWS = ();
 # clear,
 end of identified row,
 force exit
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
============================
\end_layout

\end_inset

Terminate.
 As this should never happen,
 signal failure by sending back a transition value of zero.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[explore,
 cf.
 JD of 0 ??] [limit to 1 anyway]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  return(0,0);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We also need to consider the scenario where a 
\begin_inset Quotes eld
\end_inset

transition
\begin_inset Quotes erd
\end_inset

 in tr is just a December prosthesis.
 This shouldn't be an issue where JX falls before tr,
 as the value is 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

,
 and the same should generally hold if the subsequent transition is prosthetic,
 as it then merely represents the future state in a valid way.
 But what if there's an unreasonably short gap between a prosthetic and either an antecedent or subsequent transition?
 
\end_layout

\begin_layout Section
Julian
\begin_inset CommandInset label
LatexCommand label
name "subsec:Julian"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
[THIS ROUTINE IS DEFECTIVE AS IT CHOPS OFF HOURS ETC.
 fixed!
 the problem was 
\begin_inset Quotes eld
\end_inset

use bigint
\begin_inset Quotes erd
\end_inset

 :-( ]
\end_layout

\end_inset

 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub BadJulian
\end_layout

\begin_layout Plain Layout

{ my($fy,
 $fm,
 $fd,
 $fh,
 $fmi,
 $fs,
 $ff,
 $LToff,
 $Dst);
\end_layout

\begin_layout Plain Layout

     ($fy,
 $fm,
 $fd,
 $fh,
 $fmi,
 $fs,
 $ff,$LToff,
 $Dst)=@_;
\end_layout

\begin_layout Plain Layout

if(!
 defined $fs)
\end_layout

\begin_layout Plain Layout

  { return(0);
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  # HACK:
 COMPENSATE FOR THE FACT THAT GPS TIME IS currently 16s AHEAD OF UTC 
\end_layout

\begin_layout Plain Layout

  ## $fs = $fs + 16;
   # 'convert' to GPS time.
 
\end_layout

\begin_layout Plain Layout

  # end hack.
 [no!
 see GpsJulian_()
\end_layout

\begin_layout Plain Layout

  my($f);
\end_layout

\begin_layout Plain Layout

  $f= 367*$fy - int(7*($fy+int(($fm+9)/12))/4)
\end_layout

\begin_layout Plain Layout

              - int(3*(int(($fy+($fm-9)/7)/100)+1)/4)
\end_layout

\begin_layout Plain Layout

              + int(275*$fm/9)+$fd+1721028.5
\end_layout

\begin_layout Plain Layout

              - ($LToff + $Dst)/24
\end_layout

\begin_layout Plain Layout

              + ($fh + ($fmi + ($fs+ "0.$ff")/60)/60)/24;
\end_layout

\begin_layout Plain Layout

  # &Log("
\backslash
n   debug Julian:
 $fh:$fmi:$fs.$ff ==> $f / "  );
\end_layout

\begin_layout Plain Layout

  return $f;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Revised version that works across dates
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status open

\begin_layout Plain Layout
Baum:
 
\begin_inset CommandInset href
LatexCommand href
name "http://mysite.verizon.net/aesir_research/date/jdimp.htm"
target "http://mysite.verizon.net/aesir_research/date/jdimp.htm"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

;
 $ff is milliseconds,
 or can be left as a null string.
 $Zoff is the time zone offset,
 and $Dst is daylight saving adjustment.
 
\end_layout

\begin_layout Standard
NOTE that the units of the zone offset and daylight saving are 
\emph on
hours
\emph default
,
 something that may cause confusion.
 
\end_layout

\begin_layout Standard
The algorithm is Baum's (See Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Full-Gregorian"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

 for a reference).
 
\end_layout

\begin_layout Enumerate
Z = Y + int((M-14)/12);
\end_layout

\begin_layout Enumerate
IF M<3 THEN M=M+12;
 F = int((153*M-457)/5 );
 
\end_layout

\begin_layout Enumerate
J=D+F+365*Z+floor(Z/4)-floor(Z/100)+floor(Z/400) + 1721118.5
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The submitted values in $Zoff and $Dst are in seconds.
 The returned Julian value is in seconds,
 not Julian day number.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
See:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

IF M < 3 THEN 
\end_layout

\begin_layout Plain Layout

      M = M + 12 
\end_layout

\begin_layout Plain Layout

      Y=Y-1 
\end_layout

\begin_layout Plain Layout

END IF 
\end_layout

\begin_layout Plain Layout

JD = D + (153 * M - 457) 
\backslash
 5 + 365 * Y + [Y / 4] - [Y / 100] + [Y / 400] + 1721118.5
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub ToJulian
\end_layout

\begin_layout Plain Layout

{ my($YY,
 $MM,
 $DD,
 $h,
 $m,
 $s,
 $fff,
 $Zoff,
 $Dst);
\end_layout

\begin_layout Plain Layout

    ($YY,
 $MM,
 $DD,
 $h,
 $m,
 $s,
 $fff,
 $Zoff,
 $Dst)=@_;
\end_layout

\begin_layout Plain Layout

if(!
 defined $s) # must have seconds
\end_layout

\begin_layout Plain Layout

  { return(0);
    
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  $Zoff /= 86400;
\end_layout

\begin_layout Plain Layout

  $Dst /= 86400;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  $fff = &Lead($fff,3);
 # leading zeroes for milliseconds [??
 check this]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ## my($Z) = $YY + int( ($MM-14)/12 );
 # step 1.
 
\end_layout

\begin_layout Plain Layout

if($MM < 3)                          # step 2.
 
\end_layout

\begin_layout Plain Layout

  { $MM += 12;
 # could equally just subtract 1 from $YY and use ipo $Z.
 
\end_layout

\begin_layout Plain Layout

    $YY -= 1;
  # equivalent of step 1.
 
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($F) = int( (153*$MM - 457)/5 );
 
\end_layout

\begin_layout Plain Layout

  my($J) = $DD + $F + 365*$YY + floor($YY/4) - floor($YY/100) 
\end_layout

\begin_layout Plain Layout

             + floor($YY/400) + 1721118.5;
 # step 3.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  $J -= ( $Zoff + $Dst );
 # fractions of a day
\end_layout

\begin_layout Plain Layout

  $J += (  $h + ( $m + ($s + "0.$fff")/60 )/60  )/24;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return($J*86400);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Julian
\end_layout

\begin_layout Plain Layout

{ my($YY,
 $MM,
 $DD,
 $h,
 $m,
 $s,
 $fff,
 $Zoff,
 $Dst);
\end_layout

\begin_layout Plain Layout

    ($YY,
 $MM,
 $DD,
 $h,
 $m,
 $s,
 $fff,
 $Zoff,
 $Dst)=@_;
\end_layout

\begin_layout Plain Layout

if(!
 defined $s) # must have seconds
\end_layout

\begin_layout Plain Layout

  { return(0);
    
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  $fff = &Lead($fff,3);
 # leading zeroes for milliseconds
\end_layout

\begin_layout Plain Layout

if($MM < 3)
\end_layout

\begin_layout Plain Layout

  { $MM += 12;
\end_layout

\begin_layout Plain Layout

    $YY --;
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  my($J) = $DD + int((153*$MM-457)/5) + 365*$YY + int($YY/4) - int($YY/100) + int($YY/400) + 1721118.5;
\end_layout

\begin_layout Plain Layout

  $J += ( $h - $Zoff - $Dst + ($m + ($s + "0.$fff")/60)/60 )/24;
\end_layout

\begin_layout Plain Layout

if($YY < 0) { $J --;
 };
 # subtract a day if before 1 Mar 0000 [check this?]
\end_layout

\begin_layout Plain Layout

  return($J);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the above,
 we take a plain Gregorian UTC date and convert it to the corresponding Julian day (floating point).
 We do not offset the result with a GPS offset,
 something done by GpsJulian
\begin_inset space ~
\end_inset

() below.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
%
\backslash

\end_layout

\begin_layout Plain Layout
http://mysite.verizon.net/aesir_research/date/back.htm
\end_layout

\begin_layout Plain Layout
checking conversion routines:
\end_layout

\begin_layout Plain Layout
http://mysite.verizon.net/aesir_research/date/analy1.htm
\end_layout

\begin_layout Plain Layout
–
\end_layout

\begin_layout Plain Layout
http://www.astro.rug.nl/~vogelaar/PYTHONPRACT/pythonintroduction.php
\end_layout

\begin_layout Plain Layout
http://cpansearch.perl.org/src/SYAMAL/Date-Indian-0.01/lib/Date/Indian.pm
\end_layout

\begin_layout Plain Layout
=== for J–>G:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

SUB fliegel (jd AS DOUBLE,
 year AS LONG,
 month AS INTEGER,
 day AS DOUBLE) 
\end_layout

\begin_layout Plain Layout

l& = jd + 68569 
\end_layout

\begin_layout Plain Layout

n& = (4 * l&) 
\backslash
 146097 
\end_layout

\begin_layout Plain Layout

l& = l& - (146097 * n& + 3) 
\backslash
 4 
\end_layout

\begin_layout Plain Layout

I& = 4000 * (l& + 1) 
\backslash
 1461001 
\end_layout

\begin_layout Plain Layout

l& = l& - (1461 * I&) 
\backslash
 4 + 31 
\end_layout

\begin_layout Plain Layout

J& = (80 * l&) 
\backslash
 2447 
\end_layout

\begin_layout Plain Layout

day = l& - (2447 * J&) 
\backslash
 80 
\end_layout

\begin_layout Plain Layout

l& = J& 
\backslash
 11 
\end_layout

\begin_layout Plain Layout

month = J& + 2 - 12 * l& 
\end_layout

\begin_layout Plain Layout

year = 100 * (n& - 49) + I& + l& 
\end_layout

\begin_layout Plain Layout

END SUB
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
sub Julian
\end_layout

\begin_layout Plain Layout
{ my($fy,
 $fm,
 $fd,
 $fh,
 $fmi,
 $fs,
 $ff);
\end_layout

\begin_layout Plain Layout
($fy,
 $fm,
 $fd,
 $fh,
 $fmi,
 $fs,
 $ff)=@_;
\end_layout

\begin_layout Plain Layout
my($f);
\end_layout

\begin_layout Plain Layout
$f= 367*$fy - int(7*($fy+int(($fm+9)/12))/4)
\end_layout

\begin_layout Plain Layout
- int(3*(int(($fy+($fm-9)/7)/100)+1)/4)
\end_layout

\begin_layout Plain Layout
+ int(275*$fm/9)+$fd+1721028.5
\end_layout

\begin_layout Plain Layout
- ($LOCALTIMEOFFSET+$DAYLIGHTSAVING)/24
\end_layout

\begin_layout Plain Layout
+ ($fh + ($fmi + ($fs+ "0.$ff")/60)/60)/24;
\end_layout

\begin_layout Plain Layout
return $f;
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
GPS Julian
\begin_inset CommandInset label
LatexCommand label
name "subsec:GPS-Julian"

\end_inset


\end_layout

\begin_layout Standard
Given Gregorian date,
 convert to Julian and then apply GPS adjustment.
 Note that the values in $LToff and $Dst are in seconds,
 so the caller must be aware of this.
 Returns a value in 
\emph on
seconds
\emph default
,
 not a Julian day number.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub GpsJulian # 
\end_layout

\begin_layout Plain Layout

{ my($fy,
 $fm,
 $fd,
 $fh,
 $fmi,
 $fs,
 $ff,
 $LToff,
 $Dst);
    # clumsy,
 use @
\end_layout

\begin_layout Plain Layout

    ($fy,
 $fm,
 $fd,
 $fh,
 $fmi,
 $fs,
 $ff,
 $LToff,
 $Dst)=@_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($J) = &ToJulian($fy,
 $fm,
 $fd,
 $fh,
 $fmi,
 $fs,
 $ff,
 $LToff,
 $Dst);
\end_layout

\begin_layout Plain Layout

                                                # seconds ^       ^
\end_layout

\begin_layout Plain Layout

  return( &ApplyGps($J) );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Add GPS
\end_layout

\begin_layout Standard
Given that a Gregorian date has been converted correctly to the corresponding Julian day number,
 adjust to GPS by adding the relevant leap seconds.
 The supplied value must be in Julian seconds,
 not days!
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub ApplyGps # 
\end_layout

\begin_layout Plain Layout

{ my($J) = @_;
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  my($Ltop) = scalar @LEAPDATA;
 
\end_layout

\begin_layout Plain Layout

  my($i) = 0;
\end_layout

\begin_layout Plain Layout

while($i < $Ltop)
\end_layout

\begin_layout Plain Layout

  { my($d) = $LEAPDATA[$i];
 # most recent value is at start of @LEAPDATA
\end_layout

\begin_layout Plain Layout

    my(@D) = @$d;
 # dereference 
\end_layout

\begin_layout Plain Layout

    # in the following note 1 (not 0) index:
 
\end_layout

\begin_layout Plain Layout

  if( $J >= ($D[1]/1000000.0) ) # smarter ?
 pre-scale @LEAPDATA or a copy 
\end_layout

\begin_layout Plain Layout

    { return($J+$D[2]);
  # add the offset
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

    $i ++;
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  return($J-9);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
GPS applied to BIG value
\end_layout

\begin_layout Standard
Adjust a big Julian (microseconds as opposed to days).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub BigApplyGps #
\end_layout

\begin_layout Plain Layout

{ my($Jbig);
\end_layout

\begin_layout Plain Layout

    ($Jbig)=@_;
\end_layout

\begin_layout Plain Layout

  my($Ltop) = scalar @LEAPDATA;
 
\end_layout

\begin_layout Plain Layout

  my($i) = 0;
\end_layout

\begin_layout Plain Layout

while($i < $Ltop)
\end_layout

\begin_layout Plain Layout

  { my($d) = $LEAPDATA[$i];
\end_layout

\begin_layout Plain Layout

    my(@D) = @$d;
 # dereference
\end_layout

\begin_layout Plain Layout

    my($greg) = $D[1];
\end_layout

\begin_layout Plain Layout

    my($off) = $D[2];
    # seconds
\end_layout

\begin_layout Plain Layout

  if($Jbig >= $greg)        # [check this inequality for consistency ??]
\end_layout

\begin_layout Plain Layout

    { my($K) = $Jbig+($off*1000000);
  # microseconds
\end_layout

\begin_layout Plain Layout

      return($K);
 # days
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

    $i ++;
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  my($K) = $Jbig -(9000000);
  # 9s
\end_layout

\begin_layout Plain Layout

  return($K);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Julian from Unix
\end_layout

\begin_layout Standard
Given Unix time,
 convert to GPS Julian (not simply UTC Julian).
 Unix time zero in GPS is 1 January 1970 00:00:00.
 The returned Julian value is in seconds,
 not days.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub JulianFromUnix
\end_layout

\begin_layout Plain Layout

{ my($unix) = @_;
\end_layout

\begin_layout Plain Layout

  # currently allow a proleptic negative value [explore] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($Uzero) = &ToJulian(1970,
 1,
 1,
 0,
 0,
 0,
 0,
 0,
 0);
 # to seconds
\end_layout

\begin_layout Plain Layout

  $Uzero += $unix;
 # [NB.
 what about internal unix leap seconds?]
\end_layout

\begin_layout Plain Layout

  return( &ApplyGps($Uzero) );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Fetch TZ date
\end_layout

\begin_layout Standard
Given year,
 month etc,
 establish a date for the stated zone (eg 
\begin_inset Quotes eld
\end_inset

Pacific/Auckland
\begin_inset Quotes erd
\end_inset

) and then convert to UTC,
 returning the string value.
 This is problematic in that some local timestamps simply won't exist.
 We thus always provide $JD,
 which is a GPS Julian time:
 it can be converted to UTC,
 and the corresponding date/time extracted.
 
\end_layout

\begin_layout Standard
In other words,
 our sequence is:
\end_layout

\begin_layout Enumerate
Submit a Gregorian wall timestamp (together with a backup Julian timestamp);
\end_layout

\begin_layout Enumerate
Turn this into a value (object) within DateTime using the zone name in 
\family typewriter
$zone
\family default
;
 DateTime uses tz (This may fail)
\end_layout

\begin_layout Enumerate
On success,
 clone the value,
 and convert it to a UTC timestamp,
 using DateTime again
\end_layout

\begin_deeper
\begin_layout Enumerate
Return the formatted string.
 
\end_layout

\end_deeper
\begin_layout Enumerate
On failure,
 convert the Julian value to UTC,
 convert 
\emph on
this
\emph default
 to a UTC timestamp,
 and return the formatted string.
 A compensatory hack.
\end_layout

\begin_deeper
\begin_layout Enumerate
Write some warning messages.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Note that when tz converts an ambiguous wall time to UTC,
 it returns the later of the two UTC dates.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub FetchTzDate #
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  my($JD,
 $zone,
 $YEAR,
 $MONTH,
 $DAY,
 $HOUR,
 $MINUTE,
 $SECOND) = @_;
\end_layout

\begin_layout Plain Layout

##  print 
\begin_inset Quotes eld
\end_inset

 { FetchTzDate :
 $zone,
 $YEAR,
 $MONTH,
 $DAY,
 $HOUR,
 $MINUTE,
 $SECOND 
\begin_inset Quotes eld
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($zone eq 'UTC/UTC')
\end_layout

\begin_layout Plain Layout

  { return( &PrettyDate(1,$YEAR,$MONTH,$DAY,
 $HOUR,
 $MINUTE,
 $SECOND) );
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ## print 
\begin_inset Quotes eld
\end_inset

Debug:
 fetching tz date:
 '$zone'
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 # 2021-03-13 
\end_layout

\begin_layout Plain Layout

if(length $zone < 1)
\end_layout

\begin_layout Plain Layout

  { $zone = 'UTC';
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($yours)='';
\end_layout

\begin_layout Plain Layout

eval
\end_layout

\begin_layout Plain Layout

  { my($dt1) = DateTime->new( year => $YEAR,
 month => $MONTH,
 day => $DAY,
\end_layout

\begin_layout Plain Layout

       hour => $HOUR,
 minute => $MINUTE,
 second => $SECOND,
\end_layout

\begin_layout Plain Layout

       time_zone => $zone);
\end_layout

\begin_layout Plain Layout

    my($dtest) = $dt1->clone->set_time_zone( 'UTC' );
\end_layout

\begin_layout Plain Layout

    $yours = $dtest->datetime();
  # format is identical
\end_layout

\begin_layout Plain Layout

    1;
   # prevents alterations to $@
\end_layout

\begin_layout Plain Layout

  } or do
\end_layout

\begin_layout Plain Layout

  { my($e) = $@;
\end_layout

\begin_layout Plain Layout

    chomp($e);
 # $e should contain 'bad' zone name.
 
\end_layout

\begin_layout Plain Layout

    my($dt2);
 
\end_layout

\begin_layout Plain Layout

    my($woops);
 
\end_layout

\begin_layout Plain Layout

   if($e =~ /The timezone .* could not be loaded/)  ## e.g.
 new zone like America/Coyhaique 
\end_layout

\begin_layout Plain Layout

     { $woops = 
\begin_inset Quotes eld
\end_inset

Missing timezone in tz DateTime:
 '$e' --- defaulting to UTC
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

       $zone = 'UTC';
\end_layout

\begin_layout Plain Layout

     } else # Walldate is for debugging:
 
\end_layout

\begin_layout Plain Layout

     { my($walldate) = &PrettyDate(0,$YEAR,
 $MONTH,
 $DAY,
 $HOUR,
 $MINUTE,
 $SECOND);
 
\end_layout

\begin_layout Plain Layout

       $woops = "BAD zone time,
 Perl DateTime said:
 '$e';
 wall=$walldate
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

       ($YEAR,
 $MONTH,
 $DAY,
 $HOUR,
 $MINUTE,
 $SECOND) = Timely::FullGregorian($JD,
 0,
 0,
 1);
\end_layout

\begin_layout Plain Layout

     };
 
\end_layout

\begin_layout Plain Layout

     $dt2 = DateTime->new( year => $YEAR,
 month => $MONTH,
 day => $DAY,
 
\end_layout

\begin_layout Plain Layout

           hour => $HOUR,
 minute => $MINUTE,
 second => $SECOND,
 time_zone => 'UTC');
\end_layout

\begin_layout Plain Layout

     $yours = $dt2->datetime() .
 '?';
 
\end_layout

\begin_layout Plain Layout

     my($corrected) = $dt2->clone->set_time_zone( $zone )->datetime();
 
\end_layout

\begin_layout Plain Layout

     &Warn(3,
 
\begin_inset Quotes eld
\end_inset

$woops;
 corrected='$corrected' 
\begin_inset Quotes erd
\end_inset

 );
 
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##  print 
\begin_inset Quotes eld
\end_inset

 => $yours } 
\begin_inset Quotes eld
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return($yours);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
–
\end_layout

\begin_layout Subsection
Fetch new timezone
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub NewZone #
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  my($zone,
 $YEAR,
 $MONTH,
 $DAY,
 $HOUR,
 $MINUTE,
 $SECOND);
\end_layout

\begin_layout Plain Layout

    ($zone,
 $YEAR,
 $MONTH,
 $DAY,
 $HOUR,
 $MINUTE,
 $SECOND) = @_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # use eval { } to trap error:
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 my($dt) = eval { DateTime->new( year => $YEAR,
 month => $MONTH,
 day => $DAY,
\end_layout

\begin_layout Plain Layout

                  hour => $HOUR,
 minute => $MINUTE,
 second => $SECOND,
 time_zone => 'UTC')
\end_layout

\begin_layout Plain Layout

                } ;
\end_layout

\begin_layout Plain Layout

if(!$dt)
\end_layout

\begin_layout Plain Layout

  { $e = $@;
 
\end_layout

\begin_layout Plain Layout

  if($e =~ /The timezone .* could not be loaded/)
\end_layout

\begin_layout Plain Layout

    { print 
\begin_inset Quotes eld
\end_inset

Missing timezone in tz DateTime:
 '$e' --- defaulting to UTC
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

      $dt = eval { DateTime->new( year => $YEAR,
 month => $MONTH,
 day => $DAY,
\end_layout

\begin_layout Plain Layout

                  hour => $HOUR,
 minute => $MINUTE,
 second => $SECOND,
 time_zone => 'UTC')
\end_layout

\begin_layout Plain Layout

                } ;
      
\end_layout

\begin_layout Plain Layout

    };
 
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return($dt);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Internal Julian
\begin_inset CommandInset label
LatexCommand label
name "subsec:Internal-Julian"

\end_inset


\end_layout

\begin_layout Standard
Given a Gregorian date specific to a given zone,
 find the internal (GPS) rendition of the date.
 The returned value is a Julian number as 
\emph on
seconds
\emph default
.
 Assumes that MYTIMELY has already been set up,
 allowing `quick' G2J
\begin_inset space ~
\end_inset

().
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[The internal printing in this routine is nasty and should be fixed]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub InternalJulian #
\end_layout

\begin_layout Plain Layout

{ my($inp,
 $region,
 $regionNAME) = @_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($YY,$MM,$DD,$h,$m,$s);
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($inp =~ /^
\backslash
s*(
\backslash
d{4})-(
\backslash
d{2})-(
\backslash
d{2})[ T](
\backslash
d{2}):(
\backslash
d{2}):(
\backslash
d{2})
\backslash
s*$/ )
\end_layout

\begin_layout Plain Layout

  { ($YY,$MM,$DD,$h,$m,$s) = ($1,
 $2,
 $3,
 $4,
 $5,
 $6);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

elsif( $inp =~ /^
\backslash
s*(
\backslash
d{4})-(
\backslash
d{2})-(
\backslash
d{2})
\backslash
s*$/ )
\end_layout

\begin_layout Plain Layout

  { ($YY,$MM,$DD,
 $h,$m,$s) = ($1,
 $2,
 $3,
 0,0,0);
\end_layout

\begin_layout Plain Layout

  } else
\end_layout

\begin_layout Plain Layout

  { print " [ERROR] date format is YYYY-MM-DD hh:mm:ss 
\backslash
n";
  # ?
 be more lenient
\end_layout

\begin_layout Plain Layout

    return(0);
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  my($J,
 $shadow) = (0,0);
\end_layout

\begin_layout Plain Layout

if($region == $UTCCODE)  # if UTC
\end_layout

\begin_layout Plain Layout

  { $J = &GpsJulian($YY,$MM,$DD,$h,$m,$s,
 0,
 0,
 0);
\end_layout

\begin_layout Plain Layout

  } else
\end_layout

\begin_layout Plain Layout

  { ($J,
 $shadow) = &G2J(1,
 $region,
 $YY,$MM,$DD,$h,$m,$s);
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

if( ( $shadow < 0)   # failed,
 -ve shadow
\end_layout

\begin_layout Plain Layout

  || !
 $J            # or zero (bad J)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  { print "
\backslash
nBad date for zone $region($regionNAME):
 $inp (
\begin_inset Quotes eld
\end_inset

 
\end_layout

\begin_layout Plain Layout

          .
 &JulianDay($J) .
 
\begin_inset Quotes eld
\end_inset

 / " .
 $shadow .
 " )
\backslash
n";
\end_layout

\begin_layout Plain Layout

    return(0);
 # fail
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the external TZ date routine automatically jumps forward when it is supplied with a timestamp within the groundhog hour,
 on conversion to UTC.
 This places the discontinuity at the start of the groundhog time,
 while my program puts it at the end.
 In other words,
 TZ jumps forward by +DST at the start of the groundhog hour.
 This discrepancy results in a mismatch between my Greg
\begin_inset space ~
\end_inset

() routine and FetchTzDate
\begin_inset space ~
\end_inset

().
 Try e.g.
 America/Phoenix 1943-12-31 23:01:00 versus 1 minute earlier.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
I compensate by testing against the adjusted date (
\family typewriter
$mine2
\family default
).
 See also Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:A-TZ-catch"
nolink "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  my($mine) = &Greg($J,0,0,1);
  # Render as standard date,
 then do the same in TZ!
\end_layout

\begin_layout Plain Layout

  $mine =~ s/ /T/;
  # replace ' ' with 'T'
\end_layout

\begin_layout Plain Layout

  my($yours) =  &FetchTzDate($J,
 $regionNAME,
 $YY,
 $MM,
 $DD,
 $h,
 $m,
 $s);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($yourmsg);
 
\end_layout

\begin_layout Plain Layout

  my($err) = '';
 
\end_layout

\begin_layout Plain Layout

if(length $yours < 1) 
\end_layout

\begin_layout Plain Layout

  { $yourmsg = 
\begin_inset Quotes eld
\end_inset

[no reference]
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

  } else
\end_layout

\begin_layout Plain Layout

  { $yourmsg = $yours .
 $TICK ;
\end_layout

\begin_layout Plain Layout

  if($mine ne $yours)
\end_layout

\begin_layout Plain Layout

    { my($mine2) = &Greg($J + $shadow,
 0,
 0,
 1);
 # add s;
 compensate for TZ jump!
\end_layout

\begin_layout Plain Layout

      $mine2 =~ s/ /T/;
\end_layout

\begin_layout Plain Layout

    if($mine2 eq $yours)
\end_layout

\begin_layout Plain Layout

      { $err = ' (+) ';
\end_layout

\begin_layout Plain Layout

      } else
\end_layout

\begin_layout Plain Layout

      { $err = " Date mismatch '$mine'??
  vs ";
\end_layout

\begin_layout Plain Layout

      };
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(length $err > 0)
\end_layout

\begin_layout Plain Layout

  { print sprintf("%.12f",
 &JulianDay($J) ) 
\end_layout

\begin_layout Plain Layout

          .
 " zone=$region (shadow=" .
 $shadow .
 " s) $err gps=$yourmsg
\begin_inset Quotes erd
\end_inset

 .
 
\begin_inset Quotes erd
\end_inset


\backslash
n";
\end_layout

\begin_layout Plain Layout

#  }
\end_layout

\begin_layout Plain Layout

#elsif($FULLDEBUG)
\end_layout

\begin_layout Plain Layout

#  { print sprintf("%.12f",
 &JulianDay($J) ) .
 " zone=$region (shadow=" 
\end_layout

\begin_layout Plain Layout

#          .
 $shadow .
 " s) gps=$yourmsg
\begin_inset Quotes erd
\end_inset

 .
 
\begin_inset Quotes erd
\end_inset


\backslash
n";
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  return($J);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the above,
 FetchTzDate
\begin_inset space ~
\end_inset

() retrieves a Gregorian date formatted by the DateTime Perl module (which uses tz);
 the value in 
\family typewriter
$J
\family default
 and the associated routines are checked by applying Greg
\begin_inset space ~
\end_inset

() back to the value in 
\family typewriter
$J
\family default
 that was set by G2J
\begin_inset space ~
\end_inset

() 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[or GpsJulian
\begin_inset space ~
\end_inset

() ]
\end_layout

\end_inset

 above.
 If there's an error,
 this might have been introduced in two places:
 either the Julian conversion by G2J
\begin_inset space ~
\end_inset

() 
\emph on
or
\emph default
 the back-conversion by Greg
\begin_inset space ~
\end_inset

().
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[The character 
\backslash
xa0 should be rendered as a non-breaking space but isn't.
 ] Perl prints something else.
 How does one generate an nbs before the 's'?
 [open question]
\end_layout

\begin_layout Plain Layout
[
\series bold
Answer:

\series default
 1/12/2020:
 get the console right,
 and use utf8 throughout.
\end_layout

\begin_layout Plain Layout
i.e.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

use utf8;
 
\end_layout

\begin_layout Plain Layout

use open ':encoding(utf8)';
\end_layout

\begin_layout Plain Layout

binmode(STDOUT,
 ":utf8");
\end_layout

\begin_layout Plain Layout

## NB.
 Under Windows in your console you will still need to say 
\end_layout

\begin_layout Plain Layout

#      chcp 65000
\end_layout

\begin_layout Plain Layout

##  and set the Console properties (font) to Lucida Console !
 
\end_layout

\begin_layout Plain Layout

##   ...
 in order to get the active code page right!
 (Default is 850)
\end_layout

\begin_layout Plain Layout

## Also note that   use utf8;
   doesn't alter output,
 it's for input.
 
\end_layout

\begin_layout Plain Layout

## For STDOUT,
 STDIN & STDERR,
 might also say:
\end_layout

\begin_layout Plain Layout

##   use open qw/:std :utf8/;
 
\end_layout

\end_inset

]
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Julian Day
\begin_inset CommandInset label
LatexCommand label
name "subsec:Julian-Day"

\end_inset


\end_layout

\begin_layout Standard
Convert seconds to Julian day number:
 a convenient wrapper.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub JulianDay # 
\end_layout

\begin_layout Plain Layout

{ my($s) = @_;
\end_layout

\begin_layout Plain Layout

  return($s/86400.0);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Full Gregorian
\begin_inset CommandInset label
LatexCommand label
name "subsec:Full-Gregorian"

\end_inset


\end_layout

\begin_layout Standard
Given:
\end_layout

\begin_layout Description
jd A Julian day value,
 expressed as seconds (rather than the more conventional 1=1
\begin_inset space \thinspace{}
\end_inset

day,
 with fraction)
\end_layout

\begin_layout Description
LCL a local offset,
 in seconds
\end_layout

\begin_layout Description
DST a daylight saving time offset in seconds
\end_layout

\begin_layout Description
isgps Whether this Julian day includes a GPS offset (i.e.
 it's a proleptic Julian GPS time).
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\SpecialChar ldots
 return a list of year,
 month,
 day,
 hours,
 minutes and seconds—
for the corresponding Gregorian value,
 using the 
\emph on
supplied
\emph default
 local offset and daylight saving.
 We make no representation that the supplied values are right—
we simply use them.
 
\end_layout

\begin_layout Standard
If $isgps is set to 1,
 then we strip off a GPS offset from the Julian day 
\emph on
before
\emph default
 we convert to Gregorian values.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
An explicatory addendum:
 if we're at the start of a 
\begin_inset Quotes eld
\end_inset

groundhog hour
\begin_inset Quotes erd
\end_inset

 i.e.
 we're falling back to the start of the repeated (overlap) hour,
 then the first time around we don't touch on the next hour.
 For example,
 if we're in Auckland and the wall clock time is 
\emph on
about
\emph default
 to reach 2020-04-05 03:00:00,
 at the 
\emph on
instant
\emph default
 before this happens (corresponding to 
\emph on
infinitesimally just before
\emph default
 UTC 2020-04-04 14:00:00 ) the wall clock is set back to 2020-04-05 02:00:00.
 All of this has several implications.
\end_layout

\begin_layout Enumerate
The first is that there is obviously a multitude of 
\begin_inset Quotes eld
\end_inset

single
\begin_inset Quotes erd
\end_inset

 wall times in that hour that each map to two distinct UTC times,
 so we need to make a choice if we wish to convert the wall time to UtC.
 For example,
 if we're converting 
\emph on
wall 
\emph default
time 2020-04-05 02:30:00,
 this may map to:
\end_layout

\begin_deeper
\begin_layout Enumerate
UTC 2020-04-04 13:30:00 or
\end_layout

\begin_layout Enumerate
UTC 2020-04-04 14:30:00
\end_layout

\end_deeper
\begin_layout Enumerate
The second is that we must not convert UTC 2020-04-04 14:00:00 to wall time 2020-04-05 03:00:00.
 Only when we reach UTC 2020-04-04 15:00:00 must we display this time.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We use Peter Baum's translation algorithm.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://www.researchgate.net/publication/316558298_Date_Algorithms"
target "https://www.researchgate.net/publication/316558298_Date_Algorithms"
literal "false"

\end_inset


\end_layout

\end_inset

 We currently just add DST and the local offset.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Z = INT(JD - 1721118.5) step 1
\end_layout

\begin_layout Plain Layout
R = JD - 1721118.5 - Z step 1
\end_layout

\begin_layout Plain Layout
G = Z - .25 used in later steps
\end_layout

\begin_layout Plain Layout
A = INT(G / 36524.25) step 2
\end_layout

\begin_layout Plain Layout
B = A - INT(A / 4) part of step 3
\end_layout

\begin_layout Plain Layout
year = INT((B+G) / 365.25) part of step 3 and step 4
\end_layout

\begin_layout Plain Layout
C = B + Z - INT(365.25 * year) step 5
\end_layout

\begin_layout Plain Layout
month = FIX((5 * C + 456) / 153) step 6
\end_layout

\begin_layout Plain Layout
day = C - FIX((153 * month - 457) / 5) + R step 7 and 8
\end_layout

\begin_layout Plain Layout
IF month > 12 THEN step 9
\end_layout

\begin_layout Plain Layout
year = year + 1 step 9
\end_layout

\begin_layout Plain Layout
month = month - 12 step 9
\end_layout

\begin_layout Plain Layout
END IF step 9
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Equation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Baum step
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
Z = INT(JD - 1721118.5)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
step 1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
R = JD - 1721118.5 - Z
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
G = Z - .25
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
used in later steps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
A = INT(G / 36524.25)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
step 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
B = A - INT(A / 4)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
part of step 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
year = INT((B+G) / 365.25)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
part of step 3 and step 4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
C = B + Z - INT(365.25 * year)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
step 5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
month = FIX((5 * C + 456) / 153)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
step 6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
day = C - FIX((153 * month - 457) / 5) + R
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
step 7 and 8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
IF month > 12 THEN
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
step 9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
year = year + 1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
month = month - 12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
END IF
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In the following 
\family typewriter
$jd
\family default
 is now in 
\emph on
seconds
\emph default
,
 as are 
\family typewriter
$LCL
\family default
 (Zone offset) and 
\family typewriter
$DST
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub FullGregorian #
\end_layout

\begin_layout Plain Layout

{ my($jd,
 $LCL,
 $DST,
 $isgps);
\end_layout

\begin_layout Plain Layout

    ($jd,
 $LCL,
 $DST,
 $isgps)=@_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # ensure $jd is in integer seconds,
 and likewise for LCL,
 DST:
\end_layout

\begin_layout Plain Layout

  $jd = &Biggen($jd);
 
\end_layout

\begin_layout Plain Layout

  $LCL = &Biggen($LCL);
\end_layout

\begin_layout Plain Layout

  $DST = &Biggen($DST);
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($isgps)
\end_layout

\begin_layout Plain Layout

  { $jd = &ExGps($jd);
  # get rid of GPS offset,
 still integer.
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($Z,
 $R,
 $G,
 $A,
 $B,
 $C);
\end_layout

\begin_layout Plain Layout

  my($year,
 $month,
 $day);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  $jd += $LCL+$DST;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($ss);
  
\end_layout

\begin_layout Plain Layout

  my($hh,
 $mm);
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    $Z = floor($jd/86400 - 1721118.5);
       # Z = integer Julian days (exact) 
\end_layout

\begin_layout Plain Layout

    $R = $jd - 43200*(3442237 + 2*$Z);
       # 1721118.5*2 = 3442237 
\end_layout

\begin_layout Plain Layout

      # R is the rest (as seconds,
 integer)
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    # the following are calculations in terms of days,
 including leap years etc.:
 
\end_layout

\begin_layout Plain Layout

    $G = $Z - 0.25;
                          # 0.25 is precise,
 $G precise (days)
\end_layout

\begin_layout Plain Layout

    $A = floor( ($G) / 36524.25);
            # $A is integer 
\end_layout

\begin_layout Plain Layout

    $B = $A - floor( ($A) / 4);
              # $B is integer 
\end_layout

\begin_layout Plain Layout

    $year = floor( ($B+$G) / (365.25) );
     # $year is integer 
\end_layout

\begin_layout Plain Layout

    $C = $B + $Z - floor(365.25 * $year);
  # $C is integer
\end_layout

\begin_layout Plain Layout

    $month = int( (5 * $C + 456) / 153 );
    # 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    $day = $C - int( (153 * $month - 457) / 5 ) + $R/86400;
 # note $R use
\end_layout

\begin_layout Plain Layout

  if ($month > 12)
\end_layout

\begin_layout Plain Layout

     { $year = $year + 1;
\end_layout

\begin_layout Plain Layout

       $month = $month - 12;
\end_layout

\begin_layout Plain Layout

     };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    my($hms) = 24*$R;
                 # 24*seconds !!
\end_layout

\begin_layout Plain Layout

    $hh =int($hms/86400);
             # hours
\end_layout

\begin_layout Plain Layout

    my($ms) = 60*($hms - $hh*86400);
  # minutes AND seconds
\end_layout

\begin_layout Plain Layout

    $mm =int($ms/86400);
              # minutes
\end_layout

\begin_layout Plain Layout

    my($sx) = 60*($ms - $mm*86400);
 
\end_layout

\begin_layout Plain Layout

    $ss = int($sx/86400);
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    # a redundant check:
 
\end_layout

\begin_layout Plain Layout

if($ss - $sx/86400 != 0) # should always be exact,
 check:
 
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    print 
\begin_inset Quotes eld
\end_inset


\backslash
n***BLAST!!*** $ss,
 $sx :
 delta=
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Plain Layout

          .
 sprintf(
\begin_inset Quotes eld
\end_inset

%.12f
\begin_inset Quotes erd
\end_inset

,
 ($ss - $sx/86400) );
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return ($year,
 $month,
 int($day),
 $hh,
 $mm,
 $ss );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub FullGregorian #
\end_layout

\begin_layout Plain Layout

{ my($jd,
 $LCL,
 $DST,
 $isgps);
\end_layout

\begin_layout Plain Layout

    ($jd,
 $LCL,
 $DST,
 $isgps)=@_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($isgps)
\end_layout

\begin_layout Plain Layout

  { $jd = &ExGps($jd);
  # get rid of GPS offset
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($Z,
 $R,
 $G,
 $A,
 $B,
 $C);
\end_layout

\begin_layout Plain Layout

  my($year,
 $month,
 $day);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($DELTA) = $LCL+$DST;
 
\end_layout

\begin_layout Plain Layout

  $jd += $DELTA;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ## NOT:
 $jd += $epsilon;
 # 1 != 0.99999999...99 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ## now use Julian day values [explore]
\end_layout

\begin_layout Plain Layout

  $jd /= 86400;
  # or invoke JulianDay_() 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($ss)=60;
 
\end_layout

\begin_layout Plain Layout

  my($hh,
 $mm);
 
\end_layout

\begin_layout Plain Layout

while($ss > 59) # compensate for round-up of seconds to 60 :( 
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    $Z = floor($jd - 1721118.5);
 # 1721118.5 is precise,
 $Z is integer:
 Note $jd dependency
\end_layout

\begin_layout Plain Layout

    $R = $jd - 1721118.5 - $Z;
              # 1721118.5 is precise,
 $R incorporates $jd 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    $G = $Z - 0.25;
                        # 0.25 is precise $G is precise
\end_layout

\begin_layout Plain Layout

    $A = floor($G / 36524.25);
             # $A is integer 
\end_layout

\begin_layout Plain Layout

    $B = $A - floor($A / 4);
               # $B is integer 
\end_layout

\begin_layout Plain Layout

    $year = floor(($B+$G) / 365.25);
       # $year is integer 
\end_layout

\begin_layout Plain Layout

    $C = $B + $Z - floor(365.25 * $year);
  # $C is integer
\end_layout

\begin_layout Plain Layout

    $month = int((5 * $C + 456) / 153);
    # 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    $day = $C - int((153 * $month - 457) / 5) + $R;
 # note incorporation of $R 
\end_layout

\begin_layout Plain Layout

  if ($month > 12)
\end_layout

\begin_layout Plain Layout

     { $year = $year + 1;
\end_layout

\begin_layout Plain Layout

       $month = $month - 12;
\end_layout

\begin_layout Plain Layout

     };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    my($hms) = 24*$R;
                 # fraction of day left converted to hours
\end_layout

\begin_layout Plain Layout

    $hh =int($hms);
  # 
\end_layout

\begin_layout Plain Layout

    my($ms) = 60*($hms - $hh);
        # note use of $hh
\end_layout

\begin_layout Plain Layout

    $mm =int($ms);
                    # minutes
\end_layout

\begin_layout Plain Layout

    my($sx) = 60*( $ms - $mm );
       # note use of $mm 
\end_layout

\begin_layout Plain Layout

    # ignore fractional seconds.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    $ss = int($sx+EPSILONSECONDS);
 # hmm.
 [EXPLORE AND FIX THIS!]
\end_layout

\begin_layout Plain Layout

    $jd += EPSILONSECONDS / 86400;
 # add a fraction of a second [nasty] 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  return ($year,
 $month,
 int($day),
 $hh,
 $mm,
 $ss );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
[FIX THE ABOVE BY USING SECONDS RATHER THAN JULIAN DAY,
 THROUGHOUT][fix me!]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The above presents a fairly subtle problem.
 Sometimes the calculations will provide a 
\family typewriter
$sx
\family default
 value like 5.999999 rather than 6.
 It's thus tempting to just add 
\family typewriter
EPSILONSECONDS
\family default
 (eg.
 10ms) to this value before saying 
\family typewriter
int($sx)
\family default
.
 The catch comes with a value of 59.999999 —
 the error can propagate backwards to hours and minutes too.
 There are three sources of inaccuracy:
 
\family typewriter
$LCL
\family default
,
 
\family typewriter
$DST
\family default
 and 
\family typewriter
$jd
\family default
.
 Any of these,
 or any combination of these,
 can lead to 0.999\SpecialChar ldots
 rather than 1 in any derived value.
 This gives us great scope for error.
\end_layout

\begin_layout Enumerate
An immediate issue is that 
\family typewriter
$jd+$LCL+$DST
\family default
 can give such a rounding error,
 propagating into the values of $Z and $R.
 Any of the floor/integer values may similarly trouble us.
\end_layout

\begin_layout Enumerate
In our first adjustment and calculation of day units in $Z,
 we've 
\begin_inset Quotes eld
\end_inset

fixed
\begin_inset Quotes erd
\end_inset

 not just days,
 but everything greater—
$$G,
 $A,
 $B,
 $year,
 $C,
 $month.
\end_layout

\begin_layout Enumerate
But what about hours?
 Is it possible that we have something like 0.999999 hours?
 Likewise for the 60* factors related to minutes and seconds.
 The best approach is surely to fix the adjustments at every step,
 with an appropriate 
\begin_inset Quotes eld
\end_inset

size compensation
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
ExGPS
\end_layout

\begin_layout Standard
Given Julian day number as seconds,
 remove GPS adjustment (leap seconds).
 This assumes 
\family typewriter
@LEAPDATA
\family default
 has been populated.
 
\end_layout

\begin_layout Standard
The value supplied in J is in seconds.
 
\family typewriter
@LEAPDATA
\family default
 contains (in order) a gps timestamp,
 a utc timestamp,
 and the offset in seconds.
 To convert from GPS to utc,
 subtract the offset value if the time is greater than or equal to the cutoff time;
 otherwise move to the next row and repeat,
 finally adding 9s if no match is found (The table has the most recent value as its 
\emph on
first
\emph default
 entry).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub ExGps # 
\end_layout

\begin_layout Plain Layout

{ my($J);
\end_layout

\begin_layout Plain Layout

    ($J)=@_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($Ltop) = scalar @LEAPDATA;
 
\end_layout

\begin_layout Plain Layout

  my($i) = 0;
\end_layout

\begin_layout Plain Layout

while($i < $Ltop)
\end_layout

\begin_layout Plain Layout

  { my($d) = $LEAPDATA[$i];
\end_layout

\begin_layout Plain Layout

    my(@D) = @$d;
 # dereference # [clumsy]
\end_layout

\begin_layout Plain Layout

  if( $J >= ($D[0]/1000000.0) )        # [check this inequality ??]
\end_layout

\begin_layout Plain Layout

    { return($J-$D[2]);
 # days
\end_layout

\begin_layout Plain Layout

    };
\end_layout

\begin_layout Plain Layout

    $i ++;
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  return($J+9);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Invoking FullGregorian
\begin_inset space ~
\end_inset

()
\end_layout

\begin_layout Standard
Because of the central position of this function and the first argument,
 let's look at how it's invoked.
 The callers are:
 
\end_layout

\begin_layout Description
FetchTzDate
\begin_inset space ~
\end_inset

() Invoked by:
 
\end_layout

\begin_deeper
\begin_layout Description
InternalJulian
\begin_inset space ~
\end_inset

() Implements g,
 u [end]
\end_layout

\begin_layout Description
Multitest
\begin_inset space ~
\end_inset

() implements v [end]
\end_layout

\end_deeper
\begin_layout Description

\emph on
ListLeapseconds
\begin_inset space ~
\end_inset

() Trivial 
\end_layout

\begin_layout Description
J2G
\begin_inset space ~
\end_inset

() —
 Invokers:
\end_layout

\begin_deeper
\begin_layout Description
MultiTest
\begin_inset space ~
\end_inset

() implements v,
 as above [end]
\end_layout

\end_deeper
\begin_layout Description
Greg
\begin_inset space ~
\end_inset

() Multiple uses:
\end_layout

\begin_deeper
\begin_layout Description
ReadLeapseconds
\begin_inset space ~
\end_inset

() A simple check.
 [end] 
\end_layout

\begin_layout Description
InternalJulian
\begin_inset space ~
\end_inset

() Implements g,
 u [end],
 as above.
 
\end_layout

\begin_layout Description
Multitest
\begin_inset space ~
\end_inset

() implements v,
 as above [end]
\end_layout

\begin_layout Description

\end_layout

\end_deeper
\begin_layout Description

\emph on
QuickJ2G
\begin_inset space ~
\end_inset

() ??
 —
 of dubious current utility,
 needs work.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Fix date fraction
\begin_inset CommandInset label
LatexCommand label
name "subsec:Fix-date-fraction"

\end_inset


\end_layout

\begin_layout Standard
Remove fractional seconds from date;
 SQL server chokes
\begin_inset Note Note
status open

\begin_layout Plain Layout
[or certainly used to choke]
\end_layout

\end_inset

 if more than 3 digits.
 [?
 utility] 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub ClipFractionalSeconds #
\end_layout

\begin_layout Plain Layout

{ my($d) = @_;
\end_layout

\begin_layout Plain Layout

if($d =~ /(.+)
\backslash
.(
\backslash
d+)/ )
\end_layout

\begin_layout Plain Layout

  { $d = $1;
  # clip everything after the decimal,
 AND the decimal point
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  return($d);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Single Gregorian
\end_layout

\begin_layout Standard
The value in $J is Julian,
 but in seconds;
 
\family typewriter
$LCL
\family default
 and 
\family typewriter
$DST
\family default
 likewise.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Greg #
\end_layout

\begin_layout Plain Layout

{ my($J,
 $LCL,
 $DST,
 $isgps) = @_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($J < 1) # rubbish
\end_layout

\begin_layout Plain Layout

  { return('_');
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  my($YY,$MM,$DD,
 $h,$m,$s) = &FullGregorian($J,
 $LCL,
 $DST,
 $isgps);
\end_layout

\begin_layout Plain Layout

if($YY < 1) # 1 AD
\end_layout

\begin_layout Plain Layout

  { return('?');
 # we're not interested in BC!
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  return( &PrettyDate(0,$YY,$MM,$DD,$h,$m,$s) );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Pretty date
\end_layout

\begin_layout Standard
If the initial value is non-zero (i.e.
 1) use 'T' as the separator between date and time,
 rather than ' '.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub PrettyDate # 
\end_layout

\begin_layout Plain Layout

{ my($isT,
 $YYYY,$M,$D,$h,$m,$s) = @_;
\end_layout

\begin_layout Plain Layout

  my($spacer) = ' ';
 # usual separator between date and time
\end_layout

\begin_layout Plain Layout

if($isT)
\end_layout

\begin_layout Plain Layout

  { $spacer = 'T';
 
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout

  return( "$YYYY-" .
 &DoubleDigit($M) .
 '-' .
 &DoubleDigit($D) .
 $spacer 
\end_layout

\begin_layout Plain Layout

    .
 &DoubleDigit($h) .
 ':' .
 &DoubleDigit($m) .
 ':' .
 &DoubleDigit($s) );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Microseconds to Julian
\end_layout

\begin_layout Standard
The converse,
 now simply converting microseconds to seconds,
 rather than a Julian day number or part thereof.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub HugeToJ # 
\end_layout

\begin_layout Plain Layout

{ my($d);
\end_layout

\begin_layout Plain Layout

    ($d)=@_;
\end_layout

\begin_layout Plain Layout

if(!
 defined $d)
\end_layout

\begin_layout Plain Layout

  { return(PART_EMPTY);
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

if($d !~ /^-?
\backslash
d+/ )  # allow -ves
\end_layout

\begin_layout Plain Layout

  { return('_')
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

  ## print 
\begin_inset Quotes eld
\end_inset

HugeToJ took $d gave 
\begin_inset Quotes eld
\end_inset

 .
 sprintf(
\begin_inset Quotes eld
\end_inset

%.12f
\begin_inset Quotes erd
\end_inset

,
 $d/1000000) .
 
\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

  return( &Biggen($d/1000000) );
 # convert microseconds to *int* seconds [NB] 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Julian to Gregorian
\end_layout

\begin_layout Standard
Given J,
 a GPS timestamp,
 convert this to a Gregorian date pertinent to that location (wall clock time).
 As all of the stored values in the relevant row of the database use GPS time,
 comparisons are relatively simple,
 and we don't adjust for leap seconds until just before we convert to Gregorian.
 
\end_layout

\begin_layout Enumerate
Find the location code and year.
 Get the relevant line for this location and year from 
\series bold
daytime
\series default
.
 Note that if we are within a few hours of the start or end of the year,
 we may have a problem,
 as we will only be certain that we are within the 
\begin_inset Quotes eld
\end_inset

wall clock year
\begin_inset Quotes erd
\end_inset

 after we've gone through the whole of the following calculation!
 So we may determine that we've chosen the wrong year 
\emph on
after 
\emph default
we've done all of the calculations,
 and may have to repeat with the following or previous year!
 [EXPLORE THIS ANOMALY,
 might facilitate by having a third redundant timestamp that signals the start of the year in wall time,
 and even a fourth 
\begin_inset Quotes eld
\end_inset

year end
\begin_inset Quotes erd
\end_inset

]
\end_layout

\begin_layout Enumerate
Record the 
\series bold
zone_offset
\series default
 as Z,
 and if 
\series bold
zone_transition
\series default
 is nonzero:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
If J >= 
\series bold
zone_transition
\series default
,
 set Z to 
\series bold
zone_future
\series default
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[what if this is zero??
 explore]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Create D=0,
 the daylight saving value.
 Now,
 if 
\series bold
dst_start
\series default
 is non-zero:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
If 
\series bold
dst_end
\series default
 is zero:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if J >= 
\series bold
dst_start
\series default
,
 D = 
\series bold
dst_add
\series default
;
 
\end_layout

\end_deeper
\begin_layout Enumerate
else,
 if 
\series bold
dst_end
\series default
 > 
\series bold
dst_start
\series default
,
 we are in northern hemisphere:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if J >= 
\series bold
dst_start
\series default
 and J < 
\series bold
dst_end
\series default
,
 D = 
\series bold
dst_add
\series default
;
\end_layout

\end_deeper
\begin_layout Enumerate
else,
 must be in southern hemisphere:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if J < 
\series bold
dst_end
\series default
,
 D = 
\series bold
prior_add
\series default
;
\end_layout

\begin_layout Enumerate
if J >= 
\series bold
dst_start
\series default
 D = 
\series bold
dst_add
\series default
;
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Else (
\series bold
dst_start
\series default
 is zero) if 
\series bold
dst_end
\series default
 is non-zero:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if J < 
\series bold
dst_end
\series default
,
 D = 
\series bold
prior_add
\series default
 (Carried over from previous year) 
\end_layout

\end_deeper
\begin_layout Enumerate
Adjust J for leap seconds using the relevant GPS time cutoff;
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[CHECK ME:
 IS THIS RIGHT?]
\end_layout

\end_inset

 to J add Z the relevant 
\series bold
zone_offset
\series default
 and D dst value (add) and make the actual timestamp.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
J2G
\begin_inset CommandInset label
LatexCommand label
name "subsec:J2G"

\end_inset


\end_layout

\begin_layout Standard
The submitted 
\family typewriter
$jd
\family default
 value is GPS time in seconds.
 We adjust for zone and DST for this time and 
\family typewriter
$zone
\family default
.
 By submitting 
\family typewriter
$qic=1
\family default
 to Anomalous
\begin_inset space ~
\end_inset

(),
 we can speed things up a bit.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Amended 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[on 12/12/2020]
\end_layout

\end_inset

 to return three added values,
 Z and D as fractions of a day,
 and $hog,
 derived from Anomalous
\begin_inset space ~
\end_inset

(),
 a routine that is very slow because it interrogates the database.
 The $hog value is normally 0;
 it's nonzero if we're in the 
\begin_inset Quotes eld
\end_inset

shadow
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

groundhog
\begin_inset Quotes erd
\end_inset

 hour;
 we also accommodate something similar when the zone offset changes!
 Effectively,
 when the zone offset becomes smaller,
 this is like falling back in autumn;
 conversely,
 there is a gap when the zone offset increases.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Returns a plethora of values:
\end_layout

\begin_layout Description
$YY,
\begin_inset space ~
\end_inset

$MM,
\begin_inset space ~
\end_inset

$DD,
\begin_inset space ~
\end_inset

$h,
\begin_inset space ~
\end_inset

$m,
\begin_inset space ~
\end_inset

$s Obvious from context
\end_layout

\begin_layout Description
$LCL Z value in seconds,
 currently obtaining for this date 
\end_layout

\begin_layout Description
$DST DST value in seconds,
 likewise.
 
\end_layout

\begin_layout Description
$hog Whether we're in the zone (
\begin_inset Quotes eld
\end_inset

groundhog zone
\begin_inset Quotes erd
\end_inset

) where Julian values are ambiguous,
 because we've fallen back,
 either due to cancellation of DST,
 or a zone change.
 Is -1 if the Julian value is in the shadow zone;
 is +1 if we're in the 
\begin_inset Quotes eld
\end_inset

fall-back
\begin_inset Quotes erd
\end_inset

 area.
 
\end_layout

\begin_layout Description
$delta_Z The amount of zone change in seconds
\end_layout

\begin_layout Description
$delta_DST The amount of DST change,
 in seconds.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub J2G # 
\end_layout

\begin_layout Plain Layout

{ my($qic,
 $zone,
 $jd) = @_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($J) = $jd * 1000000;
  # [really should use big number libraries]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($YEAR,
 $xMM,
 $xDD,
 $xh,
 $xm,
 $xs) = &FullGregorian($jd,
 0,
 0,
 1);
  # NB $jd NOT $J
\end_layout

\begin_layout Plain Layout

    # clumsy,
 rather just divide etc.
 [fix me]
\end_layout

\begin_layout Plain Layout

  # print 
\begin_inset Quotes eld
\end_inset

Debug:
 J2G :
 $zone $jd
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($Z,$D,
 $hog,
 $deltz,
 $delds) = &Anomalous($qic,
 $zone,
 $YEAR,
 $J);
\end_layout

\begin_layout Plain Layout

  # NB.
 $deltz,
 $delds are in microseconds,
 at present.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my($LCL) = $Z/1000000;
 # microseconds to days
\end_layout

\begin_layout Plain Layout

  my($DST) = $D/1000000;
 #
\end_layout

\begin_layout Plain Layout

  my($YY,
 $MM,
 $DD,
 $h,
 $m,
 $s) = &FullGregorian($jd,
 $LCL,
 $DST,
 1);
  # GPS *on*
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

# print 
\begin_inset Quotes eld
\end_inset

Debug:
 J2G done:
 $YY,
 $MM,
 $DD,
 $h,
 $m,
 $s
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # return all values,
 not a composite:
\end_layout

\begin_layout Plain Layout

  return( $YY,
 $MM,
 $DD,
  $h,
 $m,
 $s,
  $LCL,
 $DST,
 $hog,
 $deltz/1000000,
 $delds/1000000);
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# we now permit DST < 0,
 thus suppress:
\end_layout

\begin_layout Plain Layout

#if($D < 0)
\end_layout

\begin_layout Plain Layout

#  { 
\end_layout

\begin_layout Plain Layout

#  if($zone == $UTCCODE)  # special case of UTC [NASTY,
 really need global constant not inline here??]
\end_layout

\begin_layout Plain Layout

#    { $Z = 0;
\end_layout

\begin_layout Plain Layout

#      $D = 0;
\end_layout

\begin_layout Plain Layout

#    } else
\end_layout

\begin_layout Plain Layout

#    { print 
\begin_inset Quotes eld
\end_inset

Debug:
 bugger!
\backslash
n
\begin_inset Quotes erd
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

#      return(0,0,0,
 0,0,0,
 0,0,0);
  # signal failure
\end_layout

\begin_layout Plain Layout

#    };
\end_layout

\begin_layout Plain Layout

#  };
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Handle anomalies
\begin_inset CommandInset label
LatexCommand label
name "subsec:Handle-anomalies"

\end_inset


\end_layout

\begin_layout Standard
Recall that in timely,
 all transitions refer to the past,
 and associated Z and DST values apply until the transition.
 Anomalous
\begin_inset space ~
\end_inset

() retrieves relevant entries for zone and year.
 If nil found,
 fail;
 otherwise iterate through until transition value above Julian.
 We know the DST and zone values then apply.
 Anomalous
\begin_inset space ~
\end_inset

() is only invoked by J2G
\begin_inset space ~
\end_inset

().
 The arguments are:
 
\end_layout

\begin_layout Description
$handDB Database handle
\end_layout

\begin_layout Description
$zone Internal zone code
\end_layout

\begin_layout Description
$YEAR eponymous
\end_layout

\begin_layout Description
$JBIG The Julian timestamp we wish to characterise:
 this is a big integer in microseconds after -4712-1-1 12:00:00 i.e.
 January 1st,
 4713 BCE.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The return values are several:
\end_layout

\begin_layout Description
$z The 
\emph on
current
\emph default
 Z for this timestamp;
\end_layout

\begin_layout Description
$d The 
\emph on
current
\emph default
 DST for this timestamp;
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

$hog
\begin_inset Quotes erd
\end_inset

 Whether the timestamp is within the 
\begin_inset Quotes eld
\end_inset

shadow
\begin_inset Quotes erd
\end_inset

 (groundhog) zone where two Julian values map to one wall time.
 This code has internal structure:
\end_layout

\begin_deeper
\begin_layout Description
0 Not in shadow
\end_layout

\begin_layout Description
-1 In shadow,
 the first of the two Julian values that map to a single wall timestamp
\end_layout

\begin_layout Description
1 The second shadow
\end_layout

\end_deeper
\begin_layout Description
$deltaz if $hog is non-zero,
 then the pertinent change in zone offset that generated the relevant shadow;
 otherwise zero
\end_layout

\begin_layout Description
$ddst likewise.
 
\end_layout

\begin_layout Standard
For dealing with a $JBIG value that's close to a transition T,
 it's important to identify whether the value is within the 
\begin_inset Quotes eld
\end_inset

groundhog
\begin_inset Quotes erd
\end_inset

 period after the transition from a higher DST value D[-1] to a lower one D[0],
 in other words if:
\end_layout

\begin_layout Itemize
D[0] < D[-1] 
\series bold
and
\series default
 
\end_layout

\begin_layout Itemize
T < JBIG < T+D 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
This is however a bit more nuanced,
 because logically the antecedent period is similarly ambivalent!
 A single 
\begin_inset Quotes eld
\end_inset

wall time
\begin_inset Quotes erd
\end_inset

 value maps to 
\emph on
two
\emph default
 UTC (or GPS) timestamps.
 There's yet another complication:
 if there's a similar transition from a given zone offset to a smaller zone offset,
 at the transition we'll jump back in time by the difference,
 with another 
\begin_inset Quotes eld
\end_inset

groundhog hour
\begin_inset Quotes erd
\end_inset

.
 We also need to accommodate this.
 
\end_layout

\begin_layout Standard
Another issue is where we're at the (early) cusp of a transition,
 for example at the start of the shadow hour when DST of +1 hour is about to be turned off.
 The -1
\begin_inset space \thinspace{}
\end_inset

hour mark must be included in this shadow hour—
otherwise we'll get an error for every v-3600 (or whatever).
 
\end_layout

\begin_layout Standard
We also return the actual delta values for zone and time,
 where appropriate 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[This is clunky and can be refined,
 fix me!]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now consider the following example (Europe/Minsk in 1941):
 at a wall time of 1941-06-28 00:00:00,
 corresponding to UTC 1941-06-27 21:00:00,
 we drop z from 3 to 1 hours and add DST of 1 hour.
 Effectively we jump back by 1 hour to a wall time of 1941-06-27 23:00:00 (UTC 1941-06-27 20:00:00 also corresponds);
 the shadow period is thus calculated by deltaDST-deltaZ = 1 -2 = -1.
 any wall time between 23:00 and 00:00 of the next day is in the shadow,
 corresponding to UTC 1941-06-27 20:00:00 to 22:00:00.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

sub Anomalous #
\end_layout

\begin_layout Plain Layout

{ my($qic,
 $zone,
 $YEAR,
 $JBIG);
\end_layout

\begin_layout Plain Layout

    ($qic,
 $zone,
 $YEAR,
 $JBIG)=@_;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if($zone == $UTCCODE)
\end_layout

\begin_layout Plain Layout

  { return(0,
 0,
 0,
 0,
 0);
  # Z=0,
 DST=0,
 not groundhog,
 ...
\end_layout

\begin_layout Plain Layout

  };
  # [explore:
 what it $zone is zero??] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if( $qic
\end_layout

\begin_layout Plain Layout

  &&($zone != $MYZONE) # check it's the right region,
 D'Oh!
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  { &Aagh(
\begin_inset Quotes eld
\end_inset

Quick Anomaly,
 mismatched zones:
 $zone|$MYZONE
\begin_inset Quotes erd
\end_inset

,
 __LINE__,
 0);
 
\end_layout

\begin_layout Plain Layout

    return;
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Prepare SQL,
 as needed:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

  ## my($epsilon) = 500000;
 # microseconds 0.5 seconds [?
 :
 see notes] 
\end_layout

\begin_layout Plain Layout

  my($epsilon) = 10000;
 # 10 microseconds
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  my(@ROWS);
\end_layout

\begin_layout Plain Layout

  my($hi) = 2 + int($YEAR);
\end_layout

\begin_layout Plain Layout

  my($lo) =-1 + int($YEAR);
\end_layout

\begin_layout Plain Layout

if($qic)
\end_layout

\begin_layout Plain Layout

  { (@ROWS) = &QuickBetween($lo,
 $hi);
 # as for G2J_():
 get tr,
 dst,
 zo,
 ignored
\end_layout

\begin_layout Plain Layout

  } else
\end_layout

\begin_layout Plain Layout

  { my($handDB) = $DB_MAIN;
  
\end_layout

\begin_layout Plain Layout

    my($q) = "SELECT transition,
 dst,
 zone_offset,
 ignored from timely "
\end_layout

\begin_layout Plain Layout

                                   # a dummy value ^ 
\end_layout

\begin_layout Plain Layout

    .
 "WHERE region = $zone AND year BETWEEN $lo AND $hi ORDER BY transition";
  # ASC
\end_layout

\begin_layout Plain Layout

    (@ROWS) = &SQLManySQL($handDB,
 $q,
 'get all rows');
\end_layout

\begin_layout Plain Layout

  };
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the above SQL,
 because there ia always a transition at year end,
 we are guaranteed values in the preceding and following years,
 to act as 
\begin_inset Quotes eld
\end_inset

stoppers
\begin_inset Quotes erd
\end_inset

,
 unless the submitted date is 
\begin_inset Quotes eld
\end_inset

out of range
\begin_inset Quotes erd
\end_inset

—
too low or too high for there to be stoppers.
 To accommodate year-end transitions,
 the 
\family typewriter
$hi
\family default
 value adds not one but two years.
 
\end_layout

\begin_layout Standard
We now find where $JBIG lies.
 In the 
\series bold
timely
\series default
 table,
 the Z and DST values apply prior to any transition.
 Because two Julian values may map to a single wall time,
 there may be gaps in the wall time,
 but there should never be an unmapped Julian value—
this would imply a Julian outside the range of the database.
 We will not only return the Z and DST values that apply to the submitted Julian,
 but also signal (in 
\begin_inset Quotes eld
\end_inset

$hog
\begin_inset Quotes erd
\end_inset

,
 the third value returned) whether there is a second Julian value that would also have given the same wall time!
 
\end_layout

\begin_layout Standard
We:
\end_layout

\begin_layout Enumerate
Work through all of the rows,
 until $JBIG is below the transition time.
 Initially,
 because the transition times are sorted in ascending order and we work upwards,
 $JBIG will be above the current transition (If we've input a very low value of $JBIG,
 then the first row will apply,
 willy-nilly).
 If we reach the end without the condition being met,
 then we have a problem:
 our date is out of range.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[explore handling,
 fix]
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Another way of saying $JBIG is below is that $tr - $JBIG > 0.
 Actually,
 I use a slight value over 0,
 $epsilon,
 e.g.
 half a second or less.
 This means that if $JBIG is exactly at the interface,
 the next transition applies,
 rather than the current one.
 
\end_layout

\end_deeper
\begin_layout Enumerate
We now know that the row (with its Z,
 DST) applies to our time.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
A few initialisations,
 and we're in a large 
\family typewriter
while
\family default
 loop that performs the test just described:
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim} 
\end_layout

\begin_layout Plain Layout

  my($r);
\end_layout

\begin_layout Plain Layout

  my($trold) = 0;
 # preceding transition
\end_layout

\begin_layout Plain Layout

  my($dold) = 0;
  # preceding DST value
\end_layout

\begin_layout Plain Layout

  my($zold) = 0;
  # preceding zone offset
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  my($i) = 0;
\end_layout

\begin_layout Plain Layout

  my($rL) = scalar @ROWS;
 
\end_layout

\begin_layout Plain Layout

while($i < $rL)
\end_layout

\begin_layout Plain Layout

  { $r = $ROWS[$i];
 
\end_layout

\begin_layout Plain Layout

    my($tr,
 $d,
 $z,
 $dmy) = @$r;
  # database tr (Julian),
 DST,
 Z that apply up to $tr.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if( ($tr - $JBIG) > $epsilon )  # we have our transition row:
 A large IF CLAUSE 
\end_layout

\begin_layout Plain Layout

    { ## print 
\begin_inset Quotes eld
\end_inset


\backslash
n[$JBIG :
 $tr],
 diff=
\begin_inset Quotes erd
\end_inset

 .
 ($tr - $JBIG) ;
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now the value in JBIG is somewhere in between the previous transition ($trold) and the current transition ($tr):
 
\end_layout

\begin_layout Quote

\family typewriter
previous transition > || xxx | ...
 | yyy || < current transition.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The DST and Zone parameters $d and $z relate to this interval;
 the values in $dold and $zold relate to the previous one.
 There are two rather special cases:
\end_layout

\begin_layout Enumerate
JBIG is within the section indicated by xxx—
and xxx reflects a 
\begin_inset Quotes eld
\end_inset

groundhog hour
\begin_inset Quotes erd
\end_inset

 where this Julian value and another value both map to the same wall time (this is the second Julian,
 and will be signalled by $hog=1),
 around the 
\emph on
previous
\emph default
 transition.
 The change in Z and/or change in DST that brought this about relate to the difference between the current values and the preceding ones.
 
\end_layout

\begin_layout Enumerate
JBIG is within the section indicated by yyy,
 another groundhog time,
 but this time,
 the first Julian that maps to the groundhog hour about the current transition.
 This will be signalled by $hog = -1.
 The change in Z and/or DST relate to the current transition,
 and as such,
 we need to examine 
\emph on
future
\emph default
 Z and DST values from the subsequent transition!
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
First,
 the simpler case of $hog = 1.
 As a convenience,
 we identify section xxx by adding the change in Z and DST (let's call this $shadow):
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Still in the transition,
 test whether $JBIG is in shadow.
 To do this,
 we need to calculate the net 
\begin_inset Quotes eld
\end_inset

amount of shadow
\begin_inset Quotes erd
\end_inset

.
 If the overall effect is a jump back,
 then we are potentially in shadow.
 This will potentially be the case if DST was positive and now is zero ($d - $dold is negative,
 i.e.
 we've fallen back) but also if Z has become less ($z - $zold) is negative,
 or the sum of these two delta values is negative;
 otherwise we can simply return the Z and DST values with a zero value in $hog.
\end_layout

\begin_layout Plain Layout
As a convenience,
 let's call the sum of the two deltas 
\begin_inset Quotes eld
\end_inset

$shadow
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

      my($deltaz) = $z - $zold;
   # eg.
 will be negative if Z has decreased 
\end_layout

\begin_layout Plain Layout

      my($ddst) = $d - $dold;
     # eg.
 will be positive if spring forward
\end_layout

\begin_layout Plain Layout

      my($shadow) = $deltaz+$ddst;
  
\end_layout

\begin_layout Plain Layout

      ## print 
\begin_inset Quotes eld
\end_inset

 shadow=$shadow ($deltaz $ddst [$z $zold $d $dold]) 
\begin_inset Quotes eld
\end_inset

;
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the shadow is negative,
 then there was a jump back at and subsequent to the previous transition.
 To determine whether JBIG falls into section xxx,
 we thus 
\emph on
subtract
\emph default
 $shadow from $trold,
 and only respond if JBIG is less than this.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
If shadow is 
\emph on
negative
\emph default
,
 we have two cases where it's relevant:
\end_layout

\begin_layout Enumerate
$JBIG is in the first passage through the shadow:
\end_layout

\begin_layout Enumerate
$JBIG is going groundhog through the shadow period (But NB.
 see below).
\end_layout

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Plain Layout
For example,
 if DST goes from +1 hour to +0 hours at midnight (wall time),
 then just before we hit midnight,
 we fall back to 23:00 and repeat the hour;
 but a Julian value that corresponds to the first 23:00 is similarly 
\begin_inset Quotes eld
\end_inset

in the shadow
\begin_inset Quotes erd
\end_inset

.
 This is tricky.
\end_layout

\begin_layout Plain Layout
Let's consider the first case for this simple example,
 before we start combining DST+Z.
 It's clear that if JBIG is in the region between 
\family typewriter
($tr+$ddst)
\end_layout

\begin_layout Plain Layout
and 
\family typewriter
$tr
\family default
,
 knowing that $ddst is negative you can see we're appropriately 
\emph on
before
\emph default
 
\family typewriter
$tr
\family default
.
 But what if we've passed the transition?
 This contradicts our initial condition that 
\family typewriter
($tr - $JBIG) > $epsilon
\family default
!
 You can see that the condition for us being in the 
\begin_inset Quotes eld
\end_inset

groundhog hour
\begin_inset Quotes erd
\end_inset

 relates to the 
\emph on
preceding 
\emph default
transition at 
\family typewriter
$trold
\family default
!
\end_layout

\begin_layout Plain Layout
We can even generalise rather than the simple case of 
\family typewriter
$ddst
\family default
,
 but what value goes into $hog?
 I signal the first passage using -1.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

    if($JBIG < $trold-$shadow) # we know $JBIG is > $trold.
 
\end_layout

\begin_layout Plain Layout

      { ## print 
\begin_inset Quotes eld
\end_inset

Debug Anomalous_() z=$z d=$d
\backslash
n
\begin_inset Quotes erd
\end_inset

 ;
 
\end_layout

\begin_layout Plain Layout

        return($z,
 $d,
 1,
 $deltaz,
 $ddst);
 
\end_layout

\begin_layout Plain Layout

                     # ^ 
\begin_inset Quotes eld
\end_inset

$hog
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

      };
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second case,
 where JBIG is in section yyy,
 is a bit more tricky.
 We need to fetch the 
\emph on
following
\emph default
 values to calculate deltaz and ddst!
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
We have a problem with the 
\begin_inset Quotes eld
\end_inset

second (groundhog) passage
\begin_inset Quotes erd
\end_inset

 as this logically applies to a $JBIG value 
\emph on
just after $trold
\emph default
!
 This is where our Julian value 
\begin_inset Quotes eld
\end_inset

goes back
\begin_inset Quotes erd
\end_inset

 and walks through the shadow of the groundhog hour in the wall time.
 This in turn means that we need to examine how the PRECEDING values for $deltaz and $ddst relate to $trold !!
 The 
\begin_inset Quotes eld
\end_inset

$hog
\begin_inset Quotes erd
\end_inset

 value is here 1.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

      $i ++;
 
\end_layout

\begin_layout Plain Layout

    if($i >= $rL) # run out!!
\end_layout

\begin_layout Plain Layout

      { &Warn(3,
 
\begin_inset Quotes eld
\end_inset

Anomalous_() data ran out:
 zone=$zone,
 year=$YEAR,
 value=$JBIG
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Plain Layout

        return($z,
 $d,
 0,
 0,
 0);
 # or might even fail
\end_layout

\begin_layout Plain Layout

      };
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      $r = $ROWS[$i];
  # next row
\end_layout

\begin_layout Plain Layout

      my($tnext,
 $dnext,
 $znext) = @$r;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      # a further caution:
 ?
 can be 'next' transition almost immediately after
\end_layout

\begin_layout Plain Layout

      # current--- related to our end-of-year 'ignorable' insert.
 
\end_layout

\begin_layout Plain Layout

      # We thus check for this:
\end_layout

\begin_layout Plain Layout

    if( ($tnext - $tr) < 120000000) # currently use 2 minutes,
 NB Phoenix 
\end_layout

\begin_layout Plain Layout

      { $i ++;
 
\end_layout

\begin_layout Plain Layout

      if( $i >= $rL )  # [can this happen?]
\end_layout

\begin_layout Plain Layout

        { &Warn(3,
 
\begin_inset Quotes eld
\end_inset

Upper adjustment failed!!
 zone=$zone,
 year=$YEAR,
 value=$JBIG
\begin_inset Quotes erd
\end_inset

);
 
\end_layout

\begin_layout Plain Layout

        } else
\end_layout

\begin_layout Plain Layout

        { print '>>';
 # [hmm] 
\end_layout

\begin_layout Plain Layout

          $r = $ROWS[$i];
  # next row
\end_layout

\begin_layout Plain Layout

          ($tnext,
 $dnext,
 $znext) = @$r;
 # throw away the rubbish
\end_layout

\begin_layout Plain Layout

        };
 
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      # end check.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      my($nextdz) = $znext - $z;
\end_layout

\begin_layout Plain Layout

      my($nextdd) = $dnext - $d;
 
\end_layout

\begin_layout Plain Layout

      my($nextshadow) = $nextdz + $nextdd - $epsilon;
\end_layout

\begin_layout Plain Layout

      # epsilon extends the shadow slightly back to cover the e.g.
 -1hr mark.
 
\end_layout

\begin_layout Plain Layout

      ## print 
\begin_inset Quotes eld
\end_inset

 next shadow=$nextshadow ($nextdz $nextdd [$z $znext $d $dnext]) 
\begin_inset Quotes eld
\end_inset

;
 
\end_layout

\begin_layout Plain Layout

    if($JBIG > $tr+$nextshadow) # will only work if $nextshadow is -ve 
\end_layout

\begin_layout Plain Layout

      { ## print 
\begin_inset Quotes eld
\end_inset

Debug Anomalous_() z=$z d=$d
\backslash
n
\begin_inset Quotes erd
\end_inset

 ;
 
\end_layout

\begin_layout Plain Layout

        return($z,
 $d,
 -1,
 $nextdz,
 $nextdd);
\end_layout

\begin_layout Plain Layout

                      # ^ 
\begin_inset Quotes eld
\end_inset

$hog
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

      };
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otherwise,
 we've found our position,
 and values for Z and DST,
 and can simply return these.
 There is no groundhog issue.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[NEEDS WORK,
 SEE ABOVE.
\end_layout

\begin_layout Plain Layout
MUST ALSO EXPLORE the case where $$olddeltaz and $olddst are in the second pass,
 because of the initial values of 0 for both of these !!!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

        ## print 
\begin_inset Quotes eld
\end_inset

Debug Anomalous_() z=$z d=$d
\backslash
n
\begin_inset Quotes erd
\end_inset

 ;
 
\end_layout

\begin_layout Plain Layout

        return($z,
 $d,
 0,
 0,
 0);
 
\end_layout

\begin_layout Plain Layout

            # both zero ^  ^ if hog is zero [explore]  
\end_layout

\begin_layout Plain Layout

    };
 ## END large IF CLAUSE.
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The end of the large 
\family typewriter
while
\family default
 loop:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

    $trold = $tr;
\end_layout

\begin_layout Plain Layout

    $dold = $d;
\end_layout

\begin_layout Plain Layout

    $zold = $z;
 
\end_layout

\begin_layout Plain Layout

    $i ++;
 
\end_layout

\begin_layout Plain Layout

  };
 # end while.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # [EXPLORE THIS FAILURE] 
\end_layout

\begin_layout Plain Layout

  &Warn(1,
 "Timestamp 
\begin_inset Quotes eld
\end_inset

 .
 $JBIG/86400000000 .
 
\begin_inset Quotes eld
\end_inset

 out of range zone=$zone,
 y=$YEAR");
 
\end_layout

\begin_layout Plain Layout

  return(0,
 0,
 0,
 0,
 0);
 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Exiting here is disappointing:
 our translation has effectively failed.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
[ Is it possible for the transition to be the earliest one ??
 [this implies a row defect]] [explore!]
\end_layout

\begin_layout Plain Layout
== also:
 [in the following t is first,
 u is subsequent;
 we want drop in DST]
\end_layout

\begin_layout Plain Layout
SELECT
\end_layout

\begin_layout Plain Layout
p.description
\end_layout

\begin_layout Plain Layout
,GT(t.transition)
\end_layout

\begin_layout Plain Layout
,GT(u.transition)
\end_layout

\begin_layout Plain Layout
,t.zone_offset/3600000000
\end_layout

\begin_layout Plain Layout
,u.zone_offset/3600000000
\end_layout

\begin_layout Plain Layout
,t.dst/3600000000
\end_layout

\begin_layout Plain Layout
,u.dst/3600000000
\end_layout

\begin_layout Plain Layout
FROM timely t INNER JOIN timely u ON t.region = u.region
\end_layout

\begin_layout Plain Layout
INNER JOIN PLACES p ON t.region = p.place
\end_layout

\begin_layout Plain Layout
WHERE
\end_layout

\begin_layout Plain Layout
t.timekey = u.timekey-1
\end_layout

\begin_layout Plain Layout
AND u.zone_offset < t.zone_offset
\end_layout

\begin_layout Plain Layout
AND u.dst < t.dst;
\end_layout

\begin_layout Plain Layout
== there are just a few dual shifts:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

America/Argentina/Catamarca | 1991-03-03 15:00:07.0000 | 1991-10-20 17:00:07.0000 |                  -3.0000 |                  -4.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Argentina/Cordoba   | 1991-03-03 15:00:07.0000 | 1991-10-20 17:00:07.0000 |                  -3.0000 |                  -4.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Argentina/Jujuy     | 1990-03-04 15:00:06.0000 | 1990-10-28 17:00:06.0000 |                  -3.0000 |                  -4.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Argentina/La_Rioja  | 1991-03-01 15:00:07.0000 | 1991-05-07 16:00:07.0000 |                  -3.0000 |                  -4.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Argentina/Mendoza   | 1990-03-04 15:00:06.0000 | 1990-10-15 17:00:06.0000 |                  -3.0000 |                  -4.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Argentina/Salta     | 1991-03-03 15:00:07.0000 | 1991-10-20 17:00:07.0000 |                  -3.0000 |                  -4.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Argentina/San_Juan  | 1991-03-01 15:00:07.0000 | 1991-05-07 16:00:07.0000 |                  -3.0000 |                  -4.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Argentina/San_Luis  | 1990-03-14 15:00:06.0000 | 1990-10-15 17:00:06.0000 |                  -3.0000 |                  -4.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Argentina/Tucuman   | 1991-03-03 15:00:07.0000 | 1991-10-20 17:00:07.0000 |                  -3.0000 |                  -4.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Iqaluit             | 1999-10-31 19:00:13.0000 | 2000-01-01 19:00:12.0000 |                  -5.0000 |                  -6.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Juneau              | 1983-10-30 22:00:03.0000 | 1983-11-30 22:00:03.0000 |                  -8.0000 |                  -9.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Pangnirtung         | 1999-10-31 19:00:13.0000 | 2000-01-01 19:00:12.0000 |                  -5.0000 |                  -6.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

| America/Sitka               | 1983-10-30 22:00:03.0000 | 1983-11-30 22:00:03.0000 |                  -8.0000 |                  -9.0000 |           1.0000 |           0.0000 |
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
End off
\end_layout

\begin_layout Standard
In conclusion,
 I've learnt a few things:
 
\end_layout

\begin_layout Enumerate
Timezones are crazily complex and challenging to implement;
 
\end_layout

\begin_layout Enumerate
I was initially way off,
 in simply 
\begin_inset Quotes eld
\end_inset

going with the Perl flow
\begin_inset Quotes erd
\end_inset

 and with convention.
 I initially used floating point Julian day values.
 Far smarter is to rely on integer seconds,
 the problem being with Perl's failure to distinguish between integers and floating point.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Where a small floating point different results from division,
 it is wise to immediately coerce this back to an appropriate integer,
 being aware of the danger of truncation.
 
\end_layout

\end_deeper
\begin_layout Enumerate
A corollary of (2) that isn't immediately obvious is this:
\end_layout

\begin_deeper
\begin_layout Standard
Fractions of a second are the same in Julian and Gregorian space.
 So to convert between them:
\end_layout

\begin_layout Enumerate
First,
 strip off the partial second;
\end_layout

\begin_layout Enumerate
Then do the integer conversion to seconds in the relevant space (with appropriate checks and attachments);
\end_layout

\begin_layout Enumerate
Finally add the partial seconds back again!
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Formerly:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

## no!
\end_layout

\begin_layout Plain Layout

## &ImplementExit('0');
\end_layout

\begin_layout Plain Layout

##################################################
\end_layout

\begin_layout Plain Layout

#              END OF MAIN ROUTINE               #
\end_layout

\begin_layout Plain Layout

##################################################
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger 
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

##################################################
\end_layout

\begin_layout Plain Layout

#              END OF MAIN ROUTINE               #
\end_layout

\begin_layout Plain Layout

##################################################
\end_layout

\begin_layout Plain Layout

1;
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
1;

\family default
 
\emph on
at the end of the module
\emph default
 is important as it prevents eval from failing in Perl.
 
\end_layout

\begin_layout Chapter
Setup
\begin_inset CommandInset label
LatexCommand label
name "chap:Setup"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
http://www.perlmonks.org/?node_id=128077
\end_layout

\begin_layout Plain Layout
==
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This has been retained,
 but also read the start of 
\emph on
small_time_400.lyx
\emph default
.
 The following is all done there,
 so rather follow those instructions,
 and regard all of this chapter as an FYI.
 
\end_layout

\begin_layout Enumerate
Make the following subdirectories in your current directory (e.g.
 within 
\emph on
/w/seekwell/
\emph default
 or 
\emph on
~/smalltime/
\emph default
 )
\end_layout

\begin_deeper
\begin_layout Enumerate
seek
\end_layout

\begin_layout Enumerate
perl
\end_layout

\begin_layout Enumerate
perl/lib
\end_layout

\begin_layout Enumerate
perl/log 
\end_layout

\begin_layout Enumerate
perl/tz
\end_layout

\begin_layout Enumerate
perl/csv
\end_layout

\end_deeper
\begin_layout Enumerate
Install a LAMP,
 WAMP or MAMP stack,
 and then install 
\series bold
\emph on
f
\emph default
ehr
\series default
.
 Although Timely depends on just a few 
\series bold
\emph on
f
\emph default
ehr
\series default
 tables (
\series bold
leapseconds
\series default
,
 
\series bold
timely
\series default
,
 
\series bold
PLACES
\series default
,
 
\series bold
countrycodes
\series default
,
 
\series bold
SKEYS
\series default
 and the tables they in turn depend on—

\series bold
PEOPLE
\series default
,
 
\series bold
SOURCES
\series default
,
 and thence 
\series bold
Sourcescripts
\series default
 and 
\series bold
Institutions
\series default
) it's smart to install the the whole schema.
 
\end_layout

\begin_layout Enumerate
From the command line,
 open MySQL (mysql -u root -p followed by enter and password) and use fehr;
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Ensure that 
\emph on
empty
\emph default
 
\series bold
leapseconds
\series default
 and 
\series bold
timely
\series default
 tables are present.
 They look like this:
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger dogsAllowed=`no'
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

CREATE TABLE leapseconds
\end_layout

\begin_layout Plain Layout

( leapsecond int 
\end_layout

\begin_layout Plain Layout

    ,constraint leapkey PRIMARY KEY (leapsecond) 
\end_layout

\begin_layout Plain Layout

  ,gpstime BIGINT
\end_layout

\begin_layout Plain Layout

  ,utctime BIGINT
\end_layout

\begin_layout Plain Layout

  ,toffset int -- baseline is -9
\end_layout

\begin_layout Plain Layout

  ,ver integer default 0
\end_layout

\begin_layout Plain Layout

  ,chk int
\end_layout

\begin_layout Plain Layout

)CHARACTER SET=utf8mb4 
\end_layout

\begin_layout Plain Layout

    COLLATE=utf8mb4_unicode_ci;SHOW WARNINGS;DESCRIBE leapseconds;
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and:
 
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger dogsAllowed=`no'
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

CREATE TABLE timely
\end_layout

\begin_layout Plain Layout

( timekey integer 
\end_layout

\begin_layout Plain Layout

    ,
 constraint timely_pk PRIMARY KEY(timekey)
\end_layout

\begin_layout Plain Layout

  ,region BIGINT
\end_layout

\begin_layout Plain Layout

    ,constraint timely_region_fk FOREIGN KEY (region)
\end_layout

\begin_layout Plain Layout

      references PLACES(place)
\end_layout

\begin_layout Plain Layout

  ,
 year integer
\end_layout

\begin_layout Plain Layout

  ,
 transition BIGINT
\end_layout

\begin_layout Plain Layout

  ,
 zone_offset BIGINT
\end_layout

\begin_layout Plain Layout

  ,
 dst BIGINT
\end_layout

\begin_layout Plain Layout

  ,
 ignored integer default 0
\end_layout

\begin_layout Plain Layout

  ,
 ver integer default 0
\end_layout

\begin_layout Plain Layout

  ,
 chk int
\end_layout

\begin_layout Plain Layout

)CHARACTER SET=utf8mb4 
\end_layout

\begin_layout Plain Layout

    COLLATE=utf8mb4_unicode_ci;SHOW WARNINGS;DESCRIBE timely;
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Other tables that will be used by Timely are mentioned above.
 For creation code,
 see 
\emph on
fehr_sql_400.lyx
\emph default
.
 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:Update-the-countrycodes"

\end_inset

Update the countrycodes table to include a 'UT' code (for universal time),
 if not already present:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger dogsAllowed=`no'
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

INSERT INTO countrycodes (country,
 ccode,
 tla) VALUES (1,
 'UT',
 'UTC');
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
\emph on
Create
\series default
\emph default
 the following ancillary rule tables in 
\series bold
\emph on
f
\emph default
ehr
\series default
.
 There is minimal processing,
 and the tables are denormalized with respect to rule_name.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
rule sets:
 
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger dogsAllowed=`no'
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

CREATE TABLE tz_rules
\end_layout

\begin_layout Plain Layout

( tz_rule integer
\end_layout

\begin_layout Plain Layout

  ,rule_name varchar(16)
\end_layout

\begin_layout Plain Layout

  ,from_year varchar(8)
\end_layout

\begin_layout Plain Layout

  ,to_year varchar(8)
\end_layout

\begin_layout Plain Layout

  ,in_on_at varchar(64)
\end_layout

\begin_layout Plain Layout

  ,dst varchar(8)
\end_layout

\begin_layout Plain Layout

  ,is_active integer default 1
\end_layout

\begin_layout Plain Layout

)CHARACTER SET=utf8mb4 
\end_layout

\begin_layout Plain Layout

    COLLATE=utf8mb4_unicode_ci;SHOW WARNINGS;DESCRIBE tz_rules;
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
zone cutoff rules
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger dogsAllowed=`no'
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

CREATE TABLE tz_cutoffs
\end_layout

\begin_layout Plain Layout

( tz_cutoff integer
\end_layout

\begin_layout Plain Layout

  ,stdoff varchar(16)
\end_layout

\begin_layout Plain Layout

  ,rule_name varchar(16)
\end_layout

\begin_layout Plain Layout

  ,region BIGINT
\end_layout

\begin_layout Plain Layout

    ,constraint tz_cutoffs_region FOREIGN KEY (region)
\end_layout

\begin_layout Plain Layout

      references PLACES(place)
\end_layout

\begin_layout Plain Layout

  ,until_text varchar(16)
\end_layout

\begin_layout Plain Layout

  ,is_active integer default 1
\end_layout

\begin_layout Plain Layout

)CHARACTER SET=utf8mb4 
\end_layout

\begin_layout Plain Layout

    COLLATE=utf8mb4_unicode_ci;SHOW WARNINGS;DESCRIBE tz_cutoffs;
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
To prevent duplicates and check,
 each rule row can be identified not just by the sequential,
 internal PK in tz_rule or tz_cutoff,
 but respectively by rule_name+from_year+to_year+in_on_at;
 and region+until_text.
 This allows us (at the start of any re-importation) to:
\end_layout

\begin_deeper
\begin_layout Enumerate
Reset all active values to 0
\end_layout

\begin_layout Enumerate
Re-activate all identified rows to 1
\end_layout

\begin_layout Enumerate
Add new rows,
 as needed,
 in either table.
 
\end_layout

\end_deeper
\begin_layout Enumerate
We also need source rows in 
\series bold
SKEYS
\series default
:
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% Dogwagger dogsAllowed=`no'
\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

INSERT INTO SKEYS (kName,
        kValue,
 klock) VALUES 
\end_layout

\begin_layout Plain Layout

                  ('tz_rules',
   1000,
   0),
\end_layout

\begin_layout Plain Layout

                  ('tz_cutoffs',
 1000,
   0);
 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Download the tz database (as a zip,
 from 
\begin_inset CommandInset href
LatexCommand href
name "https://www.iana.org/time-zones"
target "https://www.iana.org/time-zones"
literal "false"

\end_inset

) and unzip it in \SpecialChar ldots

\emph on
seekwell/perl/tz
\emph default
 ;
 the name will be along the lines of 
\emph on
tzdata2020d.tar.gz
\end_layout

\begin_deeper
\begin_layout Enumerate
Unzip the contained files (if under Windows,
 using an application like 7zip) and put them in 
\emph on
perl/tz
\emph default
 so that files like 
\emph on
africa
\emph default
 and 
\emph on
LICENCE
\emph default
 are immediately within this directory.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
To default extension-free files to Notepad,
 see https://superuser.com/questions/13653/how-to-set-the-default-program-for-opening-files-without-an-extension-in-windows
\end_layout

\begin_layout Plain Layout
==
\end_layout

\begin_layout Plain Layout
for %i in (notepad.exe) do @echo %~$PATH:i
\end_layout

\begin_layout Plain Layout
==
\end_layout

\begin_layout Plain Layout
C:
\backslash
Windows
\backslash
System32
\backslash
notepad.exe
\end_layout

\begin_layout Plain Layout
==
\end_layout

\begin_layout Plain Layout
GCC WINDOWS:
\end_layout

\begin_layout Plain Layout
https://dev.to/gamegods3/how-to-install-gcc-in-windows-10-the-easier-way-422j
\end_layout

\begin_layout Plain Layout
== [also look into MS Linux,
 now] cf.
 https://docs.microsoft.com/en-us/learn/modules/get-started-with-windows-subsystem-for-linux/
\end_layout

\begin_layout Plain Layout

\series bold
https://ubuntu.com/wsl
\end_layout

\begin_layout Plain Layout
==
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Turn the current file (
\emph on
timely_400.lyx
\emph default
) into a Perl package:
 
\end_layout

\begin_deeper
\begin_layout Enumerate
First export 
\emph on
seek_400.lyx
\emph default
 to 
\emph on
seek_400.tex
\emph default
 and 
\emph on
timely_400.lyx
\emph default
 to 
\emph on
timely_400.tex
\emph default
.
\end_layout

\end_deeper
\begin_layout Enumerate
Run Dogwagger over these TeX files.
 You can obtain Dogwagger from 
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/jvanschalkwyk/dogwagger"
target "https://github.com/jvanschalkwyk/dogwagger"
literal "false"

\end_inset

.
 In the containing directory say:
 
\end_layout

\begin_deeper
\begin_layout Quote

\family typewriter
perl Dogwagger405.pl timely_400.tex
\end_layout

\begin_layout Quote

\family typewriter
perl Dogwagger405.pl seek_400.tex
\end_layout

\begin_layout Enumerate
Once you've done this,
 the 
\emph on
make.bat
\emph default
 file should be produced,
 and henceforth under Windows you should be able to just say 
\family typewriter
make
\family default
 ;
 similarly use 
\family typewriter
bash make.sh
\family default
 under Linux.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Under Linux,
 you will need to install 
\end_layout

\begin_deeper
\begin_layout Enumerate
Term::Readkey
\end_layout

\begin_deeper
\begin_layout Quote

\family typewriter
sudo apt-get update 
\end_layout

\begin_layout Quote

\family typewriter
sudo apt-get install libterm-readkey-perl
\end_layout

\end_deeper
\begin_layout Enumerate
DBI —
 this may be slightly traumatic (See 
\begin_inset CommandInset href
LatexCommand href
name "https://dr-jo.medium.com/the-fourth-circle-a2831bbdf769"
target "https://dr-jo.medium.com/the-fourth-circle-a2831bbdf769"
literal "false"

\end_inset

).
 
\end_layout

\begin_deeper
\begin_layout Quote

\family typewriter
sudo apt-get install libdbi-perl
\end_layout

\begin_layout Quote

\family typewriter
sudo apt-get install libdbd-odbc-perl
\family default
 
\end_layout

\begin_layout Quote
To check your sources,
 run:
 
\family typewriter
odbcinst -j
\family default
 ,
 which will point you to eg 
\end_layout

\begin_deeper
\begin_layout Quote
/etc/odbc.ini,
 as well as 
\end_layout

\begin_layout Quote
/etc/ODBCDataSources and 
\end_layout

\begin_layout Quote
/home/<mynamehere>/.odbc.ini i.e.
 ~/.odbc.ini 
\end_layout

\end_deeper
\begin_layout Quote

\family typewriter
printenv ODBCSYSINI
\family default
 should show you this environment variable,
 which should point to 
\emph on
odbcinst.ini
\emph default
 ;
 similarly ODBCINI should refer to 
\emph on
odbc.ini
\emph default
 (or printenv | grep ODBCSYSINI ) 
\end_layout

\begin_deeper
\begin_layout Quote

\family typewriter
\series bold
export ODBCSYSINI='/home/jo'
\end_layout

\begin_layout Quote

\family typewriter
\series bold
export ODBCINSTINI='.odbcinst.ini'
\end_layout

\begin_layout Quote

\family typewriter
\series bold
export ODBCINI='/home/jo/.odbc.ini'
\end_layout

\end_deeper
\begin_layout Quote
odbcinst -q -d
\end_layout

\begin_layout Quote
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
cf.
 https://www.digitalocean.com/community/tutorials/how-to-read-and-set-environmental-and-shell-variables-on-linux
\end_layout

\begin_layout Plain Layout
env VAR1="value" command_to_run command_options
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

perl -e 'use DBI 1.643;'
\end_layout

\begin_layout Plain Layout

perl -e 'use DBD::ODBC;'
\end_layout

\begin_layout Plain Layout

perl -MDBD::ODBC -e 'print $DBD::ODBC::VERSION;'
\end_layout

\begin_layout Plain Layout

odbcinst --version
\end_layout

\begin_layout Plain Layout

odbcinst -j
\end_layout

\begin_layout Plain Layout

odbcinst -q -d 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

printenv ODBCSYSINI
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# AMAZONREDSHIFTODBCINI=/etc/amazon.redshiftodbc.ini
\end_layout

\begin_layout Plain Layout

#ODBCSYSINI=/usr/local/odbc
\end_layout

\begin_layout Plain Layout

#ODBCINI=/etc/odbc.ini
\end_layout

\begin_layout Plain Layout

#LD_LIBRARY_PATH=/usr/local/lib
\end_layout

\begin_layout Plain Layout

#LD_PRELOAD=/usr/local/lib/libodbcinst.so
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#export ODBCSYSINI="<full path to user folder,
 which would be the evaluated path of {echo ~}>"
\end_layout

\begin_layout Plain Layout

#export ODBCINSTINI=".odbcinst.ini"
\end_layout

\begin_layout Plain Layout

#export ODBCINI="<full path to user folder,
 which would be the evaluated path of {echo ~}>/.odbc.ini"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

export ODBCSYSINI='/home/jo' # [?
 no terminal /' ]
\end_layout

\begin_layout Plain Layout

export ODBCINSTINI='.odbcinst.ini'
\end_layout

\begin_layout Plain Layout

export ODBCINI='/home/jo/.odbc.ini'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

*not* :
\end_layout

\begin_layout Plain Layout

ODBCSYSINI='/etc/odbcinst.ini'
\end_layout

\begin_layout Plain Layout

export ODBCSYSINI
\end_layout

\begin_layout Plain Layout

ODBCINI='/etc/odbc.ini'
\end_layout

\begin_layout Plain Layout

export ODBCINI
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
DateTime 
\end_layout

\begin_deeper
\begin_layout Quote

\family typewriter
sudo apt-get install libdatetime-perl
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:You-can-obtain"

\end_inset

You can obtain the DateTime version (which is important) by saying:
\end_layout

\begin_deeper
\begin_layout Quote

\family typewriter
perl -M"DateTime 9999" 
\end_layout

\begin_layout Quote
This should be compared with the most recent version available (that should correspond to the most recent version of tz available from IANA (
\begin_inset CommandInset href
LatexCommand href
name "https://www.iana.org/time-zones"
target "https://www.iana.org/time-zones"
literal "false"

\end_inset

).
 Note however that this will be something like 2021a;
 the corresponding DateTime version should be on CPAN (
\begin_inset CommandInset href
LatexCommand href
name "https://metacpan.org/pod/DateTime"
target "https://metacpan.org/pod/DateTime"
literal "false"

\end_inset

) but this may lag.
 In the above example,
 the date for v
\begin_inset space ~
\end_inset

1.54 is 2020-12-04,
 so this won't contain the first 2021 tz update.
 As your perl DateTime version diverges,
 the error count in timely will rise.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Move to e.g.
 
\emph on
/fehr/seekwell/perl
\emph default
 and run 
\end_layout

\begin_deeper
\begin_layout Quote

\family typewriter
\series bold
perl seek.pl
\family default
\series default

\begin_inset Note Note
status collapsed

\begin_layout Enumerate

\emph on
seek_125.pl
\emph default
.
 Let Perl know where the .pm package is:
\end_layout

\begin_deeper
\begin_layout Quote

\family typewriter
perl -Ilib/ seek_125.pl
\end_layout

\begin_layout Enumerate
The -I (capital I) should see the timely.pm module in the perl directory.
\end_layout

\begin_layout Enumerate
If you're not in the perl subdirectory,
 then the script won't see 
\emph on
csv
\emph default
 etc.
 (and you may have other trouble too)
\end_layout

\end_deeper
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
To uninstall phpmyadmin
\end_layout

\begin_layout Plain Layout
sudo apt-get remove phpmyadmin
\end_layout

\begin_layout Plain Layout
sudo apt-get purge phpmyadmin
\end_layout

\begin_layout Plain Layout
sudo apt-get autoremove
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Section
Notes [exploration]
\end_layout

\begin_layout Plain Layout
When you open localhost/phpmyadmin in your browser,
 if it doesn't have privileges,
 then open MySQL at the command line and say:
\end_layout

\begin_layout Quote

\family typewriter
\series bold
grant all privileges on * .
 * to 'phpmyadmin@localhost';
\end_layout

\begin_layout Quote

\family typewriter
\series bold
show grants for 'phpmyadmin@localhost';
\end_layout

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Plain Layout
Exit and re-open phpMyAdmin.
 Create a user specific for access to MySQL,
 e.g.
 fehr_user :
 Click on the User Accounts tab.
 If you get the unfortunate:
\end_layout

\begin_layout Quote
You do not have privileges to manipulate with the users!
\end_layout

\begin_layout Plain Layout
\SpecialChar ldots
message,
 then you likely need to find and alter 
\emph on
config.inc.php
\emph default
 in 
\emph on
etc/phpmyadmin/
\emph default
 The magic line:
\end_layout

\begin_layout Quote
$cfg['Servers'][$i]['DisableIS'] = true;
\end_layout

\begin_layout Quote
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://dba.stackexchange.com/questions/210786/you-do-not-have-privileges-to-manipulate-with-the-users
\end_layout

\begin_layout Plain Layout
https://superuser.com/questions/143734/how-can-phpmyadmin-be-restarted-after-etc-phpmyadmin-config-inc-php-is-changed
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

The same issue with me.
 It seems that Ubuntu ignores /etc/phpmyadmin/config.inc.php but loads /usr/share/phpmyadmin/config.inc.php.
 Uncomment "Storage database and tables" section and "Designer" mode will be enabled
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Plain Layout
The process:
\end_layout

\begin_layout Enumerate
Add the user name 
\family typewriter
fehr_user
\family default
 ;
\end_layout

\begin_layout Enumerate
Host name is 
\family typewriter
localhost
\family default
 ;
\end_layout

\begin_layout Enumerate
Add a difficult-to-guess password ;
\end_layout

\begin_layout Enumerate
Click [Go]
\end_layout

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Plain Layout
What about this then?
 If you get 
\begin_inset Quotes eld
\end_inset

your password does not satisfy the current policy requirements
\begin_inset Quotes erd
\end_inset

 !!
 Do as follows:
\end_layout

\begin_layout Enumerate
From command line,
 run mysql;
\end_layout

\begin_layout Enumerate
Say:
 
\family typewriter
UNINSTALL COMPONENT "file://component_validate_password";
\end_layout

\begin_layout Enumerate
Try again in phpMyAdmin as above:
 create 
\family typewriter
fehr_user
\end_layout

\begin_layout Enumerate
Then in mysql say:
 INSTALL COMPONENT "file://component_validate_password";
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[explore this] [FUCK!]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Continuing in the Edit Privileges for the new user:
\end_layout

\begin_layout Enumerate
Choose the fehr database,
 click [Go]
\end_layout

\begin_layout Enumerate
Limit the selection of privileges to:
\end_layout

\begin_deeper
\begin_layout Enumerate
Select
\end_layout

\begin_layout Enumerate
Insert
\end_layout

\begin_layout Enumerate
Update
\end_layout

\begin_layout Enumerate
Delete
\end_layout

\end_deeper
\begin_layout Enumerate
Click [Go]
\end_layout

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following additional packages will be installed:
\end_layout

\begin_layout Plain Layout
dbconfig-common dbconfig-mysql icc-profiles-free libjs-openlayers libonig5 libzip5 php-bz2
\end_layout

\begin_layout Plain Layout
php-curl php-gd php-google-recaptcha php-mbstring php-phpmyadmin-motranslator
\end_layout

\begin_layout Plain Layout
php-phpmyadmin-shapefile php-phpmyadmin-sql-parser php-phpseclib php-psr-cache
\end_layout

\begin_layout Plain Layout
php-psr-container php-psr-log php-symfony-cache php-symfony-cache-contracts
\end_layout

\begin_layout Plain Layout
php-symfony-expression-language php-symfony-service-contracts php-symfony-var-exporter
\end_layout

\begin_layout Plain Layout
php-tcpdf php-twig php-twig-extensions php-xml php-zip php7.4-bz2 php7.4-curl php7.4-gd
\end_layout

\begin_layout Plain Layout
php7.4-mbstring php7.4-xml php7.4-zip
\end_layout

\begin_layout Plain Layout
Suggested packages:
\end_layout

\begin_layout Plain Layout
php-dbase php-libsodium php-mcrypt php-gmp php-symfony-service-implementation php-imagick
\end_layout

\begin_layout Plain Layout
php-twig-doc php-symfony-translation php-recode php-gd2 php-pragmarx-google2fa
\end_layout

\begin_layout Plain Layout
php-bacon-qr-code php-samyoul-u2f-php-server
\end_layout

\begin_layout Plain Layout
Recommended packages:
\end_layout

\begin_layout Plain Layout
php-mcrypt
\end_layout

\begin_layout Plain Layout
The following NEW packages will be installed:
\end_layout

\begin_layout Plain Layout
dbconfig-common dbconfig-mysql icc-profiles-free libjs-openlayers libonig5 libzip5 php-bz2
\end_layout

\begin_layout Plain Layout
php-curl php-gd php-google-recaptcha php-mbstring php-phpmyadmin-motranslator
\end_layout

\begin_layout Plain Layout
php-phpmyadmin-shapefile php-phpmyadmin-sql-parser php-phpseclib php-psr-cache
\end_layout

\begin_layout Plain Layout
php-psr-container php-psr-log php-symfony-cache php-symfony-cache-contracts
\end_layout

\begin_layout Plain Layout
php-symfony-expression-language php-symfony-service-contracts php-symfony-var-exporter
\end_layout

\begin_layout Plain Layout
php-tcpdf php-twig php-twig-extensions php-xml php-zip php7.4-bz2 php7.4-curl php7.4-gd
\end_layout

\begin_layout Plain Layout
php7.4-mbstring php7.4-xml php7.4-zip phpmyadmin
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Oops,
 what if phpMyAdmin fails on this?
 Again in mysql on the command line:
\end_layout

\begin_layout Quote

\family typewriter
grant all on *.* to 'phpmyadmin@localhost';
\end_layout

\begin_layout Quote

\family typewriter
flush privileges;
\end_layout

\begin_layout Plain Layout
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Plain Layout
GRANT ALL PRIVILEGES ON *.* TO 'phpmyadmin'@'localhost' WITH GRANT OPTION;
\end_layout

\begin_layout Plain Layout
==
\end_layout

\begin_layout Plain Layout
sudo apt-get remove --purge mysql*
\end_layout

\begin_layout Plain Layout
sudo apt-get purge mysql*
\end_layout

\begin_layout Plain Layout
sudo apt-get autoremove.
\end_layout

\begin_layout Plain Layout
sudo apt-get autoclean.
\end_layout

\begin_layout Plain Layout
sudo apt-get remove dbconfig-mysql
\end_layout

\begin_layout Plain Layout
==
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://dba.stackexchange.com/questions/16397/cannot-grant-privileges-as-root
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
REINSTALL:
\end_layout

\begin_layout Plain Layout
sudo apt-get update
\end_layout

\begin_layout Plain Layout
sudo apt-get install mysql-server
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
[NB.
 Here too I found weird shit.
\end_layout

\begin_layout Plain Layout
https://github.com/phpmyadmin/phpmyadmin/issues/14433
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
desc mysql.user;
\end_layout

\begin_layout Plain Layout
SELECT GROUP_CONCAT(concat(' ',
 column_name,
 '=
\backslash
'Y
\backslash
'')) FROM information_schema.columns WHERE table_schema = 'mysql' AND table_name = 'user' AND column_name LIKE '%_priv' ;
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

Select_priv='Y',
 Insert_priv='Y',
 Update_priv='Y',
 Delete_priv='Y',
 Create_priv='Y',
 Drop_priv='Y',
 Reload_priv='Y',
 Shutdown_priv='Y',
 Process_priv='Y',
 File_priv='Y',
 Grant_priv='Y',
 References_priv='Y',
 Index_priv='Y',
 Alter_priv='Y',
 Show_db_priv='Y',
 Super_priv='Y',
 Create_tmp_table_priv='Y',
 Lock_tables_priv='Y',
 Execute_priv='Y',
 Repl_slave_priv='Y',
 Repl_client_priv='Y',
 Create_view_priv='Y',
 Show_view_priv='Y',
 Create_routine_priv='Y',
 Alter_routine_priv='Y',
 Create_user_priv='Y',
 Event_priv='Y',
 Trigger_priv='Y',
 Create_tablespace_priv='Y',
 Create_role_priv='Y',
 Drop_role_priv='Y'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
== then don't need the messy:
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Select_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Insert_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Update_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Delete_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Create_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Drop_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Reload_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Shutdown_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Process_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET File_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Grant_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET References_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Index_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Alter_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Show_db_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Super_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Create_tmp_table_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Lock_tables_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Execute_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Repl_slave_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Repl_client_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Create_view_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Show_view_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Create_routine_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Alter_routine_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Create_user_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Event_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Trigger_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Create_tablespace_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Create_role_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\begin_layout Plain Layout
UPDATE mysql.user SET Drop_role_priv = 'Y' WHERE user = 'root' AND host = 'localhost';
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Subsubsection
Setup an admin
\end_layout

\begin_layout Plain Layout
Must first create admin phpmyadmin@localhost.
 Then in cmd line:
\end_layout

\begin_layout Plain Layout
GRANT ALL ON fehr.* TO 'phpmyadmin@localhost';
\end_layout

\begin_layout Plain Layout
==
\end_layout

\begin_layout Plain Layout
CREATE USER 'newuser'@'localhost' IDENTIFIED BY 'password';
\end_layout

\begin_layout Plain Layout
== flushing privileges:
\end_layout

\begin_layout Plain Layout
https://askubuntu.com/questions/820967/access-denied-for-user-phpmyadminlocalhost-while-installing-phpmyadmin
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
drop user 'phpmyadmin'@'localhost';
\end_layout

\begin_layout Plain Layout
create user 'phpmyadmin'@'localhost' identified by '0mniraptor';
\end_layout

\begin_layout Plain Layout
GRANT ALL PRIVILEGES ON *.* TO 'phpmyadmin'@'localhost' WITH GRANT OPTION;
\end_layout

\begin_layout Plain Layout
FLUSH PRIVILEGES;
\end_layout

\begin_layout Plain Layout
==
\end_layout

\begin_layout Plain Layout
== phpmyadmin still can't grant:
\end_layout

\begin_layout Plain Layout
GRANT SELECT,
 INSERT,
 UPDATE,
 DELETE ON *.* TO 'test_user'@'localhost';
 NB.
 phpmyadmin adds REQUIRE NONE 
\emph on
which fails!
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
What about:
\end_layout

\begin_layout Plain Layout
ALTER USER 'phpmyadmin' IDENTIFIED WITH mysql_native_password BY 'PASSWORD';
\end_layout

\begin_layout Plain Layout

\series bold
https://stackoverflow.com/questions/49948350/phpmyadmin-on-mysql-8-0
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
phpMyAdmin version?
 Click on home icon,
 look on right e.g.
 4.9.5deb2
\end_layout

\begin_layout Plain Layout
https://askubuntu.com/questions/947805/how-to-upgrade-phpmyadmin-revisited
\end_layout

\begin_layout Plain Layout
==
\end_layout

\begin_layout Plain Layout
TRY THIS:
\end_layout

\begin_layout Plain Layout

\size huge
https://tecadmin.net/manually-upgrade-phpmyadmin-ubuntu/
\end_layout

\begin_layout Enumerate
First,
 backup:
\end_layout

\begin_deeper
\begin_layout Enumerate
sudo mv /usr/share/phpmyadmin/ /usr/share/phpmyadmin.bak
\end_layout

\end_deeper
\begin_layout Enumerate
Get latest:
\end_layout

\begin_deeper
\begin_layout Enumerate
mkdir ~/INSTALL
\end_layout

\begin_layout Enumerate
cd ~/INSTALL
\end_layout

\begin_layout Enumerate
wget www.phpmyadmin.net/downloads/phpMyAdmin-latest-all-languages.zip
\end_layout

\begin_layout Enumerate
unzip phpMyAdmin-latest-all-languages.zip
\end_layout

\end_deeper
\begin_layout Enumerate
Move out:
\end_layout

\begin_deeper
\begin_layout Enumerate
sudo mkdir /usr/share/phpmyadmin
\end_layout

\begin_layout Enumerate
sudo mv phpMyAdmin-*/* /usr/share/phpmyadmin/
\end_layout

\end_deeper
\begin_layout Enumerate
Update config:
 
\family typewriter
sudo nano /usr/share/phpmyadmin/libraries/vendor_config.php
\family default
 and make the following changes:
\end_layout

\begin_deeper
\begin_layout Quote
define('TEMP_DIR',
 '/var/lib/phpmyadmin/tmp/');
\end_layout

\begin_layout Quote
define('CONFIG_DIR',
 '/etc/phpmyadmin/');
\end_layout

\end_deeper
\begin_layout Enumerate
Done!
\end_layout

\begin_layout Subsubsection
Other
\end_layout

\begin_layout Plain Layout
s
\family typewriter
udo apt install unixodbc
\end_layout

\begin_layout Plain Layout
This installs isql
\end_layout

\begin_layout Plain Layout
ENVIRONMENT VARIABLES:
 http://manpages.ubuntu.com/manpages/cosmic/man7/unixODBC.7.html
\end_layout

\begin_layout Plain Layout
Try
\end_layout

\begin_layout Quote

\family typewriter
printenv ODBCSYSINI
\end_layout

\begin_layout Plain Layout
export ODBCSYSINI
\end_layout

\begin_layout Plain Layout
ODBCINSTINI
\end_layout

\begin_layout Plain Layout
ODBCINSTUI
\end_layout

\begin_layout Plain Layout
ODBCSEARCH
\end_layout

\begin_layout Plain Layout
ODBCINI
\end_layout

\begin_layout Quote

\family typewriter
\series bold
export ODBCSYSINI='/home/jo'
\end_layout

\begin_layout Quote

\family typewriter
\series bold
export ODBCINSTINI='.odbcinst.ini'
\end_layout

\begin_layout Quote

\family typewriter
\series bold
export ODBCINI='/home/jo/.odbc.ini'
\end_layout

\begin_layout Quote
export ODBCSEARCH='ODBC_USER_DSN' 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[is this needed?
 is it right]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
ODBCSYSINI
\end_layout

\begin_layout Plain Layout
Overloads path to unixODBC configuration files.
 By default equals to '/etc'.
\end_layout

\begin_layout Plain Layout
ODBCINSTINI
\end_layout

\begin_layout Plain Layout
Overloads the name of the drivers configuration file.
 It is relative to ODBCSYSINI
\end_layout

\begin_layout Plain Layout
and by default set to 'odbcinst.ini'.
\end_layout

\begin_layout Plain Layout

\series bold
ODBCINSTUI
\end_layout

\begin_layout Plain Layout
Overloads the library name for UI.
 The final name that is searched for is evaluated
\end_layout

\begin_layout Plain Layout
as "lib$ODBCINSTUI".
 By default it is set to 'odbcinstQ4',
 so the resulting library
\end_layout

\begin_layout Plain Layout
name is 'libodbcinstQ4'.
\end_layout

\begin_layout Plain Layout
ODBCSEARCH
\end_layout

\begin_layout Plain Layout
Overloads the configuration mode and determines where to look for configuration
\end_layout

\begin_layout Plain Layout
files.
 Must be set to one of ODBC_SYSTEM_DSN,
 ODBC_USER_DSN or ODBC_BOTH_DSN (the
\end_layout

\begin_layout Plain Layout
last one is the default value).
\end_layout

\begin_layout Plain Layout
ODBCINI
\end_layout

\begin_layout Plain Layout
Overloads the path to user configuration file.
 By default it is set to
\end_layout

\begin_layout Plain Layout
"~/.odbc.ini".
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset Quotes eld
\end_inset

Design features
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Some readers will be disturbed by:
\end_layout

\begin_layout Itemize
My tendency not to use standard `code-shop' indentation of braces;
\end_layout

\begin_layout Itemize
Globals like 
\family typewriter
$DB_MAIN
\family default
.
 You might argue that this should be tossed around as a parameter rather than the approach taken—
to instantiate 
\family typewriter
$handDB
\family default
 locally from the global,
 as needed close to use of SQL primitives that applies just to this database.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
This is the only apology you'll get—
and it's not much of an apology.
 These are deliberate;
 all of the other design flaws are made from sheer ignorance.
 
\end_layout

\begin_layout Section
Residual issues
\end_layout

\begin_layout Enumerate
Perl automagically converts integers over about 
\begin_inset Formula $2^{54}$
\end_inset

 to floats (actually,
 they're all floats,
 it just doesn't show well),
 and this results in the best case in loss of precision.
 If the number is a primary key,
 effectively all is lost.
 Solutions exist,
 but 
\begin_inset CommandInset href
LatexCommand href
name "bignum"
target "https://perldoc.perl.org/bignum"
literal "false"

\end_inset

 (bigint + bigfloat) has a number of side effects,
 including slower processing.
 If you try simply to use bigint,
 then all floats are coerced to integers,
 which may not be,
 shall we say,
 highly desirable.
 PK big integers should thus be represented as strings,
 and kept as strings.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[explore implications] 
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
It will be wise to timestamp t_start and t_amended within the two tz_* tables in 
\series bold
\emph on
f
\emph default
ehr
\series default
.
 I haven't yet done this.
 
\end_layout

\begin_layout Enumerate
Small things,
 cf:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

# no GPS adjust  so $DST is a redundant variable [fix me]
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Section
Change log v2
\end_layout

\begin_layout Enumerate
Version 2.0.1 (2,000,001):
\end_layout

\begin_deeper
\begin_layout Enumerate
It's important to document the requirement for a UT entry in countrycodes.
 See point 4 at the start of Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Setup"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

,
 page
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "enu:Update-the-countrycodes"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

.
 
\end_layout

\begin_layout Enumerate
It's similarly important (Page
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "enu:You-can-obtain"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

) to document the current DateTime version and if possible update this.
 Doing this under Windows,
 where ActivePerl at least lags conspicuously,
 may not be easy.
 
\end_layout

\begin_layout Enumerate
On testing under Windows 7,
 Z and DST values were initially reported with decimal fractions [explore] 
\end_layout

\begin_layout Enumerate
IT WILL BE WISE to have creation/update times not only in tz_ files but even in timely [explore] 
\end_layout

\begin_layout Enumerate
Have note on how to upgrade DateTime where you can (mainly,
 Linux).
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Also note crash:
 **Execution trapped (debugging)The timezone 'America/Nuuk' could not be loaded,
 or is an invalid name.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
On 2021-03-07 made CheckOS
\begin_inset space ~
\end_inset

() public.
 
\end_layout

\begin_layout Enumerate
On 2021-03-14 added soft option to TooBig
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Perl-big-issues-Toobig"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

).
 
\end_layout

\begin_layout Enumerate
On 2022-02-07 modified XPrint
\begin_inset space ~
\end_inset

() to prevent attempt to write to log once handle is closed.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
[hmm] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Section
Change log v4
\end_layout

\begin_layout Standard
Enormous:
 moved out huge parts.
 See 
\emph on
small_time_400.lyx
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
==
\end_layout

\begin_layout Plain Layout
== END OF THE MAIN SECTION ==
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\start_of_appendix
\begin_inset ERT
status open

\begin_layout Plain Layout

% this is the appendix.
\end_layout

\end_inset


\end_layout

\end_body
\end_document
