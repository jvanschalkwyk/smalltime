#  Generated by LaTeX DogWagger Version 4.0.5 from file <timely_400.tex>
#  Date: [2026-1-31 14:42:15] 
#  Do NOT edit this file. Edit the LaTeX source!!

#  - <Section 1> - 
#!/usr/local/bin/perl -w
package Timely;
use strict;
use warnings; 

use feature 'unicode_strings';    # UTF-8 usage
use utf8;                         #
use open ':encoding(utf8)';       #
binmode(STDOUT, ":utf8");         # 

#  - <Section 2> - 
use Exporter qw(import);

our $VERSION = 4000000;          # 4.0.0 e.g. 1024000=1.24.0
our @ISA = qw(Exporter);
our @EXPORT = qw( BeginTimely ); 
our @EXPORT_OK = qw( GetSQL DoSQL SQLManySQL AppendSQLConstraint ClearSQLConstraint 
  FindRegion SetRegion Timely GetLocalTime Julian Gregorian 
  FormatDate QuickJ2G GetUtcCode SetUtcCode ExGps FetchTzDate 
  GetNewWarnings Eek TooBig SetOffender SetMaxKeyFetch ClearWarnings 
  EndTimely SetUserId SetTzDatabase SetParsingScript  
  XPrint Warn ListWarnings FetchManyKeys ErrorThresholdGet SetErrorThreshold 
  SetWarnMax CheckOS GpsJulian InternalJulian ModTimeNow JulianFromUnix 
  Greg J2G Padding FetchKey ToJulian ApplyGps HugeToJ FullGregorian PrettyDate G2J 
  ); 
  # ^ DO NOT put comment in qw list. Note Padding() is a bit niche. 

## WE CURRENTLY DO *not* export the following but they are still accessible using Timely::
## ValidatePath() SetFehrOdbc()FetchLeapData() BigApplyGps() 
## BumpNewWarnings() LogError() Converter() DoubleDigit() Lead() 
## Greg() ClipFractionalSeconds() Anomalous() Signum() Biggen() JulianDay() 
  

#  - <Section 3> - 
use Time::HiRes qw(gettimeofday usleep);  # high-resolution timing 
use POSIX qw(floor); 
use Term::ReadKey;  # only used to interrupt long loops by pressing Esc
              # 
  ReadMode 1; # normal read mode. [should this be in invoker?] 

use DateTime; # this may give trouble if you're behind a corporate firewall
              # For Windows DateTime version:  perl -M"DateTime 9999" 
              # 

#  - <Section 4> - 
use constant HUGE_INT => 999999999999999;      # if GT, has exponent in Perl
use constant HUGE_NEGATIVE_INT => -(HUGE_INT); # similarly...
use constant EPSILONSECONDS => 0.010;     # [clumsy] 
use constant  PART_EMPTY => '__';  # 
  
my $TICK  = "âœ”"; # or '_/' if no Utf8. 
my $FETCHTIMEOUT = 2;           # seconds
my $TOPCOUNTRY = 999;           # max in PLACES table. *DO NOT* fiddle! 
                                # don't make it a constant (interpolated).

#  - <Section 5> - 
my $SQLCONSTRAINT = ''; 
my $LOGFILE;
my $ERRORFILE; 

my @WARNMAX =   (200, 500, 1000, 10000); # maximum warnings displayed in each category 
my @WARNCOUNT = (  0,   0,    0,     0); # actual number of warnings recorded for this run.
my $NEWWARNINGS = 0;                     # new warnings during recent stmt execution 
my $ERRORTHRESHOLD = 8;                  # &XPrint_() logs statements if < threshold
my $OFFENDING_LINE;
my $MAXIMUM_KEY_FETCH = 5000000;         # can fetch 5M keys at a time (limit)

my $DB_MAIN;                             # THE HANDLE OF THE MAIN (normally, fehr) DATABASE 
my $TZDATABASE;                          # a source (src, SOURCES table) ID used in src fields. 
my $USERID;                              # MAIN SYSTEM 'superuser'
my $UTCCODE;                             # 'Global' code (to fill in)

my $SQLOK = 0;                           #

my $USE_DBI;                             # if 1, then are using DBI:: and not Win32::ODBC.
my $MY_DBI_HANDLE;                       # undefined, initially  
my $PARSING_SCRIPT = '';                 # Identifies script currently being parsed. 

#  - <Section 6> - 
## internal storage for Timely rows relevant to current zone choice:
my $MYTIMELY; 
my $MYZONE = 0;          #
my @LEAPDATA;            # Stores leap second transitions. 

#  - <Section 7> - 
sub BeginTimely #
{ my($dbh, $usedbi) = @_; 

  &SetFehrOdbc($dbh, $usedbi); 
  # $LOGFILE, $ERRORFILE are globals in this module

if (! &ValidatePath('log'))
   { die "Directory 'log' does not exist";
   }; 
  my($tim) = ' ' . localtime; # NB leading space (scalar context). 
  $tim =~ s/[\s:]/_/mg; 
  my($logfile) = "log/EDLOG$tim.txt"; ## [might wish to remove spaces?] 
open ($LOGFILE, ">$logfile") or die
     "*CRASH* Could not open LOG $logfile :$!\n";

  my($errfile) = "log/ERRORS.txt";  # must *append* not overwrite!
open ($ERRORFILE, ">>$errfile") or die
     "*CRASH* Couldn't open ERROR file $errfile :$!\n";
  ClearSQLConstraint(); 
  @LEAPDATA = &FetchLeapData();
  return(@LEAPDATA); ## hmm, check this 
} 

#  - <Section 8> - 
sub SetUtcCode
{ my($utc) = @_;  
  $UTCCODE = $utc; 
}

#  - <Section 9> - 
sub FetchLeapData
{ 
  my($handDB) = $DB_MAIN;  

  my($q) = "SELECT gpstime, utctime, toffset FROM leapseconds " 
   . "order by leapsecond DESC";  # topmost is first
  my(@LEAPS) = &SQLManySQL($handDB, $q, 'get leap data');
  return(@LEAPS);
}

#  - <Section 10> - 
sub SetFehrOdbc #
{ my($dbh, $usedbi) = @_; 
  $DB_MAIN = $dbh; 
  $USE_DBI = $usedbi; 
} 

#  - <Section 11> - 
sub SetParsingScript #
{ my($b) = @_; 
  $PARSING_SCRIPT = $b; 
} 

#  - <Section 12> - 
sub SetMaxKeyFetch #
{ my($i) = @_; 
  $MAXIMUM_KEY_FETCH = $i; 
} 

#  - <Section 13> - 
sub SetUserId #
{ my($i) = @_; 
  $USERID = $i; 
} 

#  - <Section 14> - 
sub SetTzDatabase #
{ my($i) = @_; 
  $TZDATABASE = $i; 
} 

#  - <Section 15> - 
sub EndTimely #
{
  close $LOGFILE;
  close $ERRORFILE;
} 

#  - <Section 16> - 
sub CheckOS # 
{ my $Os = 'Unknown' ;

if($^O =~ /darwin/i)
  { $Os = 'Mac';
  }
elsif($^O =~ /linux/i)
  { $Os = 'Linux';
  }
elsif($^O =~ /win/i)
  { $Os = 'Windows';
  }; 

  return($Os);
} 

#  - <Section 17> - 
sub SetErrorThreshold #
{ my($i);
    ($i)=@_;
  $ERRORTHRESHOLD = $i; 
}

#  - <Section 18> - 
sub ErrorThresholdGet #
{ return($ERRORTHRESHOLD); 
}

#  - <Section 19> - 
sub SetOffender #
{ my($offal);
    ($offal)=@_;
  $OFFENDING_LINE = $offal; 
}

#  - <Section 20> - 
sub Eek #
{ my($msg, $prefix, $erk, $line);
    ($msg, $prefix, $erk, $line)=@_;
  my($ln) = '';

if(length $prefix > 0)
  { $prefix .= "\n  Warnings=" . join("\t",@WARNCOUNT) . "\n"  ; 
    $prefix .= "  at Perl source line $line "; 
  }; 
  my($out) = "$prefix$msg $ln\n";
if( (defined $OFFENDING_LINE) # SEE allocation
  &&(ref($OFFENDING_LINE) eq 'ARRAY')
  )
  { $out = "$out < @{$OFFENDING_LINE} >"; 
    undef($OFFENDING_LINE); # undefine so not used twice if caught!
  }; 
if(length $PARSING_SCRIPT > 0)
  { $out = "$out <bad script line near: '$PARSING_SCRIPT' >"; 
    $PARSING_SCRIPT = ''; # neat. 
  }; 
  &LogError($out); # 'permanent' record 

  # also helpful print, to accommodate debugging of EITHER [explore this]
if(  $erk 
  &&($ERRORTHRESHOLD > 10)
  ) # arbitrary choice of 10 [explore]
  { my($dud) = $out; 
    $dud =~ s/[\r\n]//mg; 
    ## &XPrint(0, "\n*   RECOVERY <$dud>");  # clumsy
  }; 

  ## &XPrint(0, $out); 
  die $out ;
}

#  - <Section 21> - 
sub Aagh #
{ my($msg, $line, $foo);
    ($msg, $line, $foo)=@_;
  
  &Eek($msg, '', $foo, $line); 
}

#  - <Section 22> - 
sub ValidatePath
{ my @pth;
  my $wholep = "";
 ($_) = @_;

  if ( /^\/(.*)$/ ) # if starting slash
     { $wholep = "/";
       $_ = $1;
     };
  @pth = split /\//;
#  print "\n Debug: path components @pth";

  my $p;
  foreach $p (@pth)
    { $wholep = "$wholep$p";
      if (! (-e $wholep) )
         { # print "\n Debug: bad path $wholep";
           return 0; # fail
         };
      $wholep = "$wholep/";
    };
  return 1;
} 

#  - <Section 23> - 
sub ModTimeNow
{ my($epochseconds, $microseconds);
  ($epochseconds, $microseconds) = gettimeofday;
  $epochseconds;     # use seconds for 32-bit system [?] 
}

#  - <Section 24> - 
sub Padding
{ my($ch, $n) = @_;
  return( $ch x int($n) ); # funny old Perl 
}

#  - <Section 25> - 
sub DoubleDigit # 
{ my($i) = @_;
  return(&Lead($i,2));
}

#  - <Section 26> - 
sub Lead #
{ my($i, $target) = @_;
while(length $i < $target)
  { $i = "0$i";
  };
  return($i); 
}

#  - <Section 27> - 
sub Sign # 
{ my($n) = @_;
if($n < 0)
  { return('-');
  };
  return('+'); 
}

#  - <Section 28> - 
sub Signum
{ my($n);
    ($n)=@_;
 return( $n <=> 0);
}

#  - <Section 29> - 
sub Biggen # 
{ my($n) = @_;
  return(  int( $n + EPSILONSECONDS*&Signum($n) )  ); 
}

#  - <Section 30> - 
sub TooBig #
{ my($n, $soft) = @_;
if($n < HUGE_INT && $n > HUGE_NEGATIVE_INT)
  { return($n); 
  };
if(! $soft)
  { &Warn(1, "Large integer $n. Likely precision loss"); 
  }; 
  return( int($n/1000) . '000' ); # [ugh]
}

#  - <Section 31> - 
sub Pad #
{ my($s, $L) = @_;
while(length $s < $L)
  { $s = "$s ";
  };
 return($s);
}

#  - <Section 32> - 
sub XPrint #
{ my($level, $msg) = @_;
if($level < $ERRORTHRESHOLD) # global test
  { print $msg;  # clumsy
  if($LOGFILE->opened())
    { print $LOGFILE $msg; # and keep a copy, will *fail* if no $LOGFILE [explore]
    } else 
    { print "  *** BUGGER handle is closed\n\n"; 
    }; 
  };
}

#  - <Section 33> - 
sub Warn #
{ my($level, $msg) = @_;
if($level > 3)
  { $level = 3;
  }; 
  &BumpNewWarnings($level); # short-term record first
  $WARNCOUNT[$level] ++; # bump warning count
  my($stars) = '*' x $level;  # Perl x operator
if($WARNCOUNT[$level] < $WARNMAX[$level]) # if not too many warnings: 
  {
    my($W) = 'WARNING';
  if($level == 0) # minor
    { $W = 'NOTE'; 
    };
    &XPrint(0, "\n  $stars $W $stars $msg"); # reactivated, 2021-03-12 
    return;
  } else
  { # still print to log file! [ 2021-03-13 ]
  if($level < $ERRORTHRESHOLD) # global test
    { print $LOGFILE "\n$stars $msg";
    }; 
  }; 
if($WARNCOUNT[$level] == $WARNMAX[$level])
  { &XPrint(0, "\n...suppressing level $level warnings ($WARNCOUNT[$level], too many)" );
  };
  # otherwise just ignore. 
}

#  - <Section 34> - 
sub SetWarnMax #
{ my($i, $K) = @_;
  
  $WARNMAX[$i] = $K; # might have sanity check on value [explore]
}

#  - <Section 35> - 
sub ListWarnings #
{ 
  # &XPrint(0, "\nWarning counts: \n -\t*\t**\t***\n " . join("\t",@WARNCOUNT) ); 
  return(@WARNCOUNT); 
}

#  - <Section 36> - 
sub ClearWarnings #
{ $NEWWARNINGS = 0; 
}

#  - <Section 37> - 
sub BumpNewWarnings #
{ my($level) = @_; # unused at present
  $NEWWARNINGS ++; 
}

#  - <Section 38> - 
sub GetNewWarnings #
{ return($NEWWARNINGS); 
}

#  - <Section 39> - 
sub Log #
{ my($msg) = @_;
  print $LOGFILE $msg; # and keep a copy
}

#  - <Section 40> - 
sub LogError #
{ my($msg) = @_;
  print $ERRORFILE "\n$VERSION : $msg"; # Keep a copy.
}

#  - <Section 41> - 
sub FetchKey 
{ my($tbl, $tag) = @_;
  # NB. $USERID = global. 

  my($handDB) = $DB_MAIN;  # global too. 

  my($count) = 0;
while($count < 2000)  # arbitrary MAX
  { $count ++;
    my($now) = &ModTimeNow(); # seconds 
    my($later) = $now + $FETCHTIMEOUT; # seconds, unless a 64-bit system
    my($q) = "UPDATE SKEYS 
         SET klock = $later,
             kuser = $USERID,
             kValue = kValue + 1
         WHERE kName = '$tbl' AND klock = 0";
    my($ok) = &DoSQL($handDB, $q, $tag);  # returns number of rows affected!

#  - <Section 42> - 
  if($ok > 0)
    { my($qget) = "SELECT kValue FROM SKEYS 
               WHERE kName ='$tbl' 
                 AND kuser=$USERID
                 AND klock=$later";
      my($j) = &GetSQL($handDB, $qget, "GET '$tag'"); 
      my($qput) = "UPDATE SKEYS SET klock = 0 
               WHERE kName = '$tbl'
                 AND kuser=$USERID
                 AND klock = $later";
      my($ok2) = &DoSQL($handDB, $qput, "PUT '$tag'");
    if($ok2 < 1)
      { &XPrint(0,  "Failed at reset of semaphore($tbl)\n" );  # [explore this]
      };
    if(! $j)
      { &Aagh("Oops. Bad key generation ($j), matrix $tbl ($qget)", __LINE__, 0 ); 
        return; 
      }; # must NOT return null key.
       return($j);  # success
    } else 
    { # check lock time:
      my($qbad) = "SELECT klock FROM SKEYS WHERE kName ='$tbl'";
      my($lck) = &GetSQL($handDB, $qbad, 'get lock');
    if(! $lck)
      { &Aagh("Error. Bad key on $tbl ($qbad)", __LINE__, 0 ); 
        return;
      };
    # NB. klock value may now be ZERO!
    if( ($lck < $now)
       &&($lck > 0)
      )    # if timed out AND not fixed
      { my($qfix) = "UPDATE SKEYS SET klock = 0
          WHERE kName = '$tbl' AND klock=$lck";
        my($ok3) = &DoSQL($handDB, $qfix, "UPDATE $tag");
      if($ok3 < 1)
        { &XPrint(0, "\nBad semaphore fix $tbl($lck)"); # [explore]
        };
        &XPrint(0, "\nFETCH *FIX* debug SUCCESS"); # [remove this line]
      };
      usleep( int(rand(10000)) ); # microsleep up to 10ms
    }; # end else
  };  # end while
  die("Error with key fetch on matrix $tbl"); 
}

#  - <Section 43> - 
sub FetchManyKeys #
{ my($tbl, $N);
    ($tbl, $N)=@_;
  # NB. $USERID = global. 

  my($handDB) = $DB_MAIN;  
  my($tag) = 'fetch many'; 

if( ($N > $MAXIMUM_KEY_FETCH)
  ||($N < 1)
  )
  { &Aagh("Can't fetch $N keys, max: $MAXIMUM_KEY_FETCH", __LINE__, 0 ); 
    return;
  }; 

  my($count) = 0;
while($count < 200)  # arbitrary MAX number of tries
  { $count ++;
    my($now) = &ModTimeNow();
    my($later) = $now + $FETCHTIMEOUT; # seconds, unless a 64-bit system
    my($q) = "UPDATE SKEYS 
         SET klock = $later,
             kuser = $USERID,
             kValue = kValue + $N
         WHERE kName = '$tbl' AND klock = 0"; # atomic
    my($ok) = &DoSQL($handDB, $q, $tag);  # returns number of rows affected!

#  - <Section 44> - 
  if($ok > 0)
    { my($qget) = "SELECT kValue FROM SKEYS 
               WHERE kName ='$tbl' 
                 AND kuser=$USERID
                 AND klock=$later";
      my($j) = &GetSQL($handDB, $qget, 'get top key'); 
      my($qput) = "UPDATE SKEYS SET klock = 0 
               WHERE kName = '$tbl'
                 AND kuser=$USERID
                 AND klock = $later"; # release semaphore
      my($ok2) = &DoSQL($handDB, $qput, 'many put');
    if($ok2 < 1)
      { &XPrint(0,  "Bad multiple key retrieval on semaphore($tbl)\n" ); 
      };
    if(! $j)
      { &Aagh("Oops. Bad multikey make ($j) for $tbl ($qget)", __LINE__, 0 ); 
        return; 
      }; # must NOT return null key.
       return($j);  # success
    } else 
    { # check lock time:
      my($qbad) = "SELECT klock FROM SKEYS WHERE kName ='$tbl'";
      my($lck) = &GetSQL($handDB, $qbad, 'get lock');
    if(! $lck)
      { &Aagh("Error. Bad key on $tbl ($qbad)", __LINE__, 0); 
        return;
      };
     # NB. klock value may now be ZERO!
    if( ($lck < $now)
       &&($lck > 0)
      )    # if timed out AND not fixed
      { my($qfix) = "UPDATE SKEYS SET klock = 0
          WHERE kName = '$tbl' AND klock=$lck";
        my($ok3) = &DoSQL($handDB, $qfix, 'many fix');
      if($ok3 < 1)
        { &XPrint(0, "\nBad semaphore fix $tbl($lck)"); # [hmm ? die] 
        };
        # &XPrint(0, "\nFETCH *FIX* debug SUCCESS"); # [? in production code]
      };
      usleep( int(rand(10000)) ); # microsleep up to 10ms
    }; # end else
  };  # end while
  &Aagh("Error with key fetch on matrix $tbl", __LINE__, 0 ); 
}

#  - <Section 45> - 
sub GetSQL #
{ my($myODBC, $Query, $tag) = @_;
  $SQLOK = 1;
  if (&DoSQL($myODBC, $Query, $tag) < 0)  # failed
     { # &XPrint(0, "SQL statement failed ($Query)" ); 
       die "SQL statement failed '$tag'"; 
       return ""; # fail 
     };
  my(@newrow);
  @newrow = ();

if($USE_DBI)  # [explore $dbh->selectrow_array($stmt) ] 
  { 
  if(! defined $MY_DBI_HANDLE)
    { print "Missing DBI handle for GetSQL, '$tag'";
      undef @newrow; 
    } else
    { @newrow = $MY_DBI_HANDLE->fetchrow_array(); 
    }; 
  if( (! @newrow)
    ||(scalar @newrow < 1)
    ||($MY_DBI_HANDLE->err)
    )
    { ## print "Debug GetSQL: <$Query> oops '$tag'\n";  
      $SQLOK = 0;
      @newrow = (); 
    }; 
  } else
  { 
  if ( $myODBC->FetchRow() )
     { @newrow = $myODBC->Data(); #first data row
       ## print "\n SQL debug: @newrow"; 
     } else
     { $SQLOK = 0;
     };
  }; 
  return (@newrow);
}

#  - <Section 46> - 
sub DoSQL #
{ $SQLOK=0; # default 'fail'
  my($myODBC, $Query, $tag) = @_;
  my($retcode) = 0; 

if(! defined $myODBC)
  { die "Can't find handle '$tag'";
  }; 

if($USE_DBI)
  { #NOT generally: $retcode = $myODBC->do($Query); 
    $MY_DBI_HANDLE = eval { $myODBC->prepare($Query) } or undef $MY_DBI_HANDLE; 
  if(defined $MY_DBI_HANDLE)
    { $MY_DBI_HANDLE->execute() or $retcode = 1; 
           ## at present don't parameterize (no placeholders/bind values)
    if($retcode) # [? also look into ->{Executed} attribute !]
      { print "Debug: DBI error in DoSQL\n"; 
        $retcode = $MY_DBI_HANDLE->err;  # [hmm, ? rather use $h->state]
      }; 
    } else
    { print "Woops! DBI cockup in DoSQL prepare stmt '$tag'.\n"; 
      $retcode = $myODBC->err; # pick up error code
      ## $retcode = $DBI::errstr;
    if(! defined $retcode)
      { print "No error code!";
        $retcode = 1;
      }; 
    }; 
  } else # not using DBI: 
  { $retcode = $myODBC->Sql($Query);
  }; 

if($retcode) # if problem 
  { my($sqlErrors);
  if($USE_DBI)
    { $sqlErrors = $myODBC->errstr; 
    } else
    { $sqlErrors = $myODBC->Error();
    }; 
    &XPrint(0, "\n Oops! $sqlErrors code=$retcode ($tag): $Query"); 
        # problem may be exceeding _max_allowed_packet rather than "has gone away"!
  if($retcode < 1)
    { # die "Woops! (Code=$retcode)";   # [no, rely on caller to call &Aagh_() ]
      return($retcode);
    }; 
  if($sqlErrors !~ /\[911\].+\[1\].+\[0\]/ ) # NOT if 'no data' [911]
        ## ^ the above will need revision for DBI. Explore. 
    { return(-1); # force failure
    };
    return(0);  # no data 
  };

  # no problem, RETURN ROW COUNT
  $SQLOK = 1;
  if($USE_DBI)
    { $retcode = $MY_DBI_HANDLE->rows;       
    } else
    { $retcode = $myODBC->RowCount(); 
    }; 
  ## &XPrint(0, "\nDebug ($Query) rows affected=$retcode"); 
if($retcode < 0)  # [hmm]
  { $retcode = 0; 
  }; 

  $retcode; # rows affected [?!]
}

#  - <Section 47> - 
sub SQLManySQL # 
{ 
  my($myODBC, $Query, $tag) = @_;

  # introduce SQL constraint of CONSTRAIN:
if(length $SQLCONSTRAINT > 0)
  { $Query .= $SQLCONSTRAINT; # append. 
    # [Would not work if no 'WHERE' or is ORDER/GROUP clause]
    ## print "\n\n\n\nDEBUGGING --CONSTRAINT-- <$Query>\n\n\n"; 
  }; 
  # NO. do not say:  $SQLCONSTRAINT = ''; # once only
  #     as then _direct_ will be affected under constraint. 
  #  CALLER MUST SAY: ClearSQLConstraint() when appropriate!

if( &DoSQL ( $myODBC, $Query, $tag ) < 0)
  { &Aagh("Multiple retrieval failed ($Query)", __LINE__, 0); 
    return;
  }; 
  my(@BIGARRAY) = ();
  my(@big);

if($USE_DBI)
  { 
  if(! defined $MY_DBI_HANDLE)
    { print "Missing DBI handle for SQLManySQL, '$tag'";
    } else
    { @big = $MY_DBI_HANDLE->fetchrow_array(); 
    while (  @big
          && scalar @big > 0
          && ! $MY_DBI_HANDLE->err )
      { push(@BIGARRAY, [ @big ]); # reference!
        @big = $MY_DBI_HANDLE->fetchrow_array(); 
      }; 
    }; 
  } else
  { 
  while ( $myODBC->FetchRow() )     #
    { @big = $myODBC->Data();     #get data
      # @BIGARRAY = (@BIGARRAY, @big);
      # NO! make an array of arrays:
      push (@BIGARRAY, [ @big ]);   # [] makes a reference!
    };
  }; 
  return( @BIGARRAY);
}

#  - <Section 48> - 
sub ClearSQLConstraint #
{ $SQLCONSTRAINT = ''; 
} 

#  - <Section 49> - 
sub AppendSQLConstraint # 
{ my($txt) = @_; 
  $SQLCONSTRAINT .= $txt; # if length > 0, constrains an SQL retrieval (WHERE clause)
} 

#  - <Section 50> - 
sub FindRegion # 
{ my($rgname) = @_;

  my($handDB) = $DB_MAIN; 

  my($q); 
  my($rgn, $desc) = (0, ''); 
  my($hits); 
  my($showall) = 0; 
  my($exact) = 0; 

if($rgname =~ /\?/ )  # contained ? means 'search and then show all names!' 
  { $showall = 1;
    $rgname =~ s/\?//g; # remove the '?'s 
  }; 

  # use single or double quotes for exact match: e.g. for 'MST' EST EET and MET 
if($rgname =~ /['"]/ )  # contained ? means 'search and then show all names!' 
  { $exact = 1;
    $rgname =~ s/['"]//g; # remove the quotes [imprecise but ok]
  }; 

if($rgname =~ /^\s*(\d+)\s*$/ )
  { $q = "SELECT place, description FROM PLACES "
         . "WHERE p_amended BETWEEN 1 and $TOPCOUNTRY "
         . "AND reason > -1 "
         . "AND place = $1"; 
  } 
elsif( $rgname =~ /^\s*([\w\/]+)\s*$/ )
  { $rgname = $1; 
  if($exact)
    { $q = "SELECT place, description FROM PLACES "
         . "WHERE p_amended BETWEEN 1 and $TOPCOUNTRY "
         . "AND reason > -1 "
         . "AND description = '$rgname'"; # exact match! 
    } else
    { $q = "SELECT place, description FROM PLACES "
         . "WHERE p_amended BETWEEN 1 and $TOPCOUNTRY "
         . "AND reason > -1 "
         . "AND description LIKE '\%$rgname\%' ORDER BY description"; #incl 1 = UTC
    }; 
  }
else
  { print "Bad search string '$rgname'\n" 
        . "Name can contain a-z A-Z _ and /\n"; 
    return(0,'',0); 
  }; 

  my(@M) = &SQLManySQL($handDB, $q, 'find multiple name matches'); 
  $hits = scalar @M; 
if($hits)
  { ($rgn, $desc) = ($M[0][0], $M[0][1]); # only use first row values 
  if($showall)
    { my($str) = ''; 
      my($i) = 0; 
    while($i < $hits)
      { $str .= $M[$i][1] . ' '; 
        $i ++; 
      };
      print "Matches: $str\n"; 
    }; 
  }; 
  return($rgn, $desc, $hits); 
}

#  - <Section 51> - 
sub SetRegion #
{ my($rgn) = @_; 

  # first, deal with UTC:
if($rgn == $UTCCODE)
  { undef($MYTIMELY); # <gosh>
    $MYZONE = $rgn;
    return; 
  }; 

  my($handDB) = $DB_MAIN;  

#  - <Section 52> - 
  my ($qa) = "SELECT year, transition, dst, zone_offset, ignored "
           . "FROM timely WHERE region = $rgn ORDER BY transition"; 
  my(@TM) = &SQLManySQL( $handDB, $qa, "fetch region ($rgn) details"); # 
if(scalar @TM < 1)
  { &Aagh("Failed to retrieve region data for $rgn", __LINE__, 0);   # severe. 
    return;
  }; 

  $MYTIMELY = \@TM; # [? make this less clunky][fix me!] 
  $MYZONE = $rgn; 
} 

#  - <Section 53> - 
sub GetUtcCode #
{ return($UTCCODE);
} 

#  - <Section 54> - 
sub QuickBetween # 
{ my($lowY, $hiY) = @_; 

  my(@TM) = @{$MYTIMELY}; # dereference [check efficiency ??][explore] 
  my(@OUT) = (); 

  my($L) = scalar @TM; 
  ## print "Debug: number of rows in QuickBetween_() is $L\n"; 

  my($i) = 0; 
  my($thisY) = 0; 
  # this can be made faster by using a binary search to find low value. 
while( ($thisY <= $hiY) 
     &&($i < $L) 
     )
  { my(@LN) = @{ $TM[$i] }; # get row
    $thisY = $LN[0]; 
    ## print "[check: $thisY $lowY $hiY]"; 
  if( ($thisY >= $lowY)
    &&($thisY <= $hiY)
    )
    { my(@F) = @LN[1..4]; 
      ## print "ok! @F \n"; 
      push(@OUT, \@F); # push the reference, ordered. Can't say \@LN[1..4] BTW. 
    }; 
    $i ++; 
  };

  return(@OUT); 
}

#  - <Section 55> - 
sub GetLocalTime # 
{ my($sec, $min, $hour,
      $mday, $mon, $year,
      $wday, $yday, $isdst);
  ($sec, $min, $hour,
      $mday, $mon, $year,
      $wday, $yday, $isdst) = CORE::localtime(time);
  $year += 1900;      #fix y2k :)
  $sec  = &DoubleDigit($sec );
  $min  = &DoubleDigit($min );
  $hour = &DoubleDigit($hour);
  $mday = &DoubleDigit($mday);
  $mon  = &DoubleDigit($mon );
  $mon ++;            #january is zero!
  return ("$year-$mon-$mday $hour:$min:$sec");
}

#  - <Section 56> - 
sub Julian # 
{ my($d) = @_;

if(! $MYZONE)  # 0 is taken as an error
  { &Aagh("For Julian_() you must first choose a region", __LINE__, 0);
    return;
  }; 
  my($zone) = $MYZONE;

if(!defined $d)
  { return(0);
  };
if($d !~ /(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2}):(\d{2})\.?(\d*)/ )  # strict 
  { return(0);
  };
  my($yyyy, $mm, $dd, $h, $m, $s, $ffffff) = ($1, $2, $3, $4, $5, $6, $7);

  my($JD, $shadow) = &G2J(1, $zone, $yyyy, $mm, $dd, $h, $m, $s);  

  # fix up the float:
  my($micros) = &MicroSecs($ffffff); # not fractional; truncated not rounded. 
  
  return( $JD . $micros, $shadow ); 
}

#  - <Section 57> - 
sub MicroSecs #
{ my($d) = @_;

  my($lF) = length $d; 
if($lF < 6) # will also deal with ''
  { $d .= &Padding( '0', (6-$lF) );  # we want 6 digits, even if zeroes. 
  }
elsif($lF > 6)
  { $d =~ substr($d, 0, 6); # truncate! 
  }; 
  return($d); 
}

#  - <Section 58> - 
sub Gregorian #
{ my($JD) = @_;

  # zone:
  my($zone) = $MYZONE; # global
if(! $zone)
  { &Aagh("Gregorian_() lacks zone", __LINE__, 0); 
    return; 
  };

  # convert microseconds to seconds. 
  my($ffffff); 
if( $JD !~ /^(\d+)(\d{6})$/ )
  { return(''); # how do we fail ? 
  }; 

  $JD = $1; # J2G_() requires seconds
  $ffffff = $2; 

  my($YYYY,$MM,$DD, $h,$m,$s, $dz, $dst, $hog, $deltz, $delds)
     = &J2G(1, $zone, $JD); 
  return( &PrettyDate(0,$YYYY,$MM,$DD, $h,$m,$s) . ".$ffffff" ); 
}

#  - <Section 59> - 
sub FormatDate
{ my($template, $vlu) = @_;
  my($YY,$MM,$DD);
  my($h,$m,$s) = ('00','00','00'); 
if($template eq 'YYYYMMDD')
  { 
  if($vlu !~ /(\d{4})(\d{2})(\d{2})/)
    { return('');
    }; 
    $YY = $1;
    $MM = $2;
    $DD = $3; 
  }
  # might insert variants on the above here, if required
elsif($template eq 'MM-DD-YYYY')
  { 
  if($vlu !~ /(\d{2})[.\/-](\d{2})[.\/-](\d{4})/ )
    { return('');
    }; 
    $YY = $3;
    $MM = $1;
    $DD = $2; 
  }
elsif($template eq 'DD-MM-YYYY')
  { 
  if($vlu !~ /(\d{2})[.\/-](\d{2})[.\/-](\d{4})/)
    { return('');
    }; 
    $YY = $3;
    $MM = $2;
    $DD = $1; 
  }
elsif($template eq 'YYYY-MM-DD')
  { 
  if($vlu !~ /(\d{4})[.\/-](\d{2})[.\/-](\d{2})/)
    { return('');
    }; 
    $YY = $1;
    $MM = $2;
    $DD = $3; 
  }

#  - <Section 60> - 
elsif($template eq 'YYYY-MM-DD hh:mm:ss')
  { 
  if($vlu !~ /(\d{4})[.\/-](\d{2})[.\/-](\d{2}) (\d{2}):(\d{2}):(\d{2})/)
    { return('');
    }; 
    $YY = $1;
    $MM = $2;
    $DD = $3; 
    $h = $4;
    $m = $5;
    $s = $6; 
  }

#  - <Section 61> - 
elsif($template eq 'YYYY-MM-DD hh:mm')
  { 
  if($vlu !~ /(\d{4})[.\/-](\d{2})[.\/-](\d{2}) (\d{2}):(\d{2})/)
    { return('');
    }; 
    $YY = $1;
    $MM = $2;
    $DD = $3; 
    $h = $4;
    $m = $5;
  }

#  - <Section 62> - 
elsif($template eq 'DD-MM-YYYY hh:mm:ss')
  { 
  if($vlu !~ /(\d{2})[.\/-](\d{2})[.\/-](\d{4}) (\d{2}):(\d{2}):(\d{2})/)
    { return('');
    }; 
    $DD = $1;
    $MM = $2;
    $YY = $3; 
    $h = $4;
    $m = $5;
    $s = $6; 
  }

#  - <Section 63> - 
elsif($template eq 'DD-MM-YYYY hh:mm')
  { 
  if($vlu !~ /(\d{2})[.\/-](\d{2})[.\/-](\d{4}) (\d{2}):(\d{2})/)
    { return('');
    }; 
    $DD = $1;
    $MM = $2;
    $YY = $3; 
    $h = $4;
    $m = $5;
  }

#  - <Section 64> - 
elsif($template eq 'MM-DD-YYYY hh:mm:ss')
  { 
  if($vlu !~ /(\d{2})[.\/-](\d{2})[.\/-](\d{4}) (\d{2}):(\d{2}):(\d{2})/)
    { return('');
    }; 
    $MM = $1;
    $DD = $2;
    $YY = $3; 
    $h = $4;
    $m = $5;
    $s = $6; 
  }

#  - <Section 65> - 
elsif($template eq 'MM-DD-YYYY hh:mm')
  { 
  if($vlu !~ /(\d{2})[.\/-](\d{2})[.\/-](\d{4}) (\d{2}):(\d{2})/)
    { return('');
    }; 
    $MM = $1;
    $DD = $2;
    $YY = $3; 
    $h = $4;
    $m = $5;
  }

#  - <Section 66> - 
else
  { &Aagh("Unknown _julian_ date format option <$template>", __LINE__, 0); 
    return;  # need smarter approach here, more options
  }; 
  return("$YY-$MM-$DD $h:$m:$s");
}

#  - <Section 67> - 
sub G2J #
{ my($qik, $zone, $YY, $MM, $DD, $h, $m, $s) = @_; # no fractional seconds 
 
  my($handDB) = $DB_MAIN;  

if( $qik
  &&($zone != $MYZONE) # check it's the right region, D'Oh!
  )
  { &Aagh("Can't do quick retrieval, mismatched zones: $zone|$MYZONE", __LINE__, 0); 
    return;
  }; 

#  - <Section 68> - 
  my(@ROWS);
  my($hi) = 2 + int($YY);  # high year limit
  my($lo) =-1 + int($YY);  # low year   
if($qik)  # $zone is redundant 
  { (@ROWS) = &QuickBetween($lo, $hi); # get tr, dst, zo, ignored from $MYTIMELY 
  } else
  { my($q) = "SELECT transition, dst, zone_offset, ignored from timely "
      . "WHERE region = $zone AND year BETWEEN $lo AND $hi ORDER BY transition"; # ASC 
      # ENCOMPASSES year of interest!
    (@ROWS) = &SQLManySQL($handDB, $q, 'get all rows');
  }; 

#  - <Section 69> - 
  my($jraw) = &ToJulian($YY, $MM, $DD, $h, $m, $s, 0, 0, 0); # no zone/DST yet
  my($JBIG) = $jraw * 1000000; # microseconds, as in database.

  my($JX) = 0;        # if no row applies, will fail, returning zero
  my($shadow) = 0; 
  my($last_tr) = 0;   # prior transition as error trigger
  my($lastd) = 0;     # dual usage as below
  my($lastzo) = 0;    

if($zone == $UTCCODE)
  { $JX = &BigApplyGps($JBIG);  # GPS correction!
    return( &HugeToJ($JX), 0 );  # return GPS-adjusted Julian value, no shadow. 
          # ^ [TEMP]
  }; 

#  - <Section 70> - 
while(scalar @ROWS > 0)     # [clumsy] 
  { my($r) = shift @ROWS;
    my($tr, $d, $z, $ign) = @$r;  # transition, DST, Z, all in microseconds. 
    $JX  = &BigApplyGps($JBIG - $z - $d);  # final GPS correction!

#  - <Section 71> - 
  if($JX < $tr) 
    { 
      # is this in limbo? 
    if($JX < $last_tr)
      { $shadow = ( ($lastzo + $lastd) - ($z + $d) ) / 1000000; # negative, seconds
   #     print "limbo warning: $JX , $shadow\n"; # debug 
        return( &HugeToJ($JX), &Biggen($shadow) );  # return GPS-adjusted Julian INT  
      }; 

#  - <Section 72> - 
      $r = shift @ROWS;  # get NEXT entry 
      my($next_tr, $next_d, $next_z, $next_ign) = @$r; 

      my($Delta) = ($z + $d) - ($next_d + $next_z); 
    if($JX + $Delta >= $tr)  # yes, groundhog:
      { $shadow = $Delta/1000000; # [assume integer] [hmm] 
  #      print "groundhog note: $JX, $shadow\n"; # debug. 
        return( &HugeToJ($JX), $shadow); 
      }; 

#  - <Section 73> - 
      return( &HugeToJ($JX), 0 );  # return GPS-adjusted Julian value INTEGER. 
    }; # end winner. 

#  - <Section 74> - 
    $last_tr = $tr;  # retain
    $lastd = $d;     
    $lastzo = $z;    
  };     # end of while loop. 

#  - <Section 75> - 
  return(0,0); 
}

#  - <Section 76> - 
sub ToJulian
{ my($YY, $MM, $DD, $h, $m, $s, $fff, $Zoff, $Dst);
    ($YY, $MM, $DD, $h, $m, $s, $fff, $Zoff, $Dst)=@_;
if(! defined $s) # must have seconds
  { return(0);    
  }; 

  $Zoff /= 86400;
  $Dst /= 86400; 

  $fff = &Lead($fff,3); # leading zeroes for milliseconds [?? check this]

  ## my($Z) = $YY + int( ($MM-14)/12 ); # step 1. 
if($MM < 3)                          # step 2. 
  { $MM += 12; # could equally just subtract 1 from $YY and use ipo $Z. 
    $YY -= 1;  # equivalent of step 1. 
  };

  my($F) = int( (153*$MM - 457)/5 ); 
  my($J) = $DD + $F + 365*$YY + floor($YY/4) - floor($YY/100) 
             + floor($YY/400) + 1721118.5; # step 3. 

  $J -= ( $Zoff + $Dst ); # fractions of a day
  $J += (  $h + ( $m + ($s + "0.$fff")/60 )/60  )/24; 

  return($J*86400);
}

#  - <Section 77> - 
sub GpsJulian # 
{ my($fy, $fm, $fd, $fh, $fmi, $fs, $ff, $LToff, $Dst);    # clumsy, use @
    ($fy, $fm, $fd, $fh, $fmi, $fs, $ff, $LToff, $Dst)=@_;

  my($J) = &ToJulian($fy, $fm, $fd, $fh, $fmi, $fs, $ff, $LToff, $Dst);
                                                # seconds ^       ^
  return( &ApplyGps($J) );
}

#  - <Section 78> - 
sub ApplyGps # 
{ my($J) = @_;
 
  my($Ltop) = scalar @LEAPDATA; 
  my($i) = 0;
while($i < $Ltop)
  { my($d) = $LEAPDATA[$i]; # most recent value is at start of @LEAPDATA
    my(@D) = @$d; # dereference 
    # in the following note 1 (not 0) index: 
  if( $J >= ($D[1]/1000000.0) ) # smarter ? pre-scale @LEAPDATA or a copy 
    { return($J+$D[2]);  # add the offset
    };
    $i ++;
  };
  return($J-9);
}

#  - <Section 79> - 
sub BigApplyGps #
{ my($Jbig);
    ($Jbig)=@_;
  my($Ltop) = scalar @LEAPDATA; 
  my($i) = 0;
while($i < $Ltop)
  { my($d) = $LEAPDATA[$i];
    my(@D) = @$d; # dereference
    my($greg) = $D[1];
    my($off) = $D[2];    # seconds
  if($Jbig >= $greg)        # [check this inequality for consistency ??]
    { my($K) = $Jbig+($off*1000000);  # microseconds
      return($K); # days
    };
    $i ++;
  };
  my($K) = $Jbig -(9000000);  # 9s
  return($K);
}

#  - <Section 80> - 
sub JulianFromUnix
{ my($unix) = @_;
  # currently allow a proleptic negative value [explore] 

  my($Uzero) = &ToJulian(1970, 1, 1, 0, 0, 0, 0, 0, 0); # to seconds
  $Uzero += $unix; # [NB. what about internal unix leap seconds?]
  return( &ApplyGps($Uzero) );
}

#  - <Section 81> - 
sub FetchTzDate #
{
  my($JD, $zone, $YEAR, $MONTH, $DAY, $HOUR, $MINUTE, $SECOND) = @_;
##  print " { FetchTzDate : $zone, $YEAR, $MONTH, $DAY, $HOUR, $MINUTE, $SECOND "; 

if($zone eq 'UTC/UTC')
  { return( &PrettyDate(1,$YEAR,$MONTH,$DAY, $HOUR, $MINUTE, $SECOND) );
  }; 

  ## print "Debug: fetching tz date: '$zone'\n"; # 2021-03-13 
if(length $zone < 1)
  { $zone = 'UTC';
  }; 

  my($yours)='';
eval
  { my($dt1) = DateTime->new( year => $YEAR, month => $MONTH, day => $DAY,
       hour => $HOUR, minute => $MINUTE, second => $SECOND,
       time_zone => $zone);
    my($dtest) = $dt1->clone->set_time_zone( 'UTC' );
    $yours = $dtest->datetime();  # format is identical
    1;   # prevents alterations to $@
  } or do
  { my($e) = $@;
    chomp($e); # $e should contain 'bad' zone name. 
    my($dt2); 
    my($woops); 
   if($e =~ /The timezone .* could not be loaded/)  ## e.g. new zone like America/Coyhaique 
     { $woops = "Missing timezone in tz DateTime: '$e' --- defaulting to UTC\n"; 
       $zone = 'UTC';
     } else # Walldate is for debugging: 
     { my($walldate) = &PrettyDate(0,$YEAR, $MONTH, $DAY, $HOUR, $MINUTE, $SECOND); 
       $woops = "BAD zone time, Perl DateTime said: '$e'; wall=$walldate"; 
       ($YEAR, $MONTH, $DAY, $HOUR, $MINUTE, $SECOND) = Timely::FullGregorian($JD, 0, 0, 1);
     }; 
     $dt2 = DateTime->new( year => $YEAR, month => $MONTH, day => $DAY, 
           hour => $HOUR, minute => $MINUTE, second => $SECOND, time_zone => 'UTC');
     $yours = $dt2->datetime() . '?'; 
     my($corrected) = $dt2->clone->set_time_zone( $zone )->datetime(); 
     &Warn(3, "$woops; corrected='$corrected' " ); 
  };

##  print " => $yours } "; 

  return($yours); 
}

#  - <Section 82> - 
sub InternalJulian #
{ my($inp, $region, $regionNAME) = @_;

  my($YY,$MM,$DD,$h,$m,$s); 

if($inp =~ /^\s*(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2}):(\d{2})\s*$/ )
  { ($YY,$MM,$DD,$h,$m,$s) = ($1, $2, $3, $4, $5, $6);
  }
elsif( $inp =~ /^\s*(\d{4})-(\d{2})-(\d{2})\s*$/ )
  { ($YY,$MM,$DD, $h,$m,$s) = ($1, $2, $3, 0,0,0);
  } else
  { print " [ERROR] date format is YYYY-MM-DD hh:mm:ss \n";  # ? be more lenient
    return(0);
  };
  
  my($J, $shadow) = (0,0);
if($region == $UTCCODE)  # if UTC
  { $J = &GpsJulian($YY,$MM,$DD,$h,$m,$s, 0, 0, 0);
  } else
  { ($J, $shadow) = &G2J(1, $region, $YY,$MM,$DD,$h,$m,$s);
  };
if( ( $shadow < 0)   # failed, -ve shadow
  || ! $J            # or zero (bad J)
  )
  { print "\nBad date for zone $region($regionNAME): $inp (" 
          . &JulianDay($J) . " / " . $shadow . " )\n";
    return(0); # fail
  };

#  - <Section 83> - 
  my($mine) = &Greg($J,0,0,1);  # Render as standard date, then do the same in TZ!
  $mine =~ s/ /T/;  # replace ' ' with 'T'
  my($yours) =  &FetchTzDate($J, $regionNAME, $YY, $MM, $DD, $h, $m, $s);

  my($yourmsg); 
  my($err) = ''; 
if(length $yours < 1) 
  { $yourmsg = "[no reference]";
  } else
  { $yourmsg = $yours . $TICK ;
  if($mine ne $yours)
    { my($mine2) = &Greg($J + $shadow, 0, 0, 1); # add s; compensate for TZ jump!
      $mine2 =~ s/ /T/;
    if($mine2 eq $yours)
      { $err = ' (+) ';
      } else
      { $err = " Date mismatch '$mine'??  vs ";
      };
    };
  }; 

if(length $err > 0)
  { print sprintf("%.12f", &JulianDay($J) ) 
          . " zone=$region (shadow=" . $shadow . " s) $err gps=$yourmsg" . "\n";
#  }
#elsif($FULLDEBUG)
#  { print sprintf("%.12f", &JulianDay($J) ) . " zone=$region (shadow=" 
#          . $shadow . " s) gps=$yourmsg" . "\n";
  }; 
  return($J);
}

#  - <Section 84> - 
sub JulianDay # 
{ my($s) = @_;
  return($s/86400.0); 
}

#  - <Section 85> - 
sub FullGregorian #
{ my($jd, $LCL, $DST, $isgps);
    ($jd, $LCL, $DST, $isgps)=@_;

  # ensure $jd is in integer seconds, and likewise for LCL, DST:
  $jd = &Biggen($jd); 
  $LCL = &Biggen($LCL);
  $DST = &Biggen($DST); 

if($isgps)
  { $jd = &ExGps($jd);  # get rid of GPS offset, still integer.
  };

  my($Z, $R, $G, $A, $B, $C);
  my($year, $month, $day);

  $jd += $LCL+$DST; 

  my($ss);  
  my($hh, $mm); 

    $Z = floor($jd/86400 - 1721118.5);       # Z = integer Julian days (exact) 
    $R = $jd - 43200*(3442237 + 2*$Z);       # 1721118.5*2 = 3442237 
      # R is the rest (as seconds, integer)
   
    # the following are calculations in terms of days, including leap years etc.: 
    $G = $Z - 0.25;                          # 0.25 is precise, $G precise (days)
    $A = floor( ($G) / 36524.25);            # $A is integer 
    $B = $A - floor( ($A) / 4);              # $B is integer 
    $year = floor( ($B+$G) / (365.25) );     # $year is integer 
    $C = $B + $Z - floor(365.25 * $year);  # $C is integer
    $month = int( (5 * $C + 456) / 153 );    # 

    $day = $C - int( (153 * $month - 457) / 5 ) + $R/86400; # note $R use
  if ($month > 12)
     { $year = $year + 1;
       $month = $month - 12;
     };

    my($hms) = 24*$R;                 # 24*seconds !!
    $hh =int($hms/86400);             # hours
    my($ms) = 60*($hms - $hh*86400);  # minutes AND seconds
    $mm =int($ms/86400);              # minutes
    my($sx) = 60*($ms - $mm*86400); 
    $ss = int($sx/86400); 

    # a redundant check: 
if($ss - $sx/86400 != 0) # should always be exact, check: 
  {
    print "\n***BLAST!!*** $ss, $sx : delta=" 
          . sprintf("%.12f", ($ss - $sx/86400) ); 
  }; 

  return ($year, $month, int($day), $hh, $mm, $ss );
}

#  - <Section 86> - 
sub ExGps # 
{ my($J);
    ($J)=@_;

  my($Ltop) = scalar @LEAPDATA; 
  my($i) = 0;
while($i < $Ltop)
  { my($d) = $LEAPDATA[$i];
    my(@D) = @$d; # dereference # [clumsy]
  if( $J >= ($D[0]/1000000.0) )        # [check this inequality ??]
    { return($J-$D[2]); # days
    };
    $i ++;
  };
  return($J+9);
}

#  - <Section 87> - 
sub ClipFractionalSeconds #
{ my($d) = @_;
if($d =~ /(.+)\.(\d+)/ )
  { $d = $1;  # clip everything after the decimal, AND the decimal point
  };
  return($d);
}

#  - <Section 88> - 
sub Greg #
{ my($J, $LCL, $DST, $isgps) = @_;

if($J < 1) # rubbish
  { return('_');
  };
  my($YY,$MM,$DD, $h,$m,$s) = &FullGregorian($J, $LCL, $DST, $isgps);
if($YY < 1) # 1 AD
  { return('?'); # we're not interested in BC!
  };
  return( &PrettyDate(0,$YY,$MM,$DD,$h,$m,$s) );
}

#  - <Section 89> - 
sub PrettyDate # 
{ my($isT, $YYYY,$M,$D,$h,$m,$s) = @_;
  my($spacer) = ' '; # usual separator between date and time
if($isT)
  { $spacer = 'T'; 
  }; 
  return( "$YYYY-" . &DoubleDigit($M) . '-' . &DoubleDigit($D) . $spacer 
    . &DoubleDigit($h) . ':' . &DoubleDigit($m) . ':' . &DoubleDigit($s) );
}

#  - <Section 90> - 
sub HugeToJ # 
{ my($d);
    ($d)=@_;
if(! defined $d)
  { return(PART_EMPTY);
  };
if($d !~ /^-?\d+/ )  # allow -ves
  { return('_')
  };
  ## print "HugeToJ took $d gave " . sprintf("%.12f", $d/1000000) . "\n"; 
  return( &Biggen($d/1000000) ); # convert microseconds to *int* seconds [NB] 
}

#  - <Section 91> - 
sub J2G # 
{ my($qic, $zone, $jd) = @_;

  my($J) = $jd * 1000000;  # [really should use big number libraries]


  my($YEAR, $xMM, $xDD, $xh, $xm, $xs) = &FullGregorian($jd, 0, 0, 1);  # NB $jd NOT $J
    # clumsy, rather just divide etc. [fix me]
  # print "Debug: J2G : $zone $jd\n"; 


  my($Z,$D, $hog, $deltz, $delds) = &Anomalous($qic, $zone, $YEAR, $J);
  # NB. $deltz, $delds are in microseconds, at present. 


  my($LCL) = $Z/1000000; # microseconds to days
  my($DST) = $D/1000000; #
  my($YY, $MM, $DD, $h, $m, $s) = &FullGregorian($jd, $LCL, $DST, 1);  # GPS *on*
  
# print "Debug: J2G done: $YY, $MM, $DD, $h, $m, $s\n"; 

  # return all values, not a composite:
  return( $YY, $MM, $DD,  $h, $m, $s,  $LCL, $DST, $hog, $deltz/1000000, $delds/1000000); 
}

#  - <Section 92> - 
sub Anomalous #
{ my($qic, $zone, $YEAR, $JBIG);
    ($qic, $zone, $YEAR, $JBIG)=@_;

if($zone == $UTCCODE)
  { return(0, 0, 0, 0, 0);  # Z=0, DST=0, not groundhog, ...
  };  # [explore: what it $zone is zero??] 

if( $qic
  &&($zone != $MYZONE) # check it's the right region, D'Oh!
  )
  { &Aagh("Quick Anomaly, mismatched zones: $zone|$MYZONE", __LINE__, 0); 
    return;
  }; 

#  - <Section 93> - 
  ## my($epsilon) = 500000; # microseconds 0.5 seconds [? : see notes] 
  my($epsilon) = 10000; # 10 microseconds

  my(@ROWS);
  my($hi) = 2 + int($YEAR);
  my($lo) =-1 + int($YEAR);
if($qic)
  { (@ROWS) = &QuickBetween($lo, $hi); # as for G2J_(): get tr, dst, zo, ignored
  } else
  { my($handDB) = $DB_MAIN;  
    my($q) = "SELECT transition, dst, zone_offset, ignored from timely "
                                   # a dummy value ^ 
    . "WHERE region = $zone AND year BETWEEN $lo AND $hi ORDER BY transition";  # ASC
    (@ROWS) = &SQLManySQL($handDB, $q, 'get all rows');
  }; 

#  - <Section 94> - 
   my($r);
  my($trold) = 0; # preceding transition
  my($dold) = 0;  # preceding DST value
  my($zold) = 0;  # preceding zone offset
  
  my($i) = 0;
  my($rL) = scalar @ROWS; 
while($i < $rL)
  { $r = $ROWS[$i]; 
    my($tr, $d, $z, $dmy) = @$r;  # database tr (Julian), DST, Z that apply up to $tr. 

  if( ($tr - $JBIG) > $epsilon )  # we have our transition row: A large IF CLAUSE 
    { ## print "\n[$JBIG : $tr], diff=" . ($tr - $JBIG) ; 

#  - <Section 95> - 
      my($deltaz) = $z - $zold;   # eg. will be negative if Z has decreased 
      my($ddst) = $d - $dold;     # eg. will be positive if spring forward
      my($shadow) = $deltaz+$ddst;  
      ## print " shadow=$shadow ($deltaz $ddst [$z $zold $d $dold]) "; 

#  - <Section 96> - 
    if($JBIG < $trold-$shadow) # we know $JBIG is > $trold. 
      { ## print "Debug Anomalous_() z=$z d=$d\n" ; 
        return($z, $d, 1, $deltaz, $ddst); 
                     # ^ "$hog"
      }; 

#  - <Section 97> - 
      $i ++; 
    if($i >= $rL) # run out!!
      { &Warn(3, "Anomalous_() data ran out: zone=$zone, year=$YEAR, value=$JBIG");
        return($z, $d, 0, 0, 0); # or might even fail
      }; 

      $r = $ROWS[$i];  # next row
      my($tnext, $dnext, $znext) = @$r;

      # a further caution: ? can be 'next' transition almost immediately after
      # current--- related to our end-of-year 'ignorable' insert. 
      # We thus check for this:
    if( ($tnext - $tr) < 120000000) # currently use 2 minutes, NB Phoenix 
      { $i ++; 
      if( $i >= $rL )  # [can this happen?]
        { &Warn(3, "Upper adjustment failed!! zone=$zone, year=$YEAR, value=$JBIG"); 
        } else
        { print '>>'; # [hmm] 
          $r = $ROWS[$i];  # next row
          ($tnext, $dnext, $znext) = @$r; # throw away the rubbish
        }; 
      } 
      # end check. 

      my($nextdz) = $znext - $z;
      my($nextdd) = $dnext - $d; 
      my($nextshadow) = $nextdz + $nextdd - $epsilon;
      # epsilon extends the shadow slightly back to cover the e.g. -1hr mark. 
      ## print " next shadow=$nextshadow ($nextdz $nextdd [$z $znext $d $dnext]) "; 
    if($JBIG > $tr+$nextshadow) # will only work if $nextshadow is -ve 
      { ## print "Debug Anomalous_() z=$z d=$d\n" ; 
        return($z, $d, -1, $nextdz, $nextdd);
                      # ^ "$hog"
      }; 

#  - <Section 98> - 
        ## print "Debug Anomalous_() z=$z d=$d\n" ; 
        return($z, $d, 0, 0, 0); 
            # both zero ^  ^ if hog is zero [explore]  
    }; ## END large IF CLAUSE. 

#  - <Section 99> - 
    $trold = $tr;
    $dold = $d;
    $zold = $z; 
    $i ++; 
  }; # end while. 

  # [EXPLORE THIS FAILURE] 
  &Warn(1, "Timestamp " . $JBIG/86400000000 . " out of range zone=$zone, y=$YEAR"); 
  return(0, 0, 0, 0, 0); 
} 

#  - <Section 100> - 
##################################################
#              END OF MAIN ROUTINE               #
##################################################
1;
#  -END OF FILE- 
