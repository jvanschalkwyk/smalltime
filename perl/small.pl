#  Generated by LaTeX DogWagger Version 4.0.5 from file <small_time_400.tex>
#  Date: [2026-1-31 14:42:15] 
#  Do NOT edit this file. Edit the LaTeX source!!

#  - <Section 39> - 
#!/usr/local/bin/perl -w
use strict;
use warnings; 

# check the following: 
use feature 'unicode_strings'; 
use utf8; 
use open ':encoding(utf8)';
binmode(STDOUT, ":utf8");

use constant LEAPSECONDCOUNT => 27;  # see usage below 
my $TOPCOUNTRY = 999;           # max in PLACES table. *DO NOT* fiddle! 
                                # don't make it a constant (interpolated).

my $FULLDEBUG = 0; # [nasty] 
my $TOPYEAR = 2035;
my $LOWYEAR = 1895;
my($PRETTYDOTS) = 60;  # count of dots on console before newline 
my $TICK  = "✔"; # or '_/' if no Utf8. 
my $MAXOOPS = 100;              # maximum errors. See usage.
my $READKEYBLOCKINGPROBLEM = 0; # A problem with Perl upgrade to 5.28 ! 


my $TZDIR = 'tz';        # sub-directory that contains tz data files

package main; 
## use Time::HiRes qw(gettimeofday usleep);  # high-resolution timing 
## use POSIX qw(floor ceil); 
## use File::Copy qw(move); # more 'compatible' than rename

use Term::ReadKey;  # only used to interrupt long loops by pressing Esc
$| = 1;             # turn on autoflushing 

## ensure lib/Timely module is visible: [??? is this necessary ???] 
use FindBin; 
use lib "$FindBin::Bin/lib"; 

use Timely; 


#  - <Section 40> - 
             # NAMES: ('region', 'placename', 'INTERVAL', 'utc', 'DayNumber', 
             #         'sec', 'wall', 'myz', 'mydst'); 
 my(@OLDMENUVALUES) = ('',       '',          '',         '',    '',          
                       '',    '',     '',    ''     ); 

#  - <Section 41> - 
use constant ZoneReadFailed => 1000; # arbitrary failure code (should be > 100) 

  ## COLOURS: 30–37 = black, red, green, yellow, blue, magenta, cyan, white. 
use constant ANSIBLACK => 30; 
use constant ANSIRED => 31; 
use constant ANSIGREEN => 32; 
use constant ANSIYELLOW => 33; 
use constant ANSIBLUE => 34; 
use constant ANSIMAGENTA => 35; 
use constant ANSICYAN => 36; 
use constant ANSIWHITE => 37; 

use constant MAXZOFF => 1+14*3600;  # ) maximum ZONE offset (+14 for Kiritimati); 
use constant MAXDST => 1+12*3600;   # ) seconds 
use constant MINIMUMDATE => 2378496*86400;    # < 1800 is just silly 

  ## convenient constants used in tz rule translation: 
use constant  DASHRULE => '-';
use constant  FIXEDDST => 'd';
use constant  FIXEDDZ => 'z';
use constant  DSTTRAN => 'x';
use constant  FINALRULE => 'y'; 

use constant EPSILONSECONDS => 0.010;     # [fix this up cf below. 10 ms. ] 

  ## ERROR codes: 
use constant OnlyHelp => 1; 
use constant BadTopYear => 2; 

my $LEAPSECONDS = LEAPSECONDCOUNT; 
my $BASEDATABASE = 'SMALLTIME';    # the target database *written to* 
                                   # for change specify db=foo on the command line. 
  my $TZDATABASEID = 0;              # a source (src) ID 
  my $USERID = 2000;               # 'standard' default main user

my @STORAGE; 
my %LOCALS = ();                   # current set of locals (empty) 
my %ZONECODES;                     #  internal database zone codes 
my %REZONE;                        # the reverse lookup of ZONECODES 
my %RULES;                         # associative array for rules
my %ZONES;                         # and for zones
my %LINKS;                         # time zone links e.g. Europe/Jersey

 use DBI; 
 my @driver_names = DBI->available_drivers;
 print ("Drivers for DBI: @driver_names \n"); 
 my @data_sources = DBI->data_sources('ODBC'); 
 print("DBI data sources for ODBC are @data_sources \n"); 

my $BUG = 0;                    # debugging, See Debug_() 

#  - <Section 42> - 

  my $WINDOWS = 0; # signal we're NOT on Windows [explore DBI use]

  # Detect OS:
  my $OPERATING_SYSTEM;
if($^O =~ /darwin/i)
  { $OPERATING_SYSTEM = 'Mac';
  }
elsif($^O =~ /linux/i)
  { $OPERATING_SYSTEM = 'Linux';
  }
elsif($^O =~ /win/i)
  { $OPERATING_SYSTEM = 'Windows';
    $WINDOWS = 1; 
    # hack: change console mode:
    `chcp 65001`;
  } else
  { $OPERATING_SYSTEM = 'Unknown'; # perhaps fail at this point!
    &DoWarn(3, " UNKNOWN OPERATING SYSTEM: '$^O'"); 
  }; 

  &PreArgs(); # read command line arguments 

#  - <Section 43> - 
my %DATABASES; 
my $smalltime_h;
  print "\nConnecting to '$BASEDATABASE'\n"; 
  $smalltime_h = DBI->connect("dbi:ODBC:$BASEDATABASE",
                                  undef, 
                                  undef, 
                                  { AutoCommit => 0,
                                    RaiseError => 1,
                                    LongReadLen => 50000000});
if(! defined $smalltime_h)
  { die "*CRASH* could not make ODBC instance for $BASEDATABASE\n"; 
  }; 
  $smalltime_h->{LongTruncOk} = 0; 
  $smalltime_h->{LongReadLen} = 100000000; # 100M ! 
  print "\n\n\nThe AutoCommit attribute is: " . $smalltime_h->{AutoCommit} . "\n";
  print "Maximum read length is: " . $smalltime_h->{LongReadLen} . "\n"; 
  print "The value of LongTruncOk is: " . $smalltime_h->{LongTruncOk} . "\n\n\n"; 
    # cf. https://docstore.mik.ua/orelly/linux/dbi/ch06_02.htm 

#  - <Section 44> - 
  $DATABASES{$BASEDATABASE} = $smalltime_h; # note this is case-sensitive. 
  my(@LEAPDATA) = Timely::BeginTimely($smalltime_h, 1);    # open log. [2nd argument is redundant] 

if(scalar @LEAPDATA < $LEAPSECONDS) 
  { &PopulateLeapSeconds($TZDIR); # fix or die. 
    @LEAPDATA = Timely::BeginTimely($smalltime_h, 1);
  if(scalar @LEAPDATA < $LEAPSECONDS) 
    { die "Unable to update leap seconds <@LEAPDATA>"; 
    }; 
  };
  print "\n Leap data length: " . scalar @LEAPDATA; 

  my($region, $regionNAME, $hits) = Timely::FindRegion('UTC/UTC'); 
  Timely::SetUtcCode($region); #$UTCCODE 

&ClearNewWarnings(); 
Timely::SetMaxKeyFetch(2500000);          # 2.5M new keys [explore]
Timely::SetUserId($USERID);
Timely::SetTzDatabase($TZDATABASEID); 

#  - <Section 45> - 
  my($fail) = Timely(); 

#  - <Section 46> - 
  &ImplementExit($fail);  # this should COMMIT unless $fail is nonzero.  

  
##################################################
#              END OF MAIN ROUTINE               #
##################################################

#  - <Section 47> - 
sub Timely #
{ my($fail); 
  $fail = &TestJulian();  # check Julian_day number conversions are working
if($fail)
  { return($fail); 
  }; 
  return( &Converter() );  # USER INTERFACE
}

#  - <Section 48> - 
sub Converter 
{
  ## &Cls();  ## temp removal 2021-03-13 

  my($INTERVAL) = 3000; # seconds, a bit < 1 hour.
  my($NUMBR) = Timely::GpsJulian(2000,1,1, 0,0,0, 0, 0, 0); # seconds!!
  # GPS time is here e.g. 13s ahead of UTC
  my($region, $regionNAME, $hits) = Timely::FindRegion('Auckland'); # [parochial] 
  Timely::SetRegion($region); 

  my($MENU) = &SetMenu($NUMBR, $region, $INTERVAL, $regionNAME, 1); # 1=Welcome
  print $MENU; 

#  - <Section 49> - 
  my($confirm) = 0; 
AGAIN: while( <STDIN> )
  { chomp;
  if($confirm)
    { $confirm = 0; 
    if( /^y/i )
      { my($fail); 
        $fail = &ReadZones(0, '');  # read all zones [at present] 0 signals this...
        ## ^ best should simply return failure code here if fails:
      if(length $fail > 0)  # expected null string
        { print "\n*FAILED* '$fail'\n"; 
          return(ZoneReadFailed);  
        }; 
      };
      print $MENU;
      next AGAIN;
    };
  if( /^r\s*(.*?)\s*$/i ) # READ
    { my($zpart) = $1; 
    if(length $zpart < 1)
      { my($fail) = &ReadZones($region, $regionNAME); # region limited.
      if(length $fail > 0)
        { print "\nOops! '$fail'\n"; # the error message.
        } else
        { print "\nCompleted zone read: '$regionNAME'.\n"; 
        }; 
      } 
    elsif($zpart eq 'all') # only this will do 
      { print "\n Read ENTIRE TZ database? Are you sure? (y|n) ";
        $confirm = 1;
      } 
    else
      { print "\nUnknown read option '$zpart'\n"; 
      }; 
      next AGAIN; 
    }; 

#  - <Section 50> - 
  if( ! /^\s*([adfghijlnqstuvwyz\+\-\?])\s*(.*?)\s*$/i ) # 'r' already processed
    { 
    if(length $_ > 0)
      { &Cls(); 
        print " Unknown option ($_)\n";
      } else
      { $MENU = &UpdateMenu($NUMBR, $region, $INTERVAL, $regionNAME); 
      }; 
      next AGAIN; 
    } else
    { my($inp) = $2;
      my($ch)  = $1;
      $ch =~ tr/A-Z/a-z/;  # lower case
    if($FULLDEBUG)
      { print "\n$inp--> ";
      }; 

#  - <Section 51> - 
  if( $ch eq 'q' )    # Quit
    { return(0);     # success. Will force COMMIT by caller! 
    };

#  - <Section 52> - 
  if( ( $ch eq 'h' )    # help [might make this more fancy?] 
    ||( $ch eq '?'  )
    )
    { my($hlp) = &ShowHelp($inp); # returns '' on success! 
    if(length $hlp > 0) # failed
      { # $MENU = &UpdateMenu($NUMBR, $region, $INTERVAL, $regionNAME);
        print $MENU; 
        print $hlp; 
      }; 
      next AGAIN;
    };

#  - <Section 53> - 
  if( $ch eq 't' ) # TEST
    { &ZoneTest($inp, $NUMBR, $LOWYEAR, $TOPYEAR); # global source 
      print $MENU;
      next AGAIN;
    };

#  - <Section 54> - 
  if( $ch eq 'w' ) # WALL TEST
    { &WallTest($inp, $NUMBR, $LOWYEAR, $TOPYEAR-1);
      print $MENU;
      next AGAIN;
    };

#  - <Section 55> - 
    if($ch eq 'g')  # convert TO Julian
      {
        my($n) = Timely::InternalJulian($inp, $region, $regionNAME);
      if($n)
        { $NUMBR = $n;
          $MENU = &UpdateMenu($NUMBR, $region, $INTERVAL, $regionNAME); 
          next AGAIN; 
        };
      }

#  - <Section 56> - 
     elsif($ch eq 'j' ) # TO Gregorian wall time
      { # here might further check $inp, but simply do:
      if($inp =~ /^\s*(\d+\.?\d*)\s*$/ )
        { my($JD) = $1; 
        if($JD > 3000000)
          { print "A bit too late!\n"; 
            next AGAIN;
          }; 
          $inp = $JD*86400; # convert to seconds 
          my($YYYY,$MM,$DD,$h,$m,$s, $dz, $dd, $hog, $deltz, $delds) 
                             # unused ^    ^    ^     ^       ^
                = Timely::J2G(1, $region, $inp); # dz,dd are dummy
        if($YYYY)
          { $NUMBR = $inp; 
            $MENU = &UpdateMenu($NUMBR, $region, $INTERVAL, $regionNAME); 
            next AGAIN; 
          };
        }; 
        print "Bad Julian '$inp'\n"; 
      } 

#  - <Section 57> - 
    elsif($ch eq 'u')  # UTC to Julian
      { my ($utc) = GetUtcCode(); 
        my($n) = Timely::InternalJulian($inp, $utc, 'UTC/UTC');
      if($n)
        { $NUMBR = $n;
          $MENU = &UpdateMenu($NUMBR, $region, $INTERVAL, $regionNAME); 
          next AGAIN; 
        };
      }

#  - <Section 58> - 
    elsif($ch eq 'v')  #
      { 
        &Multitest($inp, $region); # []
      }

#  - <Section 59> - 
    elsif($ch eq 'n')  # get current time, put into $NUMBR
      { my($now) = Timely::ModTimeNow(); 
        $NUMBR = Timely::JulianFromUnix($now); # seconds 
        $MENU = &UpdateMenu($NUMBR, $region, $INTERVAL, $regionNAME); 
        next AGAIN; 
      }

#  - <Section 60> - 
     elsif($ch eq 'f' ) # inp is target
      { 
      if($inp =~ /^\s*$/ )
        { print "Current region: $region $regionNAME\n"; 
        } else
        { my($rgn, $desc, $hits) = Timely::FindRegion($inp); 
        if($hits < 1)
          { print "No match '$inp', nothing changed\n";
          } elsif($hits > 1)
          { print "Multiple ($hits) matches! Refine your specification.\n"
          } else
          { 
          if($FULLDEBUG)
            { print "Match set to '$desc', code=$rgn\n";
            }; 
            Timely::SetRegion($rgn); 
            $region = $rgn;      # 
            $regionNAME = $desc; # 
            $MENU = &UpdateMenu($NUMBR, $region, $INTERVAL, $regionNAME);
          };
        };
      } 

#  - <Section 61> - 
     elsif($ch eq 'i' ) # interval in seconds
      { 
      if($inp !~ /^\s*(\d+)$/)
        { print " Incorrect interval(seconds)\n";
        } else
        { $INTERVAL = $1;
          print " Interval set to $INTERVAL seconds\n";
        };
      } 

#  - <Section 62> - 
     elsif($ch eq 'y' ) # year : or year range
      { 
        &TestOneZone($region, $inp, $INTERVAL); # assumes MYTIMELY already set up 
      } 

#  - <Section 63> - 
     elsif($ch eq 'z' ) # year : or year range
      { 
        &ReconcileOneZone($region, $regionNAME, $inp, $INTERVAL); # 
      } 

#  - <Section 64> - 
     elsif($ch eq 'a' ) # year
      { my($txt) = &Around($region, $inp, $NUMBR); 
      if(length $txt > 0)
        { print $txt; 
        }; 
        next AGAIN; 
      }

#  - <Section 65> - 
    elsif( ($ch eq '+') 
         ||($ch eq '-') 
         )
      { my($sgn) = 1;
      if($ch eq '-')
        { $sgn = -1; 
        }; 
        my ($k) = &TimeInSeconds($sgn, $inp); # returns zero on failure. 
      if($k)
        { 
        if(abs($k) < 5000000000)
          { # print "Debug: $k $sgn " . $NUMBR . "\n" ; 
            $NUMBR += $k; 
            $MENU = &UpdateMenu($NUMBR, $region, $INTERVAL, $regionNAME);
          } else
          { print "Perhaps $k seconds is a shade too large?\n";
          }; 
        }; 
        next AGAIN;
      }

#  - <Section 66> - 
     elsif($ch eq 'l' ) # year
      { &ListLeapseconds(); 
        next AGAIN; 
      }

#  - <Section 67> - 
      else  # braces + belt. 
      { print "\n Woops! unknown command '$ch'\n";
      }; 
    };
  };
}

#  - <Section 68> - 
sub UpdateMenu # 
{ my($NUMBR, $region, $INTERVAL, $regionNAME) = @_;
  
  my($MENU) = &SetMenu($NUMBR, $region, $INTERVAL, $regionNAME, 0);
  print $MENU;
  return($MENU); 
}

#  - <Section 69> - 
sub TimeInSeconds # 
{ my($sgn, $txt) = @_;

  # also allow d[ays]
if($txt =~ /^\s*(\d+\.?\d*)\s*da?y?s?/ ) # [hack]
  { return( int($sgn * $1*86400) );
  }; 

  my($I); 
if( $txt =~ /^\s*(\d+)\s*$/ )
  { return($sgn * $1); 
  };   # [ might have magnitude checks ?]
if( $txt =~ /^\s*(\d+):(\d{2}):(\d{2})\s*$/ ) 
        # allow eg. 3:00:00 or even 12345:99:99 ! [might constrain further??] 
  { return( $sgn * ($3 + 60*$2 + 3600*$1) ); 
  };

  print "Invalid time '$txt', enter either a number or hh:mm:ss e.g. 00:40:30\n"; 
  return(0); 
}

#  - <Section 70> - 
sub ShowHelp # 
{ my($qry) = @_;

if( $qry =~ /^elp(.+)/i )  # accommodate help or HELP etc. 
  { $qry = $1; 
  }; 

  my($h); 
if( $qry =~ /^\s*(frill)/ )
  { # special 
  } 
elsif($qry !~ /^\s*([rtvwyz])/)
  { return("  Help options are  r t v w y z  &  frills. "
           . "Try:  h t  OR:  h frills\n"); # standard failure
  };
  $h = $1; 

#  - <Section 71> - 
  my($txt); 
if( $h eq 'r')
  { $txt = "Read 'raw' tz source data. Options are: \n"
         . "\n"
         . "  r all   Read, APPLY AND REWRITE the entire data set!\n"
         . "          **use with appropriate caution**\n"
         . "          (seekwell/perl/tz must contain tz source files)\n" 
         . "\n"
         . "  r       On its own 'r' reads data for the current zone alone.\n"
         . "          This is a 'fake' read---nothing is changed.\n"; 
  }
elsif( $h eq 't')
  { $txt = "Test a specific month, day and UTC time for ALL zones and years!\n"
         . "  With no parameters, this defaults to the current menu time. \n"
         . "\n"
         . "  Entered values also work e.g.   t 07-01 00:00:00 \n"
         . "  as well as the lowest year:     t 2000-07-01 00:00:00\n"
         . "  or even a RANGE of years:       t 1990 2000-07-01 00:00:00\n"
         . "  Default time, between years:    t 1990 2000\n"
         . "\n"
         . "  The process FOR EACH timestamp FOR EACH zone is:\n"
         . "    1. Use Timely to convert UTC to zone-specific Gregorian\n"
         . "    2. Also convert UTC value to local Gregorian using tz\n"
         . "    3. If they match, print '.', otherwise issue warning.\n"
         . ''; 
  }

#  - <Section 72> - 
elsif( $h eq 'v')
  { $txt = "On its own, v validates all database transition times for this zone.\n"
         . "\n"
         . "  If you want to laboriously test all zones, say:   v all\n"
         . "  You can even test transition times with an offset. \n"
         . "  Try for example:   v+1   OR   v-1 \n"
         . "  Even constructs like:   v+3600 all   will work \n"
         . "\n"
         . "  The details are interesting: the Julian transition is retrieved,\n"
         . "  and converted to Gregorian for this zone, both in Timely and tz. \n"
         . "  A warning is issued if the two don't match. Note that this is NOT\n"
         . "  a guarantee that the transition point recorded in the database is\n"
         . "  correct, merely that the two wall timestamps ultimately match.\n"
         . ''; 
  }
elsif( $h eq 'w')
  { $txt = "This is similar to 't' but instead uses wall time. \n"
         . "\n"
         . "  The same options otherwise apply. Examples are:\n"
         . "       w 01-05 00:45:00\n"
         . "       w 2000-01-05 00:45:00\n"
         . "       w 1990  2000-01-05 00:45:00\n"
         . "   etc.\n"
         . "\n"    
         . "  Given a WALL timestamp, do two things:\n"
         . "    1. Use Timely to convert to a UTC time;\n"
         . "    2. Use tz to do the same;\n"
         . "  The two can then be compared. As one wall timestamp may have \n"
         . "  two associated UTC values, tz defaults to the later time.\n"
         . "  Timely by default uses the earlier, so an adjustment is made.\n"
         . "\n"    
         . "  Errors will result for invalid wall times, for example:\n"
         . "       w 2020-09-27 02:30:00 \n" 
         . ''; 
  }

#  - <Section 73> - 
elsif( $h eq 'y')
  { $txt = "Check sequential timestamps within a given year, internally. \n"
         . "\n"
         . "  The simplest option is something like   y 2000 \n"
         . "  Year start YYYY-01-01 00:00:00 is converted to a Julian timestamp.\n"
         . "  This is then sequentially increased by increment 'i', each time: \n"
         . "    1. Convert to a Gregorian timestamp for this zone;\n"
         . "    2. Convert the Gregorian value back to Julian; and \n"
         . "    3. Compare Julian values, issuing a warning if they don't match.\n"
         . "  Dot prints every 50 validations, and newline every $PRETTYDOTS dots.\n"
         . "  \n"
         . "  An internal check with *no* external (e.g. tz) validation. See z too.\n"
         . "\n"
         . "  You can even specify a range of years e.g. y 2000 2010 as well as\n"
         . "  full timestamps along the lines of:\n"
         . "       y 2020-07-01 00:00:00  2021-06-30 23:59:59\n"
         . ''; 
  }
elsif( $h eq 'z')
  { $txt = "Like 'y', but sequential timestamps are *validated*. \n"
         . "\n"
         . "  As with 'y' you can say e.g.   z 2000   and things like: \n"
         . "      z 2020-07-01 00:00:00  2021-06-30 23:59:59\n"
         . "      z 2020  2022\n"
         . "      z 1900-06-01 00:00:00  1901\n"
         . "      z 1900  1900-01-01 23:59:59\n"
         . "  If just YYYY is specified, default is year start/end \n"
         . "\n"
         . "  The UTC start value is converted to a Julian timestamp.\n"
         . "  This is then sequentially increased by 'i', and each time: \n"
         . "    1. The UTC time derived from the Julian is converted to both a \n"
         . "       Timely wall time and a tz wall time, for this zone. \n"
         . "    2. A warning is issued if they're not the same.\n"
         . "  Print dot every 50 validations, newline every $PRETTYDOTS dots.\n"
         . ''; 
  }

#  - <Section 74> - 
elsif( $h eq 'frill')
  { $txt = "                    A few 'frills' and 'factoids': \n"
       . "  --------------------------------------------------------------------\n"
         . "\n"
         . "  NB: Z and DST offsets apply *up to* the database transition time\n"
         . "  Use  l   to list Leap seconds\n"
         . "  Use  u YYYY-MM-DD hh:mm:ss   to enter UTC timestamp, like g\n"
         . "\n"
         . "       + 1200       Add a number of seconds to menu timestamp\n"
         . "       - 60         Similarly can move earlier, here by 60 s\n"
         . "       + 23:59:59   Can also add hours, minutes and seconds\n"
         . "       + 2.5 days   Add 2.5 days \n"
         . "\n"
         . "  With f for find, add a question mark to print all the matches!\n"
         . "     ... and for an exact match try e.g.   f 'EST' \n"
         . "     ... and you can find by Timely zone ID number too, FWIW.\n"
         . "\n"
         . "  With e.g.  y 2000   any - and + signs signal testing around DST \n"
         . "  and zone transitions. With small  i  values, these can burgeon! \n"
         . "  Similarly, '>>' signals that in comparing times, the Timely \n"
         . "  value was 'adjusted up' to make it compatible with the tz one.\n"  
         . "  (With DST/Z decrements, two UTC times map to one wall time!)\n" 
         . "\n"
         . "  The topmost year with t (for Test) is one greater than that with \n"
         . "  w for Wall time because e.g. 12-31 23:59:59 may anticipate UTC \n"
         . "  by several hours in the latter case. \n"
         . ''; 
    $h = '!'; 
  }

#  - <Section 75> - 
else  # exceptional failure, won't happen without programming error above: 
  { print "\nUnknown help option: '$h'\n"; 
    return(''); # just in case. 
  }; 

  my($M) = 
    "\n  ====================-----     HELP ($h)      -----==================="
  . "\n  $txt" 
  . "\n  --------------------------------------------------------------------\n";

  print($M); 

  return(''); # success
}

#  - <Section 76> - 
sub Cls # 
{ 
if(Timely::CheckOS() eq 'Windows') # or use $OPERATING_SYSTEM [?] 
  { system 'cls'; 
  } else
  { system 'clear'; 
  };   # or simply and obscurely:   system $^O eq 'MSWin32' ? 'cls' : 'clear';
} 

#  - <Section 77> - 
sub SetMenu # 
{ my($NUMBR, $region, $INTERVAL, $placename, $welcome) = @_;
  
  my($DayNumber) = &JulianDay($NUMBR); 

  my($hi) = '     TIMELY      ';
if($welcome)
  {  $hi =  'Welcome to TIMELY'; 
  }; 

  my($utc) = Timely::Greg($NUMBR, 0, 0, 1);  # 1=GPS is ON
  my($sec) = &GpsOffset($NUMBR); 
  
 my($wall) = '?'; 
  my($gYYYY,$gM,$gD,$gh,$gm,$gs, $Z_OFF, $DST, $hog, $deltz, $delds) 
                                              # stubs ^       ^
         = Timely::J2G(1, $region, $NUMBR); # Z_OFF,DST=day parts
if($gYYYY)  
  { $wall = Timely::PrettyDate(0,$gYYYY,$gM,$gD,$gh,$gm,$gs); # cf. InternalJulian
    #print "Wall in SetMenu is $wall\n"; 
    my($yours) = Timely::FetchTzDate($NUMBR, $placename, $gYYYY, $gM, $gD, 
                                     $gh, $gm, $gs);  # 
    #print "FetchTzDate gave $yours\n"; 
    #
    $yours =~ s/T/ /; 
  if($yours eq $utc)
    { $wall .=  $TICK;
    } 
  elsif
    ( ($region != Timely::GetUtcCode() ) # don't try with UTC base 
     ## && ! $hog   ## <-- a conceit! 
    )
    { # $wall .= " (? $yours)";   # " ? $yours"; # temporary. 
      $wall .= &Colourise('?', ANSIRED); 
    }; 
  if($hog)
    {   # Esc code will be \033[31
      my($foo) = &Colourise('?', ANSIRED);  # see quotemeta below \Q \E 
    if($wall =~ /^(.*\d\d)\Q$foo\E/) 
         # if contains red '?' [hmm] AND is groundhog, consolidate to:
      { $wall = $1 . &Colourise('*', ANSIRED); # red star = 1st groundhog!
      } else
      { $wall .= '*'; 
      }; 
    }; 
  }; 

  # eye candy: extra spaces as length of placename goes from 30 down to 7
  my($filler) = Timely::Padding(' ', (30 - (length $placename))/2 ); 

  # here determine DST and Z 
  # ... 
  my($mydst) = &Tim($DST);
  my($myz) = &Tim($Z_OFF); 

#  - <Section 78> - 
  $placename = &Colourise($placename, ANSIBLUE); 

   ($region, $placename, $INTERVAL, $utc, $DayNumber, $sec, $wall, $myz, $mydst) = 
    &PrettyAll($region, $placename, $INTERVAL, $utc, $DayNumber, 
               $sec, $wall, $myz, $mydst); 

  my($M) = 
    "\n  ===================================================================="
  . "\n  ====================----- $hi -----==================="
  . "\n                $filler ($region : $placename)"
  . "\n                  q=QUIT  h=HELP r=READ  t=TEST  n=Now"
  . "\n  ------------------------------settings------------------------------"
  . "\n  f name     eg. f Auckl      Find & set region "
  . "\n  g YYYY-MM-DD hh:mm:ss       enter Gregorian wall timestamp (u=UTC)"
  . "\n  j number   eg. g 2415020.5  enter Julian GPS day number"
  . "\n  i interval eg. i $INTERVAL       set year test Interval (seconds)"
  . "\n  -------------------------------tests--------------------------------"
  . "\n  y year     eg. y 2000       test current zone, Year at interval i"
  . "\n  z year     eg. z 2000       tZ timestamp validation at interval i"
  . "\n  a year     eg. a 2000       show transitions Around year"
  . "\n  v     the lot: v all        Validate vs source, try v+1 OR v-1 too"
  . "\n  t MM-DD hh:mm:ss            Test *all* eg. t 12-31 23:59:59"
  . "\n  w MM-DD hh:mm:ss            as for t but Wall time!"
  . "\n  --------------------------------------------------------------------"
  . "\n  UTC : $utc <= GPS $DayNumber delta=$sec s"
  . "\n  Wall: $wall   Z=$myz   DST=$mydst" 
  . "\n  ====================================================================\n";
  return($M);
}

#  - <Section 79> - 
sub Tim # 
{ my($t) = @_;

  return($t/60); # just integer seconds. 
}

#  - <Section 80> - 
sub DoubleDigit # 
{ my($i) = @_;
  return(&Lead($i,2));
}

#  - <Section 81> - 
sub PrettyAll  # NB. checks length but not *order* of submitted parameters :( 
{ my(@LOTS) = @_; 

if($OPERATING_SYSTEM eq 'Windows') # [clumsy] 
  { return(@LOTS);   # just return. 
  };

  my($N) = scalar @LOTS; 
if( $N != scalar @OLDMENUVALUES )
  { die "Missing parameter for PrettyAll_(), n=" . $N ;
    return; 
  };
  my($i) = 0; 
while($i < $N)
  { $LOTS[$i] = &PrettyBold($LOTS[$i], $i); 
    $i ++; 
  }; 
  return(@LOTS); 
}

#  - <Section 82> - 
sub PrettyBold # 
{ my($new, $i) = @_; 
if( $OLDMENUVALUES[$i] ne $new )  # Global :( 
  { $OLDMENUVALUES[$i] = $new; # update 
    $new = "\033[1m" . $new . "\033[0m";  # ANSI escape (bold) ... ESC 'reset' code. 
  };
  return($new); 
}

#  - <Section 83> - 
sub Colourise # 
{ my($txt, $clr) = @_; 

  # [might check $clr is valid]

if($OPERATING_SYSTEM ne 'Windows')
  { $txt = "\033[" . $clr . "m" . $txt . "\033[0m";
  };
  return($txt); 
}

#  - <Section 84> - 
sub JulianDay # 
{ my($s) = @_;
  return($s/86400.0); 
}

#  - <Section 85> - 
sub tz_rule_save #
{ my($rule_name, $from_year, $to_year, $in, $on, $at, $dst) = @_;
 
  my($handDB) = $smalltime_h;  

  my($inonat) = "$in $on $at"; # note space separators [explore]

  my($q) = "SELECT tz_rule FROM tz_rules WHERE rule_name = '$rule_name' "
           . "AND from_year = '$from_year' "
           . "AND to_year = '$to_year' "
           . "AND in_on_at = '$inonat' ";
  my($tz_rule) = Timely::GetSQL($handDB, $q, 'find old rule');
if($tz_rule)
  { return($tz_rule); # found
  }; 

  ## ?????????????????????????/ what if the DST has changed for a rule?! 
  
  # else need to make new entry:
  ($tz_rule) = Timely::FetchKey('tz_rules', 'tz rules');
    # [here might check this succeeded..]
  my($iq) = "INSERT INTO tz_rules "
            . "(tz_rule, rule_name, from_year, to_year, in_on_at, dst) "
            . "VALUES ($tz_rule, '$rule_name', '$from_year', '$to_year', "
            .      "'$inonat', '$dst')"; 
if( ! Timely::DoSQL($handDB, $iq, 'new tz rule') )
  { die "Failed to insert new tz rule: "
        .  "$rule_name, $from_year, $to_year, $in, $on, $at, $dst";
  }; 
  return($tz_rule); 
}

#  - <Section 86> - 
sub tz_rules_inactivate_all #
{
  my($handDB) = $smalltime_h;  

  my($q) = "UPDATE tz_rules SET is_active = 0 WHERE 1"; 
if(Timely::DoSQL($handDB, $q, "reset all tz rules") < 0)
  { die "Failed to reset tz_rules";
  }; 
}

#  - <Section 87> - 
sub tz_cutoff_save #
{ my($stdoff, $rule_name, $region, $until_text) = @_;
 
  my($handDB) = $smalltime_h;  

  # unfortunately:
if(! defined $until_text)
  { $until_text = ''; 
  }; 

  my($q) = "SELECT tz_cutoff FROM tz_cutoffs WHERE stdoff='$stdoff' "
             . "AND rule_name = '$rule_name' "
             . "AND region = $region "
             . "AND until_text = '$until_text'"; 

  my($tz_cutoff) = Timely::GetSQL($handDB, $q, 'find old rule');
if($tz_cutoff)
  { return($tz_cutoff); # found
  }; 
  
  # new entry:
  ($tz_cutoff) = Timely::FetchKey('tz_cutoffs', 'tz cutoffs');
    # [here might check this succeeded..]
  my($iq) = "INSERT INTO tz_cutoffs "
            .     " (tz_cutoff, stdoff, rule_name, region, until_text) "
            . "VALUES ($tz_cutoff, '$stdoff', '$rule_name', $region, '$until_text')"; 
if( ! Timely::DoSQL($handDB, $iq, 'new tz cutoff') )
  { die "Failed to insert new tz cutoff: $stdoff, $rule_name, $region, $until_text";
  }; 
  return($tz_cutoff); 
}

#  - <Section 88> - 
sub tz_cutoff_inactivate_all #
{ 
  my($handDB) = $smalltime_h;  
  
  my($q) = "UPDATE tz_cutoffs SET is_active = 0 WHERE 1"; 
if(Timely::DoSQL($handDB, $q, "reset all cutoff rules") < 0)
  { die "Failed to reset tz_cutoffs";
  }; 

}

#  - <Section 89> - 
sub ReadZones # 
{ my($zonecode, $zonedesc) = @_;

  my($handDB) = $smalltime_h;  

 my($cUPDATE) = 0; # No. of rows updated
  my($cINSERT) = 0; # and inserts.

  tz_cutoff_inactivate_all(); 
  tz_rules_inactivate_all(); 

  my($SingleZone) = ($zonecode != 0); 

  my($zonefile) = "zone.tab";
  my($hzone); 
  open ($hzone, "$TZDIR/$zonefile") 
     or die "\n***ERROR*** Zone file '$TZDIR/$zonefile' not found, $!\n";
  my(@ZDAT) = <$hzone>;
  close($hzone);
  my($zl);
for $zl (@ZDAT)
  { chomp($zl); 
  if($zl =~ /^\s*#/ )
    { # print ' ';       # skip comment line
    } else
    { &SetZone($zl, $zonedesc); 
    };
  };

# ensure 'UTC' exists:
  my($hack) = 'UT	+000000-000000	UTC/UTC	UTC';
  &SetZone($hack, $zonedesc);

#  - <Section 90> - 
if(! $SingleZone)
  { %REZONE = reverse %ZONECODES; # reverse the hash, NB. Global! 
    my($zq) = "SELECT place FROM PLACES "
            . "WHERE p_amended between 2 and $TOPCOUNTRY AND reason > -1 ";
    my(@OLDPLACES) = Timely::SQLManySQL($handDB, $zq, 'get existing, active places'); 
    print "There are " . (scalar @OLDPLACES) . " old places\n"; 

    my($pl); # NB. this is an array reference
  for $pl (@OLDPLACES) 
    { my($ky) = @$pl[0]; 
      # print "[$ky]"; 
    if(! exists $REZONE{$ky}) # inactive
      { Timely::Warn(1, "Retiring unused zone, code $ky\n"); 
        my($kq) = "UPDATE PLACES SET reason = -2 WHERE place = $ky"; 
      if(Timely::DoSQL($handDB, $kq, "retiring $ky") < 0)
        { &Aagh("Failed to retire zone code $pl", __LINE__, 0); 
        };   # [more fancy ODBC bound statement would work better, btw] 
      }; 
    };
  }; 

#  - <Section 91> - 
my($leapfile) = "$TZDIR/leapseconds";
  print("\n Reading leap seconds from '$leapfile'"); 
  my($hleap); 
  open ($hleap, $leapfile) or die "\n***ERROR*** Could not find $leapfile, $!\n";
  my @LS = <$hleap>;
  close $hleap;

  &ReadLeapSeconds(@LS);

#  - <Section 92> - 
  my($ZN) = '';       # name of current zone
  my($INZONE) = 0;    # are we in a zone? [clumsy] 

  my @FILES = ('africa', 'antarctica', 'asia', 'australasia', 'europe', 
               'northamerica', 'southamerica');
      # at present ignore weird : factory, 'backward', 'backzone', 'etcetera'. 

foreach my $filename (@FILES)
  { print "\n\n**PARSING MYZONE FILE $filename**";
    my $path = "$TZDIR/$filename";
    open(my $fh, '<', $path) 
      or die "\nCould not open '$path' for reading: $!";
    my(@DAT) = <$fh>;
    close($fh); 

    my($ln);
  for $ln (@DAT)
    { 
    if( $ln =~ /^(.*?)\#/ )
      { $ln = $1;         # remove comment
      };
    if($ln =~ /^\s*$/ )   # empty line
      { # Timely::XPrint(0, ' ');
      }
    elsif($ln =~ /^Link/ )
      { &MakeLink($ln);
      }
    elsif($ln =~ /^Rule/ )
      { ## Timely::XPrint(0, 'R');
      if($INZONE)
        { &EndZone($ZN);
          $INZONE = 0;   # terminate
        };
        &ParseRule($ln);
      }
    elsif($ln =~ /^Zone/ )
      { ## Timely::XPrint(0, 'Z');
      if($INZONE)
        { &EndZone($ZN);
        };
        $INZONE = 1;
        $ZN = &StartZone($ln, $zonedesc); 
      }
    elsif($INZONE)   # should be Zone continuation
      { &MoreZone($ln, $ZN, $SingleZone); 
      } else 
      { # Timely::XPrint(0,  "\n?=<$ln>\n" );
      };
    };  # end of data for this file

  if($INZONE)
    { &EndZone($ZN); 
    };
    $INZONE = 0;   # as new file will follow.
  };

#  - <Section 93> - 
  # Timely::XPrint(10, "\n *** CREATING DATABASE ZONE ROWS *** ");
  print "\n Checking database zone rows: n=" . (scalar keys %ZONES); 

NAMES: foreach my $nm ( sort keys %ZONES )
  { ## start ZONE loop

    my($NM) = $nm;
    my($region) = $ZONECODES{$NM};  # clumsy but better than hack to %ZONES

  if($SingleZone)  # not 'the lot'
    { 
    if($nm ne $zonedesc)
      { next NAMES;
      }; 
      print "\nParsing: $nm ($region) $LOWYEAR .. $TOPYEAR\n"; 
    }; 

  if( $NM eq 'UTC/UTC')         # [explore this special case] 
    { next NAMES;
    }; 

    ## Timely::XPrint(10,  "\n Zone=$nm" );

#  - <Section 94> - 
    my($qz) = "SELECT cast(north as char(13)) FROM PLACES "
              . "where place = $region AND reason > -1";
    my($north) = Timely::GetSQL($handDB, $qz, 'get north/south for zone'); 
  if(! defined $north)
    { Timely::XPrint(0,  "\n*ERROR* Bad zone for $nm($region) <$qz>" ); 
      next NAMES; # [check this branch]
    };
    my($rA) = $ZONES{$NM};
  if( ref($rA) ne 'ARRAY' )
    { 
    if(! defined $LINKS{$NM} )
       { &TimeWarn( "No zone definition for '$NM' : " . ref($rA) ,1, $NM, 0);
         # retire this zone in fehr:
         my($qx) = "UPDATE PLACES SET reason = -1 WHERE place = $region"; 
       if( Timely::DoSQL($handDB, $qx, 'retire region') < 0)
         { &Aagh("Failed to suppress region ($qx)", __LINE__, 0 ); 
         }; 
         next NAMES;  # next iteration of foreach loop 
       };
      print "\nLink: $NM -->" . $LINKS{$NM}; 
      $NM = $LINKS{$NM};
      $rA = $ZONES{$NM};  # Fails if double indirection or read single *linked* name!
    if(! defined $rA)
      { return(". I couldn't resolve this!\nRepeat  v  after saying:   f $NM \n");
      }; 
    };
    my(@A) = @$rA; # array of zone information rows 
    my($v);

  foreach $v (@A)
    { &DebugZone($v, $SingleZone); 
    };


#  - <Section 95> - 
  # Calculate each database row over the full range of years, and write to database
    my($year) = $LOWYEAR;
    my($DSTCARRY) = 0;
    my($LASTTRAN) = 0; # most recent transition
    my($ZONEBASE) = 0; # basis for year start calculation by ZoneYear!
  while($year <= $TOPYEAR+1)  # take one year above!
    { ($ZONEBASE, $DSTCARRY) 
         = &ZoneYear($SingleZone, $nm, $year, $ZONEBASE, $north, $DSTCARRY, @A);
      # NB. values in $ZONEBASE, $DSTCARRY are in seconds. 

#  - <Section 96> - 
      $year ++;  # bump
    };

#  - <Section 97> - 
  };  ## end of ZONE loop
  return(''); 
}  ## END OF ReadZones ROUTINE. 

#  - <Section 98> - 
sub ReadLeapSeconds # 
{ my(@LS) = @_;
  my($leap);
  my($BASELEAP) = -9;  # at baseline GPS is 9s before UTC, UTC generally slows
  my($itop) = scalar @LEAPDATA; 
  my($ok) = 1;
  Timely::Log("\n  Debug LEAP DATA length = $itop");

for $leap (@LS)
  { 
  if($leap =~ /^(.*?)#/)
    { $leap = $1;
    };
  if($leap !~ /^\w*$/ ) # if non-empty, not just whitespace
    { 
    if($leap !~ /Leap\s+(\d{4})\s(\w{3})\s(\d{2})\s(\d{2}):(\d{2}):(\d{2})\s([-+])\sS/)
                         #YYYY    MMM      DD        hh       mm     ss      +   S
      { die "\n***ERROR*** Unknown leap line: <$leap>\n";
        return;
      };
      $itop --; # move to corresponding data row;
      my($d) = $LEAPDATA[$itop]; 
      my(@D) = @$d; # dereference
      my($utc) = $D[1]/1000000.0;  # seconds
      my($off) = $D[2];
      my($YYYY, $MMM, $DD, $hh, $mm, $ss, $updn) = ($1, $2, $3, $4, $5, $6, $7);
    if($ss != 60)
      { die "\n***ERROR*** Odd leap line: $YYYY $MMM $DD $hh $mm *$ss* $updn";
        return;
      };
    if($updn ne '+')
      { $BASELEAP --;
        die "\n***ERROR*** I can't handle '-' value in leap line";  # [explore, fix]
        return; # need to check handling before use, if this ever happens. 
      } else
      { $BASELEAP ++; # Applies to times between $bigJ and the next cut. 
      };
    if($BASELEAP != $off)
      { die "\n***ERROR*** mismatched leap seconds: $BASELEAP/$off";
        return;
      };
      my($Mon) = &FetchMonth($MMM);  # e.g. Jan->1
      my($bigJ) = Timely::ToJulian($YYYY, $Mon, $DD, $hh, $mm, $ss, 0, 0, 0); 
               # NOT GpsJulian ; and potential 60s value in $ss
    if( abs($bigJ - $utc) > 0.01 ) # if difference is more than 10 ms:
      { my($COOKED) = Timely::Greg($utc, 0, 0, 0); # utc is in seconds [explore] 
        Timely::XPrint(0, "\n*ERROR* bad leap timestamp: $bigJ, "
                 . "$utc ($YYYY-$Mon-$DD $hh:$mm:$ss | $COOKED)" );
        $ok = 0;
      };
    };
  };
if(! $ok)
  { die "\n***ERROR*** Error in leap seconds";
  };
}

#  - <Section 99> - 
sub PopulateLeapSeconds # 
{ my($TZDIR) = @_;

  my($handDB) = $smalltime_h;  # CLUMSY 

  my($leapfile) = "$TZDIR/leapseconds";
  print("\n Populating leap seconds from '$leapfile'"); 
  my($hleap); 
  open ($hleap, $leapfile) or die "\n***ERROR*** No leap seconds source: $leapfile, $!\n";
  my @LS = <$hleap>;
  close($hleap);

  my($leap);
  my($BASELEAP) = -9;  # Baseline GPS time is 9s before UTC, UTC generally slows
  my($leapsecond) = 0; 

for $leap (@LS)
  { 
  if($leap =~ /^(.*?)#/)
    { $leap = $1;
    };
  if($leap !~ /^\w*$/ ) # if non-empty, not just whitespace
    { 
    if($leap !~ /Leap\s+(\d{4})\s(\w{3})\s(\d{2})\s(\d{2}):(\d{2}):(\d{2})\s([-+])\sS/)
                        #YYYY    MMM      DD        hh       mm     ss      +   S
      { die "\n***ERROR*** Unknown leap line: <$leap>\n";
        return;
      };
      my($YYYY, $MMM, $DD, $hh, $mm, $ss, $updn) = ($1, $2, $3, $4, $5, $6, $7);
    if($ss != 60)
      { die "\n***ERROR*** Unusual leap entry: $YYYY $MMM $DD $hh $mm *$ss* $updn";
        return;
      };
    if($updn ne '+')
      { $BASELEAP --;
      } else
      { $BASELEAP ++; # This applies to times between $bigJ and the next cut. 
      };
      my($Mon) = &FetchMonth($MMM);  # e.g. Jan->1
      my($bigJ) = Timely::ToJulian($YYYY, $Mon, $DD, $hh, $mm, $ss, 0, 0, 0); # NOT GpsJulian
               # also take note of the 60s value in $ss. This could be 61 !
      my($gps)= $bigJ+$BASELEAP;     # to get gps, add offset to UTC value
      my($q) = "INSERT INTO leapseconds (leapsecond, gpstime, utctime, toffset)"
     . " VALUES ($leapsecond, $gps*1000000, $bigJ*1000000, $BASELEAP)"; 
      # multiply seconds by 10^6 to get stored microseconds. 
    if( Timely::DoSQL($handDB, $q, 'insert leapsecond row entry') < 0)
      { &Aagh("Failed to insert leapsecond row ($q)", __LINE__, 0 ); 
        return;
      }; 
        # [ideally check entry not already present, and check for success[explore]]
      $leapsecond ++;
    };
  };
}

#  - <Section 100> - 
sub GpsOffset
{ my($J);
    ($J)=@_;

  my($Ltop) = scalar @LEAPDATA; 
  my($i) = 0;
while($i < $Ltop)
  { my($d) = $LEAPDATA[$i];
    my(@D) = @$d; # dereference 
  if( $J >= ($D[0]/1000000.0) )  # note 0 index [check inequality for consistency ?]
    { return($D[2]);     # offset in seconds
    };
    $i ++;
  };
  return(-9);  # earliest value is a lag. 
}

#  - <Section 101> - 
sub SetZone # 
{ my($zl, $zonedesc) = @_;
 
  my(@ZD) = split /\s+/, $zl;
  my($cc) = $ZD[0];
  my($rawcoords) = $ZD[1];
  my($zonename) = $ZD[2];

if(length $zonedesc > 0)
  {
  if($zonedesc ne $zonename) # if single zone and doesn't match:
    { return(''); # ignore
    }; 
    print " [Setting zone $zonedesc: '$zl'] "; 
  };

  # Timely::Log("\nSetting zone: <$zl>=<$cc><$rawcoords><$zonename>");
if(length $cc != 2)
  { die "\n***ERROR*** Bad 2-char country code: $cc\n";
    return;
  };
if($rawcoords !~ /([+-])(\d+)([+-])(\d+)/ )
  { die "\n***ERROR*** Bad coordinates for $cc: $rawcoords";
  };
  my($sN)   = $1;    # sign
  my($rawN) = $2;
  my($sE)   = $3;
  my($rawE) = $4;
  my($North) = &NEncode($sN, $rawN);
  my($East) = &NEncode($sE, $rawE);
  my($ZID) = &FetchCountryCode($cc);
if($ZID < 0)
  { die "\n***ERROR*** Country code not found: $cc\n";
  };
  &SaveZone($zonename, $ZID, $North, $East); # $ZID is country
  return($zonename); 
}

#  - <Section 102> - 
sub NEncode # 
{ my($sgn, $vlu) = @_;
  my($vlen) = length $vlu;
  # Perl 5.24 seems to have issues with $1 $2 $3 in the following ?? 
  my($deg, $min, $sec); 

if($vlen == 4)
  { $vlu =~ /(\d{2})(\d{2})(.*)/;
   # print "(Debug $1:$2:$3)"; 
    ($deg,$min,$sec) = ($1,$2,$3);
  }
elsif($vlen == 5)
  { $vlu =~ /(\d{2})(\d{3})(.*)/;
   # print "(Debug $1:$2:$3)"; 
    ($deg,$min,$sec) = ($1,$2,$3);
  }
elsif($vlen == 6)
  { $vlu =~ /(\d{2})(\d{2})(\d{2})/;
   # print "(Debug $1:$2:$3)"; 
    ($deg,$min,$sec) = ($1,$2,$3);
  }
elsif($vlen == 7)
  { $vlu =~ /(\d{3})(\d{2})(\d{2})/;
   # print "(Debug $1:$2:$3)"; 
    ($deg,$min,$sec) = ($1,$2,$3);
  } else 
  { die "\n***ERROR*** Bad degree code: $sgn $vlu";
           return;
  };
 # print "(!!Debug $1:$2:$3!!)"; 
 # my($deg) = $1;
 # my($min) = $2;
 # my($sec) = $3;
if(length $sec == 0)  # ?? can it be undefined
  { $sec = 0; 
  };
   # Timely::XPrint(0, "<Encoding '$vlu'($vlen) '$deg:$min:$sec'>"); 
  my($enc) = 100187903*($deg + $min/60 + $sec/3600)/9;
if($sgn eq '-')
  { $enc = -($enc);                  # use sign, ignore '+' value [? check]
  };
  my($ienc) = sprintf "%.0f", $enc;  # round half to even 
  return($ienc);                     # integer value  
}

#  - <Section 103> - 
sub FetchCountryCode #
{ my($cc) = @_;

  my($handDB) = $smalltime_h;  

  my($q) = "SELECT country FROM countrycodes WHERE ccode='$cc'";
  my($DBcode) = Timely::GetSQL($handDB, $q, 'get country code'); 
if(length $DBcode == 0)
  { return(-1);             # invalid
  };
  return($DBcode); 
}

#  - <Section 104> - 
sub SaveZone # 
{ my($zonename, $COUNTRY, $North, $East) = @_;

  my($handDB) = $smalltime_h;  

  my($q) = "SELECT place, reason FROM PLACES "
    . "WHERE p_amended = $COUNTRY AND description = '$zonename'"; 
    # might get away with just description but rather check country too. 
  my($zcode, $reason) = Timely::GetSQL($handDB, $q, 'find zone'); 

if( (defined $zcode) 
  &&(length $zcode > 0)
  )
  { Timely::Log("\n  Zone ($COUNTRY:$zonename) found='$zcode'"); 
  if($reason < 0) # [this option may need checking]
    { Timely::XPrint(0, "\n\n*Warning* : zone is retired: '$zonename'\n"); 
      return(0);  
    }; 

    $ZONES{$zonename} = 1; # for later
    $ZONECODES{$zonename} = $zcode;
    return(0);  # return value is unused at present 
  };  

  my($newzone) = Timely::FetchKey('PLACES', 'new zone code'); 
  Timely::Log("\nInserting new zone: $newzone=$COUNTRY/$zonename, N=$North E=$East");
  my($qw) = "INSERT INTO PLACES "
   . "(place, east, north, description, p_amended, t_amended, reason, "
   .    "amender, src, chk)"
   . " VALUES "
   . "($newzone, $East, $North, '$zonename', $COUNTRY, 0, 0, "
   .    "$USERID, $TZDATABASEID, 0)"; # no chk yet. 
  my($ok) = Timely::DoSQL($handDB, $qw, 'make new zone'); 
if($ok != 1)
  { &Aagh( "\nFailed to insert zone '$zonename' id=$newzone; $!\n", __LINE__, 0);
    return(0); 
  };
  $ZONES{$zonename} = 1;   # stub for later
  $ZONECODES{$zonename} = $newzone;
  return(1); # new zone created
}

#  - <Section 105> - 
sub DebugZone # 
{ my($v, $SingleZone) = @_;
  my(@V) = @$v;
  my($GMTOFF) = $V[0]; # Z in seconds
  my($RULE)  = $V[1];
    my($YYYY)  = $V[2];
    my($MM)    = $V[3];
    my($DD)    = $V[4];
    my($hh)    = $V[5];
    my($mm)    = $V[6];
    my($FORMAT)= $V[7];  
    my($J)     = $V[8]; # Julian seconds 
  my($UNTIL) = "$YYYY $MM $DD $hh $mm";
  my($RU);

  my($err) = 0; 

if($RULE eq '-')
  { $RU = '<>';
  }
elsif(defined $RULES{$RULE})
  {  $RU = '@' . $RULE;  
  }
elsif( $RULE =~ /^\d+:\d+/ )
  { $RU = "off=$RULE";
  } else
  { $RU = " -?- ($RULE) ";
    $err = 1;
  };

if($SingleZone)
  { print "zone rule: $GMTOFF $RU: $UNTIL $FORMAT $J\n"; 
  }; 

  Timely::Log( "\n   $FORMAT '$GMTOFF' $RU --> '$UNTIL'/$J" );  
    # cf. below: my(@V) = ($GMTOFF, $RULES, $UNTIL);
}

#  - <Section 106> - 
sub MakeLink # 
{ my($rw) = @_;
if( $rw !~ /Link\s(\w+\/\w+)\s(\w+\/\w+)/ )
  { die "\n***ERROR*** Bad link <$rw>";
    return;
  };
  $LINKS{$2} = $1;
  Timely::Log( "( $2-->$1 )" );
}

#  - <Section 107> - 
sub ZoneYear # 
{ my($SingleZone, $nm, $year, $ZONEBASE, $north, $DSTCARRY, @A) = @_;

  Timely::Log( "\n\n** Processing $nm $year (z=" . &Tim($ZONEBASE) . '|d=' 
        . &Tim($DSTCARRY) . "):" );  # nasty
    my($LASTZO) = $ZONEBASE; 

  my($LASTTRAN) = 0; 
if($SingleZone)
  { print "\n$year: "; 
  }; 

  # 'start/end of the year' won't accord with UTC start unless zone offset=0. Adjust:
  my($YearBot) = Timely::GpsJulian($year,  1,  1,  0,  0,  0, 0, $ZONEBASE, $DSTCARRY);
  my($YearTop) = Timely::GpsJulian($year, 12, 31, 23, 59, 59, 0, $ZONEBASE, $DSTCARRY); 
              #                            ^ 1 second taken off "just in case" 
              # BUT NOTE that DST may well change for the latter, as may the zone!
  &StartStorage($nm, $year);
   # NB final 2 values submitted to GpsJulian_() are seconds
  ##&Debug(0, ' from ' . &Dat($YearBot) . ' to ' . &Dat($YearTop) ); 

#  - <Section 108> - 
  my($FORMAT);                 # although retrieved, this variable is not used
  my($Jtrans);                   # transition (cutoff) time as Julian
  my($LAST_ZO) = 0;            # [???]
  my($CURRENT_ZO) = $ZONEBASE; # [horrendous, redundant mess]
  my($TOPPED) = 0;             # =1 means "value in $CURRENT_ZO is now final" 

#  - <Section 109> - 
  my($v);
  my($DONE) = 0; 
  my($PENDING_START) = 0;
  my($BETWEEN) = 0;
  my($RUNNING_DST) = $DSTCARRY;  # [another ugly monster]
  #&Debug(0, "\nrunDST1=" . &Tim($RUNNING_DST) );
  my($zod);

#  - <Section 110> - 
NEXTZONE: foreach $v (@A)  # Usually ONE zone specification applies to a year
                    #   but tricky with transitions: the specification (e.g. rule)
                    #   for the NEXT year applies after the transition!
  { my(@V) = @$v;   #  Each 'rule' in turn contains sub-rules, $v a reference 
    my($GMTOFF)= $V[0];  # the zone offset applies UP TO the transition, in seconds
    my($RULE)  = $V[1];
    my($YYYY)  = $V[2];  # the year alone is supplied to ApplyRule 

    my($MM)    = $V[3];    # These values all redundant but debugging...
    my($DD)    = $V[4];    #
    my($h)     = $V[5];    #
    my($m)     = $V[6];    # # end redundant.

    $FORMAT    = $V[7]; # the standard 8 variables
    my($Jraw)  = $V[8]; # Julian day for the above YYYY-MM-DD etc. 
    my($sufx)  = $V[9]; # suffix for this date, added belatedly [D'Oh]
   my($tz_cutoff) = $V[10]; # added for source debugging
    $zod = 1;
    $Jtrans = &FixBySuffix($sufx, $Jraw, $GMTOFF, $RUNNING_DST); 
    $LASTZO = $GMTOFF;   # retain zone offset used to determine Jtrans
      # As per the suffix, convert time based on current zone offset and 
      #    on current daylight saving ($dst)
      # NB. Latter more complex based as may be subsequent
      #    DST transitions in the rules themselves. 
      # $DSTCARRY may be adjusted below, for the next round of NEXTZONE.
    $Jtrans = Timely::ApplyGps($Jtrans); # adjust to GPS time!
    ($CURRENT_ZO, $TOPPED) = 
         &TryZone($GMTOFF, $Jtrans, $YearBot, $YearTop, $CURRENT_ZO, $TOPPED);

#  - <Section 111> - 
    my($oktm);
  if($YearBot > $Jtrans)    # NOT >= cf Asia/Khandyga 2004
    { #&Debug(0, "skip ROW, " . &Dat($YearBot) . " > " . &Dat($Jtrans)  );
    if($SingleZone)
      { print '^ '; 
      }; 
      next NEXTZONE;
    }

#  - <Section 112> - 
  elsif($RULE eq '-')
    { $RUNNING_DST = 0;   # applies until the transition, whenever it is
    if($SingleZone)
      { print '- '; 
      }; 
    if($Jtrans < $YearTop)
      { $Jtrans = Timely::ApplyGps( &FixBySuffix($sufx, $Jraw, $GMTOFF, $RUNNING_DST) ); 
           # DST changed, but retroactive
      if( &Store($LASTTRAN, $Jtrans, $RUNNING_DST, $CURRENT_ZO, $sufx, 
                 DASHRULE, 0, $SingleZone) )
        { #&Debug(0, "\nrunDST2=0" );
          $LASTTRAN = $Jtrans;
        }; 
      } else       # if at or after year top
      { last NEXTZONE;  
      };
    }

#  - <Section 113> - 
  elsif($RULE =~ /\d+:\d+/)   # value applies UP TO $Jtrans
    { $RUNNING_DST = &FixTime($RULE);   # new DST offset in seconds
      $Jtrans = Timely::ApplyGps( &FixBySuffix($sufx, $Jraw, $GMTOFF, $RUNNING_DST) );
         # DST changed, but retroactive [check this, it works] 

    if($SingleZone)
      { print ': '; 
      }; 

    if($Jtrans < $YearTop)
      { 
      if( &Store($LASTTRAN, $Jtrans, $RUNNING_DST, $CURRENT_ZO, $sufx, 
                 FIXEDDST, 0, $SingleZone) )
        { #&Debug(0, "\nrunDST3=0" );
          $LASTTRAN = $Jtrans;
        }; 
      } else       # if at or after year top
      { last NEXTZONE;  
      };
    }

#  - <Section 114> - 
  elsif($Jtrans > $YearTop) # if rule "just applies":
    { 
    if($SingleZone)
      { print '> '; 
      }; 
      ($oktm, $RUNNING_DST) 
         = &ApplyRule($nm, $year, $RULE, $RUNNING_DST, 0, $LASTTRAN, 
                      $CURRENT_ZO, $LASTZO, $SingleZone);
          # no transition
       #&Debug(0, "\nrunDST5=" . &Tim($RUNNING_DST) ); 
       last NEXTZONE;
    } 

#  - <Section 115> - 
  else                  # more interesting, as CURRENT transition is present:
    { 
    if($SingleZone)
      { print '? '; 
      }; 
      ($oktm, $RUNNING_DST) # [ *** EXPLORE AND FIX THIS NASTY HACK *** ]
         = &ApplyRule($nm, $year, $RULE, $RUNNING_DST, $Jtrans, $LASTTRAN, 
                      $CURRENT_ZO, $LASTZO, $SingleZone); 
       #&Debug(0, "\nrunDST6=" . &Tim($RUNNING_DST) );
       # KNOW  $Jtrans < $YearTop
     # a catch if rule already set AFTER $Jtrans:
    if($Jtrans > $oktm)
      { #&Debug(0, ' ===unfulfilled=== ' ); 
        $Jtrans = Timely::ApplyGps( &FixBySuffix($sufx, $Jraw, 
                             $GMTOFF, $RUNNING_DST) ); # DST changed? 
        ##
      if( &Store($LASTTRAN, $Jtrans, $RUNNING_DST, $CURRENT_ZO, $sufx, 
                 FIXEDDZ, 0, $SingleZone) )
        { $LASTTRAN = $Jtrans;
        } else
        { # [debug statement will appear within &Store] 
        }; 
      } else 
      { # #&Debug(0, "\n --********skipped********-- as " . &Tim($Jtrans) 
        #       . ' < ' . &Tim($oktm) ); 
        $LASTTRAN = $oktm;
      };
    };

#  - <Section 116> - 
  };   # End of NEXTZONE loop. 

#  - <Section 117> - 
  $YearTop = Timely::GpsJulian($year, 12, 31, 23, 59, 59, 0, $CURRENT_ZO, $RUNNING_DST); 
  &FinalStore($nm, $year, $YearBot, $YearTop, $RUNNING_DST, 
              $CURRENT_ZO, $LASTTRAN, $SingleZone);

#  - <Section 118> - 
  return($CURRENT_ZO, $RUNNING_DST); 
}

#  - <Section 119> - 
sub StartStorage
{ my($zone, $year); 
    ($zone, $year) =@_; 

  @STORAGE = ();  # clear storage
}

#  - <Section 120> - 
sub Store # 
{ my($LASTTRAN, $tran, $dst, $zoff, $mod, $type, $term, $SingleZone); 
    ($LASTTRAN, $tran, $dst, $zoff, $mod, $type, $term, $SingleZone) =@_;

  #&Debug(0, "\n    ==>STORE " . &Dat($tran) . ' d=' . &Tim($dst) . ' z=' 
  #      . &Tim($zoff) . " $mod/$type" ); 

if($tran < $LASTTRAN)
  { Timely::Warn(0, "Antecedent rule compensation: " . &JulianDay($tran) 
           . " " . &JulianDay($LASTTRAN) . " " . &Dat($tran) 
           . ' < ' . &Dat($LASTTRAN) ); 
    return(0); # no! 
  }; 

  ## We now store *seconds* in first three values in @STORAGE rows: 
  my @INS = ($tran, $dst, $zoff, $mod, $type, $term);  # array to insert
  my($off) = scalar @STORAGE; # get size of @STORAGE
  my($more) = 1; 
while(  $more
      &&($off >= 1)
     )
  { $off --;
    my($v) = $STORAGE[$off]; # get top
    my($t, $d, $z) = @$v;
  if($tran >= $t) # IF the same (=) then insert above current
    { $more = 0; # terminate, the usual behaviour
      $off ++;   # will insert ABOVE current element
    };
  };
  splice @STORAGE, $off, 0, \@INS;  # if $off is zero, inserts at start
  return($tran);
}

#  - <Section 121> - 
sub FinalStore # 
{ my($zone, $year, $YearBot, $YearTop, $CURRENT_DST, $CURRENT_ZO, 
     $LASTTRAN, $SingleZone); 
    ($zone, $year, $YearBot, $YearTop, $CURRENT_DST, $CURRENT_ZO, 
     $LASTTRAN, $SingleZone) =@_; 

  my($handDB) = $smalltime_h;  

if($SingleZone)
  { print "\n  (.)"; 
  }; 

if($LASTTRAN > $YearTop)
  { $YearTop = $LASTTRAN + 1; # +1 second, always above most recent 'true' row
  };

  &Store($LASTTRAN, $YearTop, $CURRENT_DST, $CURRENT_ZO, '', FINALRULE, 
         1, $SingleZone);  # cap entries, discard return value
  # the above will succeed, NB. assures >= one entry per zone per year!
 
if($SingleZone)
  { print "\n[n = " . (scalar @STORAGE) . '] '; 
  }; 

#  - <Section 122> - 
  my($region) = $ZONECODES{$zone};

if(! $SingleZone)  # do NOT alter SQL if single zone: 
  { my($qdel) = "DELETE FROM timely WHERE region = $region AND year = $year";
  if( Timely::DoSQL($handDB, $qdel, 'delete old entries') < 0)
    { &Aagh("Failed to delete old entries ($qdel)", __LINE__, 0);
      return; 
    }; 
  }; 

#  - <Section 123> - 
  my($ins);
  my($kept_tran, $kept_dst, $kept_zoff)=(0,0,0);
foreach $ins (@STORAGE)
  { my($tran, $dst, $zoff, $mod, $type, $IGNORED) = @$ins;   # retrieve stored values 
    # Retrieved values for $tran, $dst, $zoff are in *seconds*

    # Sort out the 'Aqtau' issue:
    my($deltaz) = $zoff - $kept_zoff; 
  if( &CloseEnough($tran + $deltaz, $kept_tran) ) # [smarter than == ]
    { # Once adjusted for zone offset change, we have a collision: 
      $tran = $kept_tran; 
    }; 
    # end 'Aqtau'. 

    my($isdup) = ( ($kept_tran == $tran)
               &&($kept_dst == $dst)
               &&($kept_zoff == $zoff)
               ); 
  if($isdup)
    { Timely::XPrint( 0, "\n  Redundant tz entry $year: (" . &JulianDay($tran) 
                . ") (d=" . &Tim($dst) . ';z=' . &Tim($zoff) . ") zone=$zone, " 
                . &JulianDay($YearBot) . " -- " . &JulianDay($YearTop) 
                . ' dst max=' . &Tim(MAXDST) . ' z max=' . &Tim(MAXZOFF) ); 
    }
  elsif( ($tran < $YearBot)
        ||($tran > $YearTop)
 ##     ||($dst < 0)  ## NO! $dst can be < 0 [explore in detail 4/12/2020] 
        ||( abs($zoff) > MAXZOFF) # [ideally need test rtn]
        ||( $dst > MAXDST)        # [likewise]
       )
    { Timely::XPrint(0, "\n       *DEFECTIVE* timely entry suppressed: " 
        . ' d=' . &Tim($dst) . ' max=' . &Tim(MAXDST) 
        . ' z=' . &Tim($zoff) . ' max=' . &Tim(MAXZOFF)
        . " $mod/$type> ");    # [consider forcing an error]
    } else # not defective: 

#  - <Section 124> - 
    { ($kept_tran, $kept_dst, $kept_zoff) = ($tran, $dst, $zoff); 
      my($HTRAN)= &MegaDate($tran); # convert to big integer, from 'Julian day' value
      my($HDST) = &MegaDate($dst);
      my($HZOFF)= &MegaDate($zoff);
       
    if($SingleZone)
      { print " !" . &JulianDay($tran) . "(" . &Dat($tran) . ') d=' . &Tim($dst) 
            . ' z=' . &Tim($zoff) . " $mod/$type" ;
      } else  # currently do NOT alter SQL if single zone: 
      { 
        my($qq) = "SELECT zone_offset, dst FROM timely " 
                . "WHERE region=$region and transition=$HTRAN"; 
          ## Do *not* include year, allows duplicate transitions at year borders
          ## . "WHERE region=$region and year=$year and transition=$HTRAN";
        my($oz, $od) = Timely::GetSQL($handDB, $qq, 'ensure no duplicate');
        # NB. these values are microseconds. 

      if(defined $oz)
        { my($HOZ) = Timely::HugeToJ($oz);
          my($HOD) = Timely::HugeToJ($od); # convert to Julian fragment 
        if(  &CloseEnough($HOZ, $zoff)
          && &CloseEnough($HOD, $dst)
          ) ## if concordant 
          { &TimeWarn('Duplicate timely entry (' . &Tim($zoff) . ', ' 
                    . &Tim($dst) . ") " ## . "as <$qq>"  
            . &Tim( Timely::HugeToJ($oz) ) . ', ' . &Tim( Timely::HugeToJ($od) ),   
                    55, $zone, $year);
          } else # discordant
          { Timely::XPrint(0, "\nIGNORED discord: Z=" . &Tim($zoff) . ' ' . &Tim($HOZ) 
                    . '; DST=' . &Tim($dst) . ' ' . &Tim($HOD) 
                    . "; zone=$REZONE{$region} ($region), transition=" . &Dat($tran) 
                  );
           # These do not impact on existing transitions. Do NOT translate/amend! 
          }; 
        } else # not duplicate 
        { my($tkey) = Timely::FetchKey('timely', 'timely code'); 
          my($qi) = "INSERT INTO timely (timekey, region, year, transition, " 
                   . "zone_offset, dst, ignored)"
           . "VALUES ($tkey, $region, $year, $HTRAN, $HZOFF, $HDST, $IGNORED)"; 
           # [? ver, chk] 
        if( Timely::DoSQL($handDB, $qi, 'insert row') < 0)
          { &Aagh("failed to insert row ($qi)", __LINE__, 0); 
            return;
          };
        }; # end else (not duplicate) 
      };  # end else (not single zone) 
       
    };  # end else (not defective)
  };  # end foreach
}

#  - <Section 125> - 
sub CloseEnough # 
{ my($J, $K) = @_;
  return( abs($J-$K) < EPSILONSECONDS ); 
}

#  - <Section 126> - 
sub MegaDate #
{ my($d);
    ($d)=@_;
if(! defined $d)
  {  # [warn here?]
    return(0);
  };
if( length($d) < 2)   # '0' will match, as will ''
  { # [warn here?] 
    return(0);
  };

if ($d !~ /^-?\d+\.?\d*$/ ) # at present don't allow leading/trailing space. 
   { Timely::XPrint(0, "\nBad number for Julian day in seconds '$d'");  # [? &Aagh_()]
     &LogError("Bad number for Julian day '$d'"); # [Who will read the log?] 
     return(0); 
   };
  
  return($d*1000000); # KISS. 
}

#  - <Section 127> - 
sub TryZone # 
{ my($GMTOFF, $j, $lo, $hi, $ZO, $TOPPED) = @_;

if($j >= $lo && $j < $hi)
  { #&Debug(0, "\n==> ZO changed from " . &Tim($ZO) . " to " . &Tim($GMTOFF));
    return($GMTOFF, 0); 
  };
if( ($j < $lo)
  || $TOPPED
  )
  { #&Debug(0, "\n==> ZO left at " . &Tim($ZO) );
    return($ZO, $TOPPED); 
  };
  ## if $TOPPED NOT set AND $j >= $hi
    #&Debug(0, "\n==> ZO finalised from " . &Tim($ZO) . " to " . &Tim($GMTOFF) );
  return($GMTOFF, 1);
}

#  - <Section 128> - 
sub Between # 
{ my($zone_transition, $j, $lo, $hi) = @_;
if($j >= $lo && $j < $hi)
  { 
    #&Debug(0, '<yes>');
    return($j); 
  };
  #&Debug(0, '<no>');
  return($zone_transition);
}

#  - <Section 129> - 
sub ApplyRule # 
    # [the utility of the $LASTZO parameter seems doubtful: check me!]
{ my($zone, $yr, $rnam, $DSTCARRY, $zone_transition, $LASTTRAN, $CURRENT_ZO, 
     $LASTZO, $SingleZone) = @_;

if($SingleZone)
  { print "[$rnam] ";
  }; 
  my($zoneinfo) = "$zone|$yr|$rnam"; 

  my($RUNNING_DST) = $DSTCARRY;
  my($STOREDOK) = 0; 
  my($DELTA_Z) = $CURRENT_ZO - $LASTZO;  # find any change in zone offset
      #  from when original timestamp was determined. Must subtract from original 
    my($dst_defer_start, $dst_defer_offset, $dst_defer_T) = (0,0,0); # see below

#  - <Section 130> - 
  my($rv) = $RULES{$rnam};  # assume exists
if( ref($rv) ne "ARRAY" )
    { Timely::XPrint(0,  "\n ERROR ***Bad definition*** for rule $rnam: ($yr) " 
            . ref($rv) ) ;
      return(0,$RUNNING_DST);
    };
  my(@R) = @$rv;    # dereference    
  my($r);

  my(%OFFSET) = (); # will associate timestamp with offset!
  my(%SUFFIX) = (); # used for TZ suffixes associated with a timestamp
  my(%CURRENT)= (); # only true if $yr WITHIN RANGE of specified rule, default false
  my(%IDS) = (); # for rule IDs
  # [explore zone time change/DST change alters timestamp order once suffix applied!?]
  # [this is theoretical rather than a concern]

  # an optimisation [see usage]:
  my($CARRYOVER) = 0;     # value is Julian seconds. 
  my($CARRYsuffix) = '';
  my($CARRYsave) = '';
  my($CARRYid) = ''; 

#  - <Section 131> - 
for $r (@R)
  { my($FROM, $TO, $IN, $ON, $AT, $SAVE, $tz_rule) = @$r;
    my($RULETEXT) = "\n  Testing rule[$tz_rule]: " 
                  . "$FROM, $TO, $IN, $ON, $AT, $SAVE-->"; # debug only
    my($VALID) = 1; # default to 'ok' for each rule. 

  if($SingleZone)
    { # Timely::XPrint( 0, "($RULETEXT" );
      Timely::XPrint(0, '(' ); 
    }; 

  if($yr < $FROM)  # if year of interest is BEFORE the FROM of the rule
    { #&Debug(0, "\n  --skip $rnam ($FROM)" );   # cannot apply here.
    } else
    {
    if($SingleZone)
      { # print ",";  # [hmm, needs refining]
      }; 
    if( ( ($TO eq 'only')  # if precisely the year of interest
        &&($yr == $FROM)
        )
      ||($TO eq 'max')     # OR all years
      ||( ($TO ne 'only')  # OR year of interest is in the range
        &&($yr <= $TO)
        )
      )
      { my($ts, $sfx) = &FixRuleDate($yr, $IN, $ON, $AT, $zoneinfo); # NO GPS-adjust
      if($ts == 0) # often just a date excursion: 
        { Timely::XPrint(0, " Skipped rule[a]: $FROM, $TO, $IN, $ON, $AT, $SAVE "
                   . "in zone $zone : $yr, $rnam");
          # return(0,0);
          $VALID = 0; # prevent creation of rule..
        }; 
      if($VALID)
        { $OFFSET{$ts} = $SAVE;  # timestamp as key! $ts *seconds*(Julian) like $SAVE 
          $SUFFIX{$ts} = $sfx;   # see suffix use below...
          $CURRENT{$ts} = 1;     # FLAG rule as relevant to CURRENT year
          $IDS{$ts} = $tz_rule;  # 
        if($SingleZone)
          { print "$TO";  
          }; 
        }; 
        my($sav) = 'OFF     ';
      if($SAVE != 0)           # numeric value, 0 signals OFF
        { $sav = &Pad( '+' . &Tim($SAVE),8 );
        };
        Timely::Log("\n   * rule $sav" . &GDat($ts) . " $rnam($yr) : "
            . "from=$FROM to=$TO $IN $ON $AT "); 
        # not yet GPS-adjusted

#  - <Section 132> - 
      if($FROM < $yr)  # must apply to the preceding year
        { my($prior) = $yr-1;
          my($ts, $sfx) = &FixRuleDate($prior, $IN, $ON, $AT, $zoneinfo);  # "year-1"
        if($ts == 0) # error
          { Timely::XPrint(0, " Skipped rule[b]: $FROM, $TO, $IN, $ON, $AT, $SAVE "
                     . "in zone $zone : $yr, $rnam");
            $VALID = 0; 
          };  
        if($VALID)
          { $OFFSET{$ts} = $SAVE;     # save DST, seconds 
            $SUFFIX{$ts} = $sfx;      # suffix
            $CURRENT{$ts} = 0;        # SIGNAL only for use in DST calculations
            $IDS{$ts} = $tz_rule;  # 
          if($SingleZone)
            { # print "<";  
            }; 
          }; 
          my($gr) = Timely::Greg($ts, 0, 0, 0); # is NOT GPS-adjusted
          Timely::Log( "\n _  PRIOR $rnam($prior) : $gr" ); # 
        };
      } else  # NOT active but potentially relevant in terms of DST carry-over:

#  - <Section 133> - 
      { my($top) = $TO;  # CANNOT be 'max'
      if($top eq 'only')
        { $top = $FROM;
        };
        my($ts, $sfx) = &FixRuleDate($top, $IN, $ON, $AT, $zoneinfo);
      if($ts == 0) # error
        { Timely::XPrint(0, " Skipped rule[c]: $FROM, $TO, $IN, $ON, $AT, $SAVE "
                   . "in zone $zone : $yr, $rnam");
          $VALID = 0; 
        };
      if($VALID)
        { 
        if($ts > $CARRYOVER) # update to most recent timestamp: [explore] 
          { $CARRYOVER = $ts;
            $CARRYsuffix = $sfx;
            $CARRYsave = $SAVE; 
            $CARRYid = $tz_rule;  # 
          if($SingleZone)
            { print "<-";  
            }; 
          } 
        elsif($SingleZone)
          { print "-";  # nice try, but..
          }; 
        }; 
      };
    };

  if($SingleZone)
    { print ')';
    }; 
  };

  # [in following ? ensure $OFFSET{$CARRYOVER} doesn't already exist? [explore]] 
if($CARRYOVER > 0)
  { $OFFSET{$CARRYOVER} = $CARRYsave;  # use timestamp as key!
    $SUFFIX{$CARRYOVER} = $CARRYsuffix;   # see suffix use below...
    $CURRENT{$CARRYOVER} = 0;     # only interested in DST
    $IDS{$CARRYOVER} = $CARRYid;  # 
  };

#  - <Section 134> - 
my($numhash) = scalar(keys %OFFSET); 
if($numhash < 1)
  { #&Debug(0, '<nil>');  
  if( $zone_transition && $RUNNING_DST ) # if transition, carry moved in, END OFF!
    { #&Debug(0, "\n  apply both OFF: t was " . &Dat($zone_transition) 
      #         . ', d was ' . &Tim($RUNNING_DST) );
      return(0, 0);   # do NOT return $RUNNING_DST. [might check this]
    }; 
    #&Debug(0, "\n  apply t OFF: t was" . &Dat($zone_transition) 
    #         . ', d=' . &Tim($RUNNING_DST) );
    return(0,0); # [odd]
  };

  print '.'; # eye candy says "one or more rules are being processed..."
  # process timestamps in ascending order, to obtain DST start, end.
  # This is important as wall clock time depends on preceding DST :-(

#  - <Section 135> - 
  my($ts);
  my($rulecount) = scalar %OFFSET; 
  Timely::Log("\n\n  Applying $rulecount rules ($SingleZone):");

SORTED: foreach $ts (sort keys %OFFSET)  # sort timestamps ASC (various formats! )
  { my($De) = $OFFSET{$ts}; 
    my($suff) = $SUFFIX{$ts}; 
    my($Tm) = &FixBySuffix($suff, $ts, $CURRENT_ZO, $RUNNING_DST);  
              # adjust TO GMT, seconds ($ts is in seconds too)

    my($tz_rule) = $IDS{$ts}; 

  if($SingleZone)
    { print "[$suff," . &Dat($Tm);   # [hmm] 
    }; 

    # THERE'S A POTENTIAL PROBLEM HERE. For example, $zone_transition was calculated
    # previously and may have had a different DST applied, but later we depend on
    # a comparison between $Tm and this!
    my($DELTA_DST) = $RUNNING_DST - $DSTCARRY; # ? DST changed since zone_transition ...
    $Tm = Timely::ApplyGps($Tm);   # convert to GPS time 
              # relevant, as $suff may implicate current wall clock time!

#  - <Section 136> - 
    my($fancy) = '_';   # only relevant to carried over DST
  if($CURRENT{$ts})
    { $fancy = '*';     # rule is applicable to this year, in all its splendour
    };

#  - <Section 137> - 
  if(! $CURRENT{$ts} )  # if only looking at carry over of DST...
    { # do nothing
    if($SingleZone)
      { print ':'; # [use a better indicator?] 
      }; 
    }

#  - <Section 138> - 
     elsif
      ( ($Tm + $DELTA_DST - $DELTA_Z < $LASTTRAN ) # applies before _prior_ transition
      )
      { Timely::Log('< *skip, before prior transition ' &Tim($DELTA_DST)  
        . '>' );   # [?DELTA_Z] 
      if($SingleZone)
        { print "<";  
        }; 
      }

#  - <Section 139> - 
    else  # is CURRENT rule:
    { 

#  - <Section 140> - 
#   &Debug(0, "\n      TESTING T=" . &Dat($Tm) . ', tr=' . &Dat($zone_transition) 
#           . ', delta=' . &Tim($DELTA_DST) );
    if( $zone_transition
      && ($Tm + $DELTA_DST - $DELTA_Z > $zone_transition)  
      )     # rule can only apply < tr  
      { Timely::Log(" *SKIP to END($rnam : $yr " . &Tim($De) . ") as " 
           . &Dat( $Tm + $DELTA_DST )  . " adjusted by " . &Tim($DELTA_DST) 
           . ' and ' . &Tim($DELTA_Z)
           . " is above transition ". &Dat($zone_transition) );
      if($SingleZone)
        { print ">";  
        }; 
        $rulecount --; 
        last SORTED;  # and finished as all others will be above too! [EXPLORE]
      }

#  - <Section 141> - 
    else
      { #&Debug(0, "\n      Apply: "); 
      if($De == 0) # if end of daylight saving  [END OF DAYLIGHT SAVING]
        { Timely::Log('End DST.');  
      if($SingleZone)
        { print "\n  (-)"; # [ugh]
        }; 

#  - <Section 142> - 
        } else   # [start of DST]
        { Timely::Log('Start DST'); 
          my($plus) = '+'; 
        if($RUNNING_DST)
          { Timely::Log(" **NOTE** super DST: " . &Tim($RUNNING_DST) 
                 . ' -> ' . &Tim($De) ) ;
            $plus = '++'; 
          };
        if($SingleZone)
          { print "\n  ($plus)";
          }; 

#  - <Section 143> - 
          };  # [end "start of DST" section!]
          $STOREDOK = &Store($LASTTRAN, $Tm, $RUNNING_DST, $CURRENT_ZO, $suff, 
                             DSTTRAN, 0, $SingleZone); # seconds
      };
    };   # end of final HUGE else within SORTED loop

    $RUNNING_DST = $De;
    #&Debug(0, "  runDST7=" . &Tim($RUNNING_DST) );

  if($SingleZone)
    { print "]";  
    }; 
    $rulecount --; 
  };   # END of SORTED loop.

#  - <Section 144> - 
if($STOREDOK > 0)
  { $STOREDOK += 7200;  # add 2h, just in case [hack]
  }; 
  #&Debug(0, "\n  apply returns: $STOREDOK, t=" . &Dat($STOREDOK) 
  #        . '; d=' . &Tim($RUNNING_DST) );
  return($STOREDOK, $RUNNING_DST); 
}

#  - <Section 145> - 
sub Pad #
{ my($s, $L) = @_;
while(length $s < $L)
  { $s = "$s ";
  };
 return($s);
}

#  - <Section 146> - 
sub Dat # Submitted Julian value is in seconds not days 
{ my($J) = @_;
  return( Timely::Greg($J,0,0,1) );
}

#  - <Section 147> - 
sub GDat # 
{ my($J) = @_;
  return( Timely::Greg($J,0,0,0) );
}

#  - <Section 148> - 
sub FixBySuffix # 
{ my($suff, $T, $GMTOFF, $newdst) = @_;

  my($naah) = 0;
#  &Debug($naah, "  `$suff:" . &Dat($T) 
#        . ', z=' . &Tim($GMTOFF) . ', new DST=' . &Tim($newdst) 
#        . '--->' ); 
if($suff =~ /[guz]/)
  { #&Debug($naah, "gmt`" ); 
    return($T);
  };

if($suff eq 's') # standard local time (excluding daylight saving)
  { $T -= $GMTOFF;
    #&Debug($naah, "local:" . &Dat($T) . "`" );
    return($T);        # time has GMT offset added in, so subtract it
  };

if( (length $suff == 0)
  ||($suff eq 'w') # wall clock time
  )
  { $T -= $GMTOFF;
    $T -= $newdst;
    #&Debug($naah, "wall:" . &Dat($T) . "`" );
    return($T); # both DST and GMT have been ADDED 
  };

  die "...\n*ERROR* Bad suffix ($suff) for time" . &JulianDay($T);
  return(0); 
}

#  - <Section 149> - 
sub FixTime # 
{ my($t) = @_;
  my($sign) = 1;
  ## my($naah) = 1;
  ## &Debug($naah, "<<$t ~ " ); 

if($t =~ /^-/ )
  { $sign = -1;
  };               # [this whole rtn is clumsy]

  my($r);
if($t =~ /(\d+):(\d+):(\d+)$/ )   #  [hours, minutes, seconds]
  { return( $sign * ($1*3600 + $2*60 + $3) ); # NB. sign distributes over the lot
    ## $r = $sign . ($1/24 + $2/(24*60) + $3/(24*3600));
    ## &Debug($naah, "$r>> " );
    ##return (  $r  );
  };
if($t =~ /(\d+):(\d+)$/ )  # [hours, minutes] 
  { return( $sign * ($1*3600 + $2*60) ); 
    # $r = $sign . ($1/24 + $2/(24*60));
    # &Debug($naah, "$r>> " );
    # return (  $r  );
  };
if($t =~ /(\d+)$/ )  # [hours]
  { return( $sign * $1*3600 ); 
    # $r = $sign . ($1/24);
    # &Debug($naah, "$r>> " );
    # return (  $r   );
  };
  die "\n***ERROR bad time: $t";
}

#  - <Section 150> - 
sub FixRuleDate # 
{ my($yr, $MMM, $dd, $hhmm, $zoneinfo) = @_;
  my($mo) = &FetchMonth($MMM);
if($mo < 1)
  { Timely::Warn(3, "BAD RULE month: $yr m=$MMM($mo) $dd $hhmm");
    return(0,0);
  };

  my($aday) = $dd; 

  # last of month eg 'lastSun'
if( $dd =~ /^last(\w+)$/ )
  { my($wday) = $1;
    $aday = &FetchLast($yr, $mo, $wday);
  }
  # MMM>=n e.g. 'Sun>=1'
elsif( $dd =~ /^(\w{3})>=(\d+)$/ )
  { ($aday, $mo) = &FetchFirst($yr, $mo, $1, $2);
  }
elsif( $dd =~ /^(\w{3})<=(\d+)$/ ) # only instance is Zion !
  { # Timely::Warn(0, "Testing <= [Zion]"); 
    ($aday, $mo) = &FetchBefore($yr, $mo, $1, $2); 
  };
  # $aday now should be numeric: 
if( $aday !~ /^\d+$/ )
  { Timely::Warn(3, "Failed date criterion($yr, $MMM .. $hhmm): '$dd'"); 
    return(0, 0);
  };

  my($hh);
  my($mm);
  my($ss) = 0; 
  my($SUFFIX) = '';
if($hhmm =~ /^(\d+):(\d+):(\d+)([guzsw]*)$/ ) # clumsy
  { $hh = $1;
    $mm = $2;
    $ss = $3;
    $SUFFIX = $4;
  }
elsif($hhmm !~ /^(\d+):(\d+)([guzsw]*)$/ )   # technically ([guzsw]?) is better
  { 
  if($hhmm =~ /^0$/ )
    { $hh = 0;
      $mm = 0;
      Timely::Log(" --assumed time '0:00' $yr $mo $aday <$hhmm>", 10);
    } else
    { Timely::Warn(3, "BAD hours/min ($zoneinfo) $yr $mo $aday $hhmm");
      return(0,0);
    };
  } else
  { $hh = $1;
    $mm = $2;
    $SUFFIX = $3;
  };
  my($J) = &ZoneJulian($yr, $mo, $aday, $hh, $mm, $ss); # seconds
  return($J, $SUFFIX);  # NB. $J is *not* GPS-adjusted!
}

#  - <Section 151> - 
sub FetchLast # 
{ my($yy, $mm, $day) = @_;
  my(@MONS) = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
    # what about leap years? [?????????????????? fix me]
  my(%WD) = ('Sun', 0, 'Mon', 1, 'Tue', 2, 'Wed', 3, 'Thu', 4, 'Fri', 5, 'Sat', 6);
if(! defined $WD{$day})
  { die "\n***ERROR*** Bad weekday: $yy $mm $day";
    return(0);
  };
  my($daycode) = $WD{$day};
if(! defined $MONS[$mm-1])
  { die "\n***ERROR***Bad month: $yy $mm $day";
    return(0);
  };
  my($topday) = $MONS[$mm-1];
  my($Jtest) = Timely::GpsJulian($yy, $mm, $topday, 0, 0, 0, 0, 0, 0)/86400;
  my($mod) = int($Jtest+2) % 7;   # modulo seven. +2 TO MAKE Sun=0
while($mod != $daycode)
  { $topday --;
    $mod --;
   if($mod < 0)
     { $mod = 6; # wrap [check this always exits, hmm]
     };
  };
  return($topday);
}

#  - <Section 152> - 
sub FetchFirst # 
{ my($yy, $mo, $day, $cut) = @_;
  my(@MONS) = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
  if( &IsLeapYear($yy) )
    { $MONS[1] = 29; 
    }; 
  my(%WD) = ('Sun', 0, 'Mon', 1, 'Tue', 2, 'Wed', 3, 'Thu', 4, 'Fri', 5, 'Sat', 6);

if(! defined $WD{$day})
  { Timely::Warn(3, "BAD weekday: $yy $mo $day");
    return('', $mo);
  };

  my($wantday) = $WD{$day};
if(! defined $MONS[$mo-1])
  { Timely::Warn(3, "BAD month: $yy $mo $day");
    return('', $mo);
  };

  my($topday) = $MONS[$mo-1];
  my($Jtest) = Timely::GpsJulian($yy, $mo, $cut, 0, 0, 0, 0, 0, 0)/86400;  # first day
  my($dayofweek) = int($Jtest+2) % 7;   # modulo seven. +2 TO MAKE Sun=0 : CURRENT DAY
  #&Debug(0, "$Jtest d=$cut dow=$dayofweek ");

  # We now need to adjust $cut upwards, until it meets the right day.
  # corresponds to incr $dayofweek commensurately until matches $wantday(0=sun).
  # (The catch is that we may need to wrap $dayofweek around); 
  # We can also wrap into the next month
  my($delta) = $wantday - $dayofweek; # desired day - current e.g. Wed-Sun = 3-0 = 3. 

if($delta < 0)  # will have to wrap around e.g. Sun-Wed = 0-3 = -3, i.e. add 7. 
  { $cut += (7+$delta); 
  } 
elsif($delta > 0) # 
  { $cut += $delta; 
  }; # else $cut is correct : the same day! 

  # check that cut isn't ridiculous:
if($cut > $topday)
  { ## Timely::Warn(0, "FetchFirst($yy-$mo-$day) wrapped $cut after month ($topday)!");
    $cut -= $topday; 
    $mo ++; 
  if($mo > 12)
    { Timely::Warn(3, "FetchFirst($yy-$mo-$day) can't advance date past year end($topday)"); 
      return('', $mo); 
    };
  };

  return($cut, $mo); 
}

#  - <Section 153> - 
sub IsLeapYear
{ my($yy);    # clumsy, use @
    ($yy)=@_;
if(($yy % 4) != 0)
  { return(0); # not a leap year, not divisible by 4. 
  }; 
if(($yy % 100) != 0)
  { return(1); # is a leap year
  };
  return(($yy % 400) == 0); # is a leap year if divisible by 400. 
}

#  - <Section 154> - 
sub FetchBefore # 
{ my($yy, $mo, $day, $cut) = @_;
  my(@MONS) = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
  ## 
  if( &IsLeapYear($yy) )
    { $MONS[1] = 29; 
    }; 
  my(%WD) = ('Sun', 0, 'Mon', 1, 'Tue', 2, 'Wed', 3, 'Thu', 4, 'Fri', 5, 'Sat', 6);

if(! defined $WD{$day})
  { Timely::Warn(3, "BAD weekday: $yy $mo $day");
    return('', $mo);
  };

  my($wantday) = $WD{$day};
if(! defined $MONS[$mo-1])
  { Timely::Warn(3, "BAD month: $yy $mo $day");
    return('', $mo);
  };

  my($Jtest) = Timely::GpsJulian($yy, $mo, $cut, 0, 0, 0, 0, 0, 0)/86400;  # last day
  my($dayofweek) = int($Jtest+2) % 7;   # modulo seven. +2 TO MAKE Sun=0 : CURRENT DAY

  # move back
  my($delta) = $dayofweek - $wantday ; # eg. Tue wants Sunday = 2-0 

if($delta < 0)  # will have to wrap back e.g. Sunday wants Tuesday = 0-2 
  { $cut -= (7+$delta); 
  } 
elsif($delta > 0) # 
  { $cut -= $delta; 
  }; # else $cut is correct : the same day! 
  # Timely::XPrint(0, " Debug: cut is $cut,"); 

  # check that cut isn't bad:
if($cut < 1)
  { 
  if($mo < 2)
    { Timely::Warn(3, "FetchBefore($yy-$mo-$day) can't move date before yr start($cut)"); 
      return('', $mo); 
    };
    # Timely::Warn(0, "FetchBefore($yy-$mo-$day) wrapped $cut back!");
    my($lasttopday) = $MONS[$mo-2];
    $cut += $lasttopday;  # add negative value or zero (0=last day of previous month)
    $mo --; 
  };

  return($cut, $mo); 
}

#  - <Section 155> - 
sub ParseRule # 
{ my($ln) = @_;

  my($r, $NAME, $FROM, $TO, $TYPE, $IN, $ON, $AT, $SAVE, $LETTERS) = split /\s+/, $ln; 

if(! defined $LETTERS)
  { Timely::Log( "\n?R=<$ln>\n" ) ;
    return(0); 
  };
  my($tz_rule) = &tz_rule_save($NAME, $FROM, $TO, $IN, $ON, $AT, $SAVE);

  # here must check format of rule components, might restructure...

  my($saving) = &FixTime($SAVE); # seconds 

  # end check.


  my (@V) = ($FROM, $TO, $IN, $ON, $AT, $saving, $tz_rule); # the key variables 
    # note that $saving at index 5 is in seconds. 

   # format is Rule NAME etc. 
if(defined $RULES{$NAME} )
  { my ($R) = $RULES{$NAME};
    my (@A) = @$R;
    ## Timely::Log( " --existing rule,size=" . scalar @A ); 
 
# if we're in the N hemisphere, it's possible to have
#   end rules appear before start rules, which means
#   we can't compensate for the DST adequately. Fix this.
#   (You also can't simply sort by time, as rules have different extent!)
#   There is however a residual problem with 'super' DST (eg UK, Germany 1940s)
#######################################################
  if( ! $saving ) # if an END of DST rule
    { push( @A, \@V);     # push a reference
    } else
    { unshift( @A, \@V);  # put STARTing rules at start of array!
    };
#######################################################

    Timely::XPrint(0, 'r');
    $RULES{$NAME} = \@A; # and store as an array reference!
  } else
  { # Timely::Log(" --new rule--");
    my(@A) = ( \@V );   # create new array with reference
    $RULES{$NAME} = \@A; 
    Timely::XPrint(0, 'R'); 
  };

  return(1); 
}

#  - <Section 156> - 
sub StartZone # 
{ my($ln, $zonedesc) = @_;
  
  my(@ZDAT) = split /\s+/, $ln; 
  my($ZL) = scalar @ZDAT;
if($ZL < 6)
  { #  e.g. CET, WET etc
    Timely::Log( " --short zone data length=$ZL: <$ln> -- " );
  if($ZL < 5) # can't fix
    { die "\n***ERROR*** zone data too short <$ln>"; # [explore use of Aagh_()]
      return(0);  
    };
    # here might compensate for missing final (end time) [? explore]
  };

#  - <Section 157> - 
  shift(@ZDAT);  # discard 'Zone'
  my($NAME)   = shift(@ZDAT);
  my($SingleZone) = (length $zonedesc > 0); 

  # if zone description exists, check this single zone 
if($SingleZone)
  { 
  if($NAME ne $zonedesc)    # and if no match:
    { return('');  # signal nil. 
    };
    print "\n[Starting zone $zonedesc] "; 
  }; 

  my(@V) = &ZoneX($SingleZone, @ZDAT);   # this should set %ZONES entry..

if(! defined $ZONES{$NAME} )
  { Timely::XPrint(0,  "\n *NOTE* Unknown zone: '$NAME', forcing:" ); 
    # create it, otherwise WET, CET, MET, EET, EST, HST, MST, EST5EDT ... absent
    # Also see the Montreal-related hack in ReadZones_()
    my($ZID) = &FetchCountryCode('UT');  # Rather use Universal Time than null 'XX' 
    &SaveZone($NAME, $ZID, 0, 0); # also fills in ZONES, ZONECODES
  };
  my($zn) = $ZONES{$NAME};
if( ref($zn) eq 'ARRAY' )
  { die "\n***ERROR*** Duplicate zone: $NAME";
    return(0);
  };

#  - <Section 158> - 
  my($zoneid) = $ZONECODES{$NAME};
  my($tz_cutoff) = &tz_cutoff_save($ZDAT[0], $ZDAT[1], $zoneid, $ZDAT[3]);
if(! defined $tz_cutoff || length $tz_cutoff < 1)
  { die "Missing zone code for '$NAME'";
  }; 
  # [$jvs: fix me! must now include $tz_cutoff ID in \@V] 
  push(@V, $tz_cutoff); 

  my(@A) = ( \@V );   # create new array with reference
  $ZONES{$NAME} = \@A; 
  Timely::Log( "\n(Z:$NAME" ); 
  return($NAME); 
}

#  - <Section 159> - 
sub MoreZone # 
{ my($ln, $NAME, $SingleZone) = @_;
  
if(length $NAME < 1)  # Don't process. 
  { return(1);
  }; 

  my(@ZDAT) = split /\s+/, $ln;  # here, first datum should be null string 

if($SingleZone)
  { print " zone: " . join('|', @ZDAT);
  } else
  { print 'z';
  }; 

  my($ZL) = scalar @ZDAT;
if($ZL < 4)
  { &TimeWarn( "short zone $ZL=<$ln>\n", 11, $NAME, 0 );  
    return(0); 
  };

  shift(@ZDAT);  # discard first (null) element
  my(@V) = &ZoneX($SingleZone, @ZDAT); 

if(! defined $ZONES{$NAME} )           # [might move this up higher?]
  { &TimeWarn( " (severe) missing zone:$NAME\n", 12, $NAME, 0 );
    # WHAT ABOUT DISCARDED DATA ? [explore]
    return(0); 
  };

  # store, get identity for this row:
  my($tz_cutoff) = &tz_cutoff_save($ZDAT[0], $ZDAT[1], 
                                   $ZONECODES{$NAME}, $ZDAT[3]);
  push(@V, $tz_cutoff); 

  my ($R) = $ZONES{$NAME};
  my (@A) = @$R;
  push( @A, \@V);     # push a reference
  $ZONES{$NAME} = \@A; # and store as an array reference!
  # print 'z'; 
  return(1); 
}

#  - <Section 160> - 
sub TimeWarn #
{ my($msg, $id, $zone, $year) = @_;
  Timely::Warn(0, "-- [$id:$zone $year] $msg");
}

#  - <Section 161> - 
sub ZoneX # 
{ my($SingleZone, @ZDAT) = @_;
  my($lZ) = scalar @ZDAT;

  my($GMTOFF) = &FixTime($ZDAT[0]); #seconds
  # might here validate the zone time [explore]

  my($RUL)  = $ZDAT[1];
  my($FORMAT) = $ZDAT[2];   # will become last entry

  my($UNTIL)  = 9999;  # ??? [must accommodate missing value = ? "ad infinitum"]
if($lZ < 4)
  { Timely::Log("--short($lZ) zone data array: @ZDAT -- "); 
  } else
  { $UNTIL = $ZDAT[3];
  };
  my($MMM)    = '0'; 
if($lZ > 4)
  { $MMM  = $ZDAT[4];
  };
  my($DD)     = '0';
if($lZ > 5)
  { $DD  = $ZDAT[5];
  };
  my($hhmm)   = '0:0';
if($lZ > 6)
  { $hhmm = $ZDAT[6];
  };
  my($hh)=$hhmm;
  my($mm)=0;
  my($ss)=0;
  my($suffix) = '';
if($hhmm =~ /(\d+):(\d+):(\d+)([guzsw]*)/ )
  { $hh = $1;
    $mm = $2; 
    $ss = $3;
    $suffix = $4;  # clumsy
  }
elsif($hhmm =~ /(\d+):(\d+)([guzsw]*)/ )
  { $hh = $1;
    $mm = $2;
    $suffix = $3;  # clumsy
  };

  ######################################################
  my($mo) = &FetchMonth($MMM);
if($mo < 1)
  { die "\n***ERROR*** Bad rule date: $UNTIL $MMM $DD $hh $mm";
    return(0);
  };

#  - <Section 162> - 
  my($J); 
    # here must accommodate e.g. lastSun
if( ($DD =~ /last/)
  ||($DD =~ /first/)
  ||($DD =~ /^\w{3}>=\d+/ )  # e.g. Sun>=
  )
  { ($J, $suffix) = &FixRuleDate($UNTIL, $mo, $DD, $hhmm, ''); # $J is in seconds. 
                            # at present no zoneinfo here ^ [explore] 
  if($J == 0) # error
    { die ("Bad rule in ZoneX: $RUL, $UNTIL, $mo, $DD, $hhmm, $FORMAT "); 
           # not $FROM, $TO, $IN, $ON, $AT, $SAVE
      return(0,0);
    }; 
     #&Debug(0, "\n Fixing anomalous Zone Rule date: $UNTIL $MMM $DD ->" . &Dat($J)); 
  } else
  { $J = &ZoneJulian($UNTIL, $mo, $DD, $hh, $mm, $ss);  # seconds. 
  };

if($SingleZone)
  { print "  : $GMTOFF, $RUL, $UNTIL, $MMM, $DD, $hh, $mm, $FORMAT, $J, $suffix\n"; 
  }; 

  # do NOT invoke Timely::ApplyGps_()
  return($GMTOFF, $RUL, $UNTIL, $MMM, $DD, $hh, $mm, $FORMAT, $J, $suffix);
}

#  - <Section 163> - 
sub ZoneJulian # 
{ my($UNTIL, $fm, $DD, $hh, $mm, $ss) = @_;

if(!defined $UNTIL)
  {$UNTIL = 9999;  # might also log warning [?]
  };
if(! defined $fm)
  { die "\n***ERROR*** Bad month for $UNTIL / $DD $hh $mm $ss";
    return(0);
  };
  #&Debug(0, "<zj $UNTIL $fm-$DD $hh:$mm:$ss>"); 

if($DD == 0) # artificial
  { $DD = 1;
  } 
elsif($DD !~ /^\d+$/)
  { die "\n Bad Zone date: $UNTIL $fm [$DD] $hh $mm";
  };
  return( Timely::ToJulian($UNTIL, $fm, $DD, $hh, $mm, $ss, 0, 0, 0) ); 
}

#  - <Section 164> - 
sub FetchMonth
{ my($mm) = @_;
  # permit numeric:
if($mm =~ /^\d+$/ )
  {
  if($mm == 0)  # turn 0 into 1
    { return(1);
    };
    return($mm);
  };  # simply return numeric.
my(%MTHS) = ('Jan', 1, 'Feb', 2, 'Mar', 3, 'Apr', 4, 'May', 5, 'Jun', 6,
    'Jul', 7, 'Aug', 8, 'Sep', 9, 'Oct', 10, 'Nov', 11, 'Dec', 12, 
    0, 1, '0', 1); # 0-->1 !
if( ! defined $MTHS{$mm} )
  { return(0);  # fail 
  };
  return( $MTHS{$mm} );
}

#  - <Section 165> - 
sub EndZone # 
{ my($ZN) = @_;
if(length $ZN < 1)
  { return(1);
  }; 

  Timely::XPrint(0,  ')' ); 

  return(1); 
}

#  - <Section 166> - 
sub ZoneTest # 
{ my($arg, $NUMBR, $myLowYear, $myTopYear);
    ($arg, $NUMBR, $myLowYear, $myTopYear)=@_;
 
  my($handDB) = $smalltime_h;  

 my($stubyear,$MONTH,$DAY, $HOUR,$MINUTE,$SECOND) 
               = Timely::FullGregorian($NUMBR, 0,        0,        1);
                             # no local ^, no DST ^, is GPS ^   

if(length $arg < 1)
  { # do nothing, accept defaults..
    my($pd) = Timely::PrettyDate(0,$stubyear,$MONTH,$DAY, $HOUR,$MINUTE,$SECOND); 
    print "\n Testing default: " . substr($pd, 4);
    ShowEscMessage(); 
  }
elsif($arg =~ /^\s*(\d{4})\s+(\d{4})-(\d+)-(\d+)[ T]+(\d+):(\d+):(\d+)\s*$/ ) 
  { $myLowYear = int($1) - 1;   # low and high years
    $myTopYear = int($2); 
    $MONTH  = $3;
    $DAY    = $4;
    $HOUR   = $5;
    $MINUTE = $6;
    $SECOND = $7;
  } 
elsif($arg =~ /\s*(\d{4})-(\d+)-(\d+)[ T]+(\d+):(\d+):(\d+)\s*$/ ) # + low yr
  { $myLowYear = int($1) - 1; 
    $MONTH  = $2;
    $DAY    = $3;
    $HOUR   = $4;
    $MINUTE = $5;
    $SECOND = $6;
  } 
elsif($arg =~ /^\s*(\d+)-(\d+)[ T]+(\d+):(\d+):(\d+)\s*$/ ) # just the month..
  { $MONTH  = $1;
    $DAY    = $2;
    $HOUR   = $3;
    $MINUTE = $4;
    $SECOND = $5;
  }
elsif($arg =~ /^\s*(\d{4})\s+(\d{4})\s*$/ ) # a range of years
  { $myLowYear = int($1) - 1; 
    $myTopYear = int($2); 
  } 
elsif($arg =~ /^\s*(\d{4})\s*$/ ) # just the minimum year
  { $myLowYear = int($1) - 1; 
  }
 else
  { print "\n Unknown format, expected MM-DD hh:mm:ss e.g. 12-31 20:30:00 ";
    return; 
  };

if( ($myLowYear < $LOWYEAR)
  ||($myTopYear > $TOPYEAR)
  )
  { print "\n Bad year range $myLowYear .. $myTopYear ($LOWYEAR : $TOPYEAR-1)";
    return;
  }; 

  my($q) = "SELECT place, description FROM PLACES "
         . "WHERE p_amended between 2 and $TOPCOUNTRY AND reason > -1";
  #   ignore 1 = UTC stub. 
  # place is internal code, description is zone code:
  my(@ZDAT) = Timely::SQLManySQL($handDB, $q, 'get zones');

#  - <Section 167> - 
  my($YEAR) = $myTopYear;
  my($ERR) = 0;
  my($ANOMALIES) = 0; 

REDO: while($YEAR > $myLowYear)
  { 
  if( CheckForEscape() )
    { $YEAR = $myLowYear-1;
      next REDO;             # 
    }; 

    my($JD) = Timely::GpsJulian($YEAR,$MONTH,$DAY, $HOUR,$MINUTE,$SECOND, 0,0,0);   
    my($xYYYY, $xMM, $xDD, $xh, $xm, $xs) = Timely::FullGregorian($JD, 0, 0, 1); #1:GPS

  my($dt1) = eval { DateTime->new( year => $xYYYY, month => $xMM, day => $xDD,
       hour => $xh, minute => $xm, second => $xs,
       time_zone => 'UTC') }; 
  if(! $dt1)
    { Timely::Warn(3, "INVALID time zone (DateTime usage) 'UTC'"); 
      last REDO; 
    }; 
     Timely::XPrint(0,  "\n " 
        . Timely::PrettyDate(0,$YEAR, $MONTH, $DAY, $HOUR, $MINUTE, $SECOND) . ' ' ); 

#  - <Section 168> - 
    my($ref);
  foreach $ref(@ZDAT)
    { 
      my($zid, $zone) = @$ref;
      my($YYYY,$MM,$DD,$h,$m,$s, undef,undef, $hog, undef, undef) 
                  # dummy values  ^    ^            ^      ^ 
             = Timely::J2G(0, $zid, $JD); # JD is Gps-based 
    if($YYYY == 0)  # anomalous date
      { Timely::XPrint(0, "\n     'Anomaly' skipped: $zid/$zone $YEAR $JD"); 
        $ANOMALIES ++;
      } else
      { my($mine) = Timely::PrettyDate(1,$YYYY, $MM, $DD, $h, $m, $s); 
        # similar to Timely::Greg_()

       # trap failure of DateTime [??]
       ## print "\ndebug .. '$zone'"; 

        my($dtest) = eval { $dt1->clone->set_time_zone( $zone ) };
      if(! $dtest)
        { Timely::Warn(3, "INVALID time zone (Perl DateTime test) $zone");
        } else
        { my($yours) = $dtest->datetime();  # format is identical
        if($mine ne $yours)
          { Timely::XPrint(0, "\n   Mismatch $zid/$zone $mine v $yours" . $TICK); 
            $ERR++;
          } else
          { print '.'; 
            ## &Debug (0,"\n OK Zone $zone OK: $mine"); 
          };
        }; 
      };
    };
  $YEAR --;
  };
  Timely::XPrint( 0, "\n\n Errors=$ERR, $ANOMALIES anomalies for " . 
          ($myLowYear+1) . '--' 
          . Timely::PrettyDate(1,$TOPYEAR, $MONTH, $DAY, $HOUR, $MINUTE, $SECOND) ); 
}

#  - <Section 169> - 
sub WallTest # 
{ my($arg, $NUMBR, $myLowYear, $myTopYear) = @_;
 
  my($handDB) = $smalltime_h;  

  # borrowed from ZoneTest_() : 
  my($stubyear,$MONTH,$DAY, $HOUR,$MINUTE,$SECOND) 
         = Timely::FullGregorian($NUMBR, 0,        0,        1);
                       # no local ^, no DST ^, is GPS ^   
if(length $arg < 1)
  { # do nothing, accept defaults..
    my($pd) = Timely::PrettyDate(0,$stubyear,$MONTH,$DAY, $HOUR,$MINUTE,$SECOND); 
    print "\n Testing default: " . substr($pd, 4);
    ShowEscMessage(); 
  }
elsif($arg =~ /^\s*(\d{4})\s+(\d{4})-(\d+)-(\d+)[ T]+(\d+):(\d+):(\d+)\s*$/ ) 
  { $myLowYear = int($1) - 1;   # low and high years
    $myTopYear = int($2); 
    $MONTH  = $3;
    $DAY    = $4;
    $HOUR   = $5;
    $MINUTE = $6;
    $SECOND = $7;
  } 
elsif($arg =~ /\s*(\d{4})-(\d+)-(\d+)[ T]+(\d+):(\d+):(\d+)\s*$/ ) # incl low year 
  { $myLowYear = int($1) - 1; 
    $MONTH  = $2;
    $DAY    = $3;
    $HOUR   = $4;
    $MINUTE = $5;
    $SECOND = $6;
  } 
elsif($arg =~ /^\s*(\d+)-(\d+)[ T]+(\d+):(\d+):(\d+)\s*$/ ) # just the month..
  { $MONTH  = $1;
    $DAY    = $2;
    $HOUR   = $3;
    $MINUTE = $4;
    $SECOND = $5;
  }
elsif($arg =~ /^\s*(\d{4})\s+(\d{4})\s*$/ ) # a range of years
  { $myLowYear = int($1) - 1; 
    $myTopYear = int($2); 
  } 
elsif($arg =~ /^\s*(\d{4})\s*$/ ) # just the minimum year
  { $myLowYear = int($1) - 1; 
  }
 else
  { print "\n Unknown WALL format, expected MM-DD hh:mm:ss e.g. 12-31 20:30:00 ";
    return; 
  };

if( ($myLowYear < $LOWYEAR)
  ||($myTopYear > $TOPYEAR-1)  # [check this]
  )
  { print "\n Bad year range $myLowYear .. $myTopYear ($LOWYEAR : " .($TOPYEAR-1). ")";
    return;
  }; 

  my($q) = "SELECT place, description FROM PLACES "
         . "WHERE p_amended between 2 and $TOPCOUNTRY AND reason > -1";
  # place is internal code, description is zone code:
  my(@ZDAT) = Timely::SQLManySQL($handDB, $q, 'get zones');

#  - <Section 170> - 
  my($YEAR) = $myTopYear;
  my($ERR) = 0;
  my($ANOMALIES) = 0; 
  my($ref);

REDO: while($YEAR > $myLowYear)
  { print "\n$YEAR ";

  if( CheckForEscape() )
    { $YEAR = $myLowYear-1;  # [hmm, check this] 
      next REDO;             # 
    };

  foreach $ref(@ZDAT)
    { my($zid, $zone) = @$ref;
      my($JD, $shadow) = Timely::G2J(0, $zid,$YEAR,$MONTH,$DAY,$HOUR,$MINUTE,$SECOND);   
    if($shadow < 0)  # if failed, don't try
      { my($yrs) 
         = Timely::FetchTzDate($JD, $zone, $YEAR,$MONTH,$DAY,$HOUR,$MINUTE,$SECOND);
      if(length $yrs < 1)
        { Timely::XPrint(0, "\n  Bad time(" . int($shadow/60) . " min): " 
          . Timely::PrettyDate(0,$YEAR, $MONTH, $DAY, $HOUR, $MINUTE, $SECOND) 
          . " /$zone"); 
          $ANOMALIES ++;
        } else
        { Timely::XPrint(0, "\n   Mismatch! $zid/$zone NOT FOUND(sh=" .int($shadow/60)
            . ") v $yrs" . $TICK); 
          $ERR++;
        };
      } else
      { # this is GPS time, so adjust to UTC, and then get back Gregorian:
        my($mine) = Timely::Greg($JD,0,0,1);  # date as YYYY-MM-DD hh:mm:ss
        $mine =~ s/ /T/;  # replace ' ' with 'T'

#  - <Section 171> - 
        # next do the same using the tz database:
        my($yours) = 
          Timely::FetchTzDate($JD, $zone, $YEAR,$MONTH,$DAY,$HOUR,$MINUTE,$SECOND);

#  - <Section 172> - 
      if($mine ne $yours)
        { my($mine2) = Timely::Greg($JD + $shadow, 0, 0, 1); # compensate for TZ jump!
          $mine2 =~ s/ /T/;
        if($mine2 eq $yours)
          { ## &Debug (0,"\n OK Zone $zone OK(+) $mine"); 
            print '+';
          } else
          { Timely::XPrint(0, "\n   Mismatch(TZ) $zid/$zone $mine v $yours" . $TICK); 
            $ERR++;
          };
        } else
        { ## &Debug (0,"\n OK Zone $zone OK: $mine"); 
          print '.';
        };
      };
    };  # end foreach
    $YEAR --;
  };  # end while

#  - <Section 173> - 
  Timely::XPrint( 0, "\n\n Errors=$ERR, $ANOMALIES anomalies "
    . ($myLowYear+1) . "--" 
    . Timely::PrettyDate(0,$TOPYEAR, $MONTH, $DAY, $HOUR, $MINUTE, $SECOND) ); 
}

#  - <Section 174> - 
sub Around # 
{ my($zone, $inp, $NUMBR);
    ($zone, $inp, $NUMBR)=@_;

  my($handDB) = $smalltime_h;  

  my($YEARTOP);
  my($YEARBOT);
if( $inp =~ /^\s*(\d{4})\s+(\d{4})\s*$/ )
  { $YEARTOP = $2;
    $YEARBOT = $1;
  }
elsif($inp =~ /^\s*(\d{4}\s*$)/ ) #  YYYY
  { $YEARTOP = $1+1;       # defaults to year-1 .. year+1 
    $YEARBOT = $1-1;    
  } 
elsif($inp =~ /^\s*$/ )  # just space or empty 
  { my($YYYY,$MM,$DD,$h,$m,$s, undef,undef, $hog, undef, undef)
                # dummy values  ^    ^            ^      ^ 
     = Timely::J2G(1, $zone, $NUMBR); 
  if(! $YYYY)
    { return(" Bad year for 'around' using current: " 
             . &JulianDay($NUMBR) . "\n"); # unlikely?!
    };
    $YEARTOP = $YYYY+1; 
    $YEARBOT = $YYYY-1; 
  }
else
  { return( "Bad parameters for a '$inp'\n" ); 
  };

  # better to sort here than in database, but for now...
  my($q) = "SELECT transition, dst, zone_offset, ignored from timely "
    . "WHERE region = $zone AND year BETWEEN $YEARBOT AND $YEARTOP "
    . "ORDER BY transition";  # ASCending order
  ##  . "AND ignored = 0 ORDER BY transition";  
      # ENCOMPASSES year of interest!
  my(@ROWS) = Timely::SQLManySQL($handDB, $q, 'get all rows');

  my($r);
  my(@P) = ();
foreach $r (@ROWS)
  { my($TR, $D, $Z, $ign) = @$r;  # transition, dst, zone, ignored
    my($flag) = '';
  if($ign) 
    { $flag = '[x]'; # signal this is supplementary, can be 'ignored' 
    };
    my($tr) = Timely::HugeToJ($TR);
    my($d)  = Timely::HugeToJ($D);
    my($z)  = Timely::HugeToJ($Z);
    push(@P, sprintf( "%.10f", &JulianDay($tr) ) . ' / ' . &Dat($tr) 
         . ' z=' . &Tim($z) . ' d=' . &Tim($d) . ' --> ' 
         . &Dat( $tr+$z+$d ) . " $flag" ); 
    # Dat_() value is GPS time, not adjusted for zone/DST.
  };  
  ## separable.. 

  print "\n Transitions for $zone ($inp); "
      . "[x] signifies 'Ignorable: end of year prosthetic':" ;
  my($rw); 
foreach $rw (@P)
  { print "\n $rw";
  };
  print "\n";
  return(''); # ok 
}

#  - <Section 175> - 
sub Debug #
{ my($naah, $msg) = @_;
if(! $BUG) 
  { return;
  };
if($naah)
  { return;
  };
  Timely::Log($msg); 
}

#  - <Section 176> - 
sub ListLeapseconds # 
{ my($handDB) = $smalltime_h;

  my($q) = "SELECT toffset, utctime from leapseconds WHERE 1 ";  
  my(@ROWS) = Timely::SQLManySQL($handDB, $q, 'get leapseconds');

  my($r);
  print "\n ==================================================\n"; 
  print "                LIST OF LEAPSECONDS\n"; 
  print " --------------------------------------------------\n"; 
  print  " Offset  Julian timestamp       Gregorian date\n"; 
foreach $r (@ROWS)
  { my($offset, $TM) = @$r;  
    my($sp) = ''; 
  if(length $offset < 2)
    { $sp = ' '; 
    };
    my($J) = $TM/1000000; # Julian day number, NOT GPS adjusted
    my($YY, $MM, $DD, $h, $m, $s) = Timely::FullGregorian($J, 0, 0, 0); # $J in seconds
    print "  $sp $offset      " . sprintf( "%.4f", &JulianDay($J) ) 
        . "       " . Timely::PrettyDate(0,$YY,$MM,$DD,$h,$m,$s) . "\n"; 
  };  
  print " --------------------------------------------------\n"; 
}

#  - <Section 177> - 
sub TestOneZone # 
{ my($zone, $inp, $intrv);
    ($zone, $inp, $intrv)=@_;
  # might here check/sanitise, ensure intrv >= 1;

  my($YYYY, $MM, $DD, $h, $m, $s, 
     $eYYYY, $eMM, $eDD, $eh, $em, $es) = &ReadDateRange($inp); 
if( $zone == Timely::GetUtcCode() )
  { print "Not tested, zone is UTC\n";
    return;
  }; 

#  - <Section 178> - 
if( ($YYYY < 1)
  ||($eYYYY < 1)
  )
  { print "Bad argument for zone '$inp'\n";
    return;
  }; 
if($eYYYY < $YYYY)
  { print "Start $YYYY can't be before end $eYYYY\n";
    return;
  }; 

if($intrv < 1)
  { print "\n Interval must be a second or greater";
    return;
  };
  print " Testing zone $zone from " 
      . Timely::PrettyDate(0, $YYYY, $MM, $DD, $h, $m, $s) 
      . " to " . Timely::PrettyDate(0,  $eYYYY, $eMM, $eDD, $eh, $em, $es) 
      . ", interval=$intrv" . "s\n";
  ShowEscMessage(); 

#  - <Section 179> - 
  my($JHi, $shadow1) = Timely::G2J(1, $zone, $eYYYY, $eMM, $eDD, $eh, $em, $es); #
if( $JHi < MINIMUMDATE)
  { Timely::Warn(3, "Bad top value in '$inp' (code $shadow1)"); 
    return;
  };  

  my($J, $shadow2) = Timely::G2J(1, $zone, $YYYY, $MM, $DD, $h, $m, $s); #
if($J < MINIMUMDATE)
  { print "\nBad start value in '$inp' (code $shadow2)";
    return;
  };    # might similarly check $shadow2

  my($oops) = 0;
  my($ok) = 0; 

#  - <Section 180> - 
REDO: while($J < $JHi)
  { 
  if( CheckForEscape() )
    { $J = $JHi;
      next REDO;             # 
    };

    my($YY, $MM, $DD, $h, $m, $s,undef, undef, $hog, undef, undef) 
                   # dummy values  ^    ^            ^      ^
          = Timely::J2G(1, $zone, $J); 
    my($K, $shadow3) = Timely::G2J(1, $zone, $YY,$MM,$DD, $h,$m,$s);
    my($delta) = $K-$J; 

  if( (abs($delta) > 1)
    || $shadow3
    )
    { my($d) = $delta; # for now simply transfer [explore]
    if( ( abs($d+$shadow3) > 0 )  # if shadow doesn't accommodate discrepancy
      &&($d)                      # and not just the first groundhog 
      )
      { Timely::XPrint(0, "\n Discrepancy($d) at $J = " 
        . Timely::PrettyDate(0,$YY,$MM,$DD,$h,$m,$s) 
        . " (shadow=$shadow3), interval=$intrv, J=" 
        . sprintf("%.12f", $J) . ' K=' . sprintf("%.12f", $K) );
        $oops ++;
        print '?';
      if($oops > $MAXOOPS)
        { print "\n Too many errors!";
          return;
        };
      } else
      { 
      if($d)
        { print '+';   # signal concordant shadow value
        } else
        { print '-';   # signal first shadow transition
        };
      };
    };

#  - <Section 181> - 
  if($ok % (50*$PRETTYDOTS) == 0) # every $PRETTYDOTS dots
    { print "\n" . &Dat($K) . ' ';
    }; 
  if($ok % 50 == 0)  # every 50 
    { print '.';
    };
    $ok ++; 
    $J += $intrv; # use this instead of increasing $J by a fraction of a day
  };
  Timely::XPrint(0, "\n Internal reconciliation for zone $zone. Errors=$oops/$ok\n"); 
}

#  - <Section 182> - 
sub ReconcileOneZone # 
{ my($zone, $zoneNAME, $inp, $intrv);
    ($zone, $zoneNAME, $inp, $intrv)=@_;

if( $zone == Timely::GetUtcCode() )
  { print "Not tested, zone is UTC\n";
    return;
  }; 

#  - <Section 183> - 
 my($YYYY, $MM, $DD, $h, $m, $s, 
   $eYYYY, $eMM, $eDD, $eh, $em, $es) = &ReadDateRange($inp); 
if( ($YYYY < 1)
  ||($eYYYY < 1)
  )
  { print "Bad argument for zone '$inp'\n";
    return;
  }; 
if($eYYYY < $YYYY)
  { print "Start $YYYY can't be before end $eYYYY\n";
    return;
  }; 

if($intrv < 1)
  { print "\n Interval must be a second or greater";
    return;
  };
  print " Reconciling zone $zone from $YYYY-$MM-$DD $h:$m:$s to "
      . "$eYYYY-$eMM-$eDD $eh:$em:$es, interval=$intrv\n";
  ShowEscMessage(); 

  my($JHi) = Timely::GpsJulian($eYYYY, $eMM, $eDD, $eh, $em, $es,  0, 0, 0); 
if( $JHi < MINIMUMDATE)
  { Timely::Warn(3, "$eYYYY is too small"); 
    return;
  };
  my($J) = Timely::GpsJulian($YYYY, $MM, $DD, $h, $m, $s,  0, 0, 0);
if($J < MINIMUMDATE)
  { Timely::Warn(3, "$YYYY is too small");
    return;
  };

#  - <Section 184> - 
  my($JMED) = $J; # seconds [fixup!]
  my($ERR) = 0; 
  my($ANOMALIES) = 0; # [do we need this? explore] 
  my($ok) = 0; 
REDO: while($J < $JHi)
  { 
  if( CheckForEscape() )
    { $J = $JHi;
      next REDO;             # 
    };
    
    #1. Turn Julian timestamp into UTC Gregorian 
    $J = $JMED; # prevent cumulative error
    my($YEAR, $jMM, $jDD, $jh, $jm, $js) = Timely::FullGregorian($J, 0, 0, 1);  

    #2. Turn Julian into *local* zone Gregorian
    my($zYYYY,$zMM,$zDD,$zh,$zm,$zs, undef, undef, $hog, undef, undef) 
                      # dummy values  ^    ^             ^      ^ 
       = Timely::J2G(1, $zone, $J); 

#  - <Section 185> - 
  if($zYYYY == 0)  # anomalous date
    { Timely::XPrint(0, "\n   'Anomaly' skipped: $zone $J"); 
      $ANOMALIES ++;
    } else
    { #3. Turn UTC Gregorian values into tz object 
      my($dt1) = eval { DateTime->new( year => $YEAR, month => $jMM, day => $jDD,
         hour => $jh, minute => $jm, second => $js, time_zone => 'UTC') };     
         
      #4. Turn tz into cloned object for this zone 
      my($dtest) = eval { $dt1->clone->set_time_zone( $zoneNAME ) };
    if(! $dtest)
      { Timely::Warn(3, "INVALID(Perl DateTime test)$zone [$YEAR $jMM $jDD $jh $jm $js]"); 
      } else 
      { #5. compare local & tz 
        my($mine) = Timely::PrettyDate(1,$zYYYY, $zMM, $zDD, $zh, $zm, $zs); 
        my($yours) = $dtest->datetime();  # format is identical
      if($mine ne $yours)
        {           
          Timely::XPrint( 0, "\n   Mismatch $mine v external $yours =>" . &Dat($J) 
                   . ' <=' . sprintf("%.12f", $J) ); 
          $ERR++;
        };
      };
    };

#  - <Section 186> - 
  if($ok % (50*$PRETTYDOTS) == 0) # every $PRETTYDOTS dots
    { print "\n" . &Dat($J) . ' ';
    }; 
  if($ok % 50 == 0)  # every 50 
    { print '.';
    };
    $ok ++; 
    $JMED += $intrv; # use this instead  [fix me! no longer needed!!] 
  };

#  - <Section 187> - 
  Timely::XPrint(0, "\n Reconciliation for zone $zone. "
           . "Errors=$ERR/$ok Anomalies=$ANOMALIES\n"); 
}

#  - <Section 188> - 
sub ReadDateRange # 
{ my($inp);
    ($inp)=@_;

  my($YYYY, $MM, $DD, $h, $m, $s) = (0, 1, 1, 0, 0, 0); 
  my($eYYYY, $eMM, $eDD, $eh, $em, $es) = (0, 12, 31, 23, 59, 59); 

  my($more); 
if($inp =~ /^\s*(\d{4})-(\d+)-(\d+)[ T](\d+):(\d+):(\d+)(.*)$/ )
  { ($YYYY, $MM, $DD, $h, $m, $s, $more) = ($1, $2, $3, $4, $5, $6, $7);
  if($more =~ /^\s*(\d{4})-(\d+)-(\d+)[ T](\d+):(\d+):(\d+)\s*$/ )
    { ($eYYYY, $eMM, $eDD, $eh, $em, $es) = ($1, $2, $3, $4, $5, $6);
    } 
  elsif($more =~ /^\s*(\d{4})\s*$/ )
    { $eYYYY = $1; 
    }
  elsif($more =~ /^\s*$/ )
    { $eYYYY = $YYYY;
    } 
  else
    { # FAIL: leave $YYYY at zero! 
    };
  }
elsif($inp =~ /^\s*(\d{4})\s+(\d{4})-(\d+)-(\d+)[ T](\d+):(\d+):(\d+)\s*$/ )
  { ($YYYY,  $eYYYY, $eMM, $eDD, $eh, $em, $es) = ($1,  $2, $3, $4, $5, $6, $7);
  } 
elsif($inp =~ /^\s*(\d{4})\s+(\d{4})\s*$/ )
  { $YYYY = $1;
    $eYYYY = $2; 
  }
elsif($inp =~ /^\s*(\d{4})\s*$/ )
  { $YYYY = $1;
    $eYYYY = $YYYY; 
  }
else
  { # leave YYYY at 0. 
  }; 
 return($YYYY, $MM, $DD, $h, $m, $s,  $eYYYY, $eMM, $eDD, $eh, $em, $es); 
}

#  - <Section 189> - 
sub ShowEscMessage # 
{ 
if($READKEYBLOCKINGPROBLEM)
  { return;  # do nothing
  }; 
  print " Press Esc to escape..\n"; 
}

#  - <Section 190> - 
sub CheckForEscape 
{ 
if($READKEYBLOCKINGPROBLEM)
  { return(0);
  }; 
  ReadMode 4; # unbuffered 
  my($key) = ReadKey(-1);
  ReadMode 1; # normal.
if( defined($key) ) # this should not block 
  {
  if(ord($key) == 27)  # Esc key pressed?
    { return(1); 
    } else ## debug, but :
    { print "\n==$key==\n";
    }; 
  }; 
  return(0); 
}

#  - <Section 191> - 
sub TestJulian
{ Timely::XPrint(0, "\n *Testing reference dates* \n"); 
  my($fail) =  &TestPair('1901', 2415385.5, 1901,1,1,   0,0,0 );  # start 20th century
  $fail = &TestPair('UNIX', 2440587.5, 1970,1,1,   0,0,0) || $fail;  # UNIX reference
  $fail = &TestPair(' DOS', 2444239.5, 1980,1,1,   0,0,0) || $fail;  # DOS reference
  $fail = &TestPair('1900', 2415020.5, 1900,1,1,   0,0,0) || $fail;  # 1900

  $fail = &TestPair('GREG', 2299160.5, 1582,10,15, 0,0,0) || $fail;  # D1 Gregorian reform
  $fail = &TestPair('MJD0', 2400000.5, 1858,11,17, 0,0,0) || $fail;  # Modif. JD zero
  $fail = &TestPair('RAT1', 1721425.5, 1,1,1,      0,0,0) || $fail;  # Rata die = 1
  $fail = &TestPair('LAST', 2299149.5, 1582,10,4,  0,0,0) || $fail;  # 1D < Gregorian reform

  $fail = &TestPair('1BC', 1721059.5, 0,1,1,       0,0,0) || $fail;  # D1, 1BC (year 0)
  $fail = &TestPair('JULI', 38,  -4712,1,1,       12,0,0) || $fail;  # JD reference
  Timely::XPrint(0, "\n\n"); 
if($fail)
  { ## die "\n*ERROR* Julian conversion(s) failed\n";
    return 1; # 
  };
  
  print "You shouldn't need to press a key now: yet you may ... \n"; 
  my($key); 
if(  defined( $key = ReadKey(-1) )  ) # this should not block 
  { print "**Your Perl has a READ BLOCKING problem (accommodated)**\n\n";
    $READKEYBLOCKINGPROBLEM = 1; 
  }; 
  return($fail); 
}

#  - <Section 192> - 
sub TestPair # 
{ my($name, $Jref, @SMART) = @_;
  my($fail) = 0;
  my($Zoff) = 0;
  my($DST)  = 0;
  my($delta) = 0.01; # 10ms. [explore]

  $Jref *= 86400; # convert to seconds 

  my($J1) = Timely::ToJulian(@SMART, 0, $Zoff, $DST); 
  my($diff) = $J1-$Jref; 
if( abs($diff) > $delta)
  { $fail = 1;
    Timely::XPrint(0,  " -Failed- $name Julian test ($J1, d=$diff)\n" );
  };
  my(@GREG) = Timely::FullGregorian($J1,$Zoff,$DST,0);
    # no GPS adjust so $DST is a redundant variable [fix me] 


if(! &SameArray(\@GREG, \@SMART))  # avoid smart match. 
  { $fail = 1;
    Timely::XPrint(0,  " -Failed- $name Gregorian retest <@GREG>\n" );
  };

if(! $fail)
  { Timely::XPrint(0, $name . $TICK . ' ');  # eye candy
  };
  return($fail);
}

#  - <Section 193> - 
sub SameArray # 
{ my($rA, $rB) = @_; # two array references

  my(@A) = @$rA;
  my(@B) = @$rB;
  my($aL) = scalar @A; 
if($aL != scalar @B)
  { return(0); 
  }; 
while($aL > 0)
  { $aL --; 
  if($A[$aL] !~ /\Q$B[$aL]\E/) #note quotemeta 
    { return(0);
    }; 
  };
  return(1); 
}

#  - <Section 194> - 
sub Multitest #
{ my($inp, $region) = @_;

  my($handDB) = $smalltime_h;  

  my($q) = "SELECT region, transition, description FROM timely t "
         . "INNER JOIN PLACES P on t.region = P.place WHERE ignored = 0 "
         . "AND t.year < $TOPYEAR" ;  ## limit top, prevent failure!  
  my($all) = 0; 

  # check v+ means add 1 second, v- subtracts
  my($OFFSET) = 0; 
if($inp =~ /^\+(\d+)(.*)/)
  { $OFFSET = 1000000*$1; # 1 second=1M
    $inp = $2; # trim 
  } 
elsif($inp =~ /^(-\d+)(.*)/) # [ugly]
  { $OFFSET = 1000000*$1; # e.g. -1 s
    $inp = $2; 
  }; 

if( $inp !~ /^\s*all\s*$/ ) # v all for the lot! 
  { $q .= " and region = $region";
  } else
  { $all = 1;
  }; 

  my(@ZTRAN) = Timely::SQLManySQL($handDB, $q, 'get zone transitions');
  my($ERR) = 0;
  my($ANOMALIES) = 0; 
  
  my($ref); 
foreach $ref(@ZTRAN)
  { my($zid, $TR, $rName) = @$ref;

    my($JD) = Timely::HugeToJ($TR+$OFFSET);
    my($YYYY,$MM,$DD,$h,$m,$s, $dz, $dst, $hog, $deltz, $delds) 
       = Timely::J2G(0, $zid, $JD); # JD is Gps-based, $dst is DST, and 
       # $hog is zero unless we're in the groundhog hour. 
  if($YYYY == 0)  # anomalous date
    { Timely::XPrint( 0, "\n     'Out of range' date skipped: $zid/$rName " 
             . &JulianDay($JD) ); 
      $ANOMALIES ++;
    } else
    { my($mine) = Timely::Greg($JD,0,0,1);  # standard date, then in TZ!
      $mine =~ s/ /T/;  # replace ' ' with 'T'
      my($yours) =  Timely::FetchTzDate($JD, $rName, $YYYY, $MM, $DD, $h, $m, $s);


#  - <Section 195> - 
    if($mine ne $yours)
      { 
      if($hog)  # $hog != 0 
        { # crude hack [explore simply using delta values]

          # assume that: A. there are two dates
          #              B. My program returned the earlier one
          #              C. tz returned the later one
          #              D. the discrepancy is ($deltz + $delds)
          # E.g. Zone went back 2 h from +3 to +1 and DST went forward by 1 h, 
          #   then deltz = -2 and delds = 1, effectively back -1 hour.
          #   Advance by the NEGATIVE of this value (tz takes the second time) 

          my($truedelta) = $hog * ($deltz + $delds); # as is shadow, will be -ve. 
          my($fixmine) = Timely::Greg($JD, $truedelta, 0, 1); # adjust "as if" zone 
          $fixmine =~ s/ /T/; 
        if($fixmine ne $yours)
          { $ERR ++; 
            Timely::XPrint( 0, "\nBad transition $rName(" . &JulianDay($JD) 
                      . ",$hog), mine=$mine tz=$yours, dz=" . &Tim($deltz) 
                      . " dd=" . &Tim($delds) . ", failed fix=$fixmine, Z=" 
                      . &Tim($dz) . ", DST=" . &Tim($dst) ); 
            ##Timely::XPrint(0, "\n Transition Mismatch [ $mine | $yours, $rName($hog) { "
            ##           . &Tim($deltz) . ' ' . &Tim($delds) . " } ] "); # HMMM ??? 
          }; 
          #
          print &Sign($hog); # + or - 

#  - <Section 196> - 
        } else
        { $ERR ++; 
        if(length $yours < 1)
          { $yours = '?'; 
          } else
          { Timely::XPrint(0, "\n"); 
          }; 
          Timely::XPrint( 0, "Mismatch for $rName($JD): mine=$mine, tz=$yours (" 
                   . Timely::PrettyDate(0,$YYYY,$MM,$DD,$h,$m,$s) 
                   . ') z=' . &Tim($dz) . ' d=' . &Tim($dst) . ' ' ); 
        }; 

#  - <Section 197> - 
      } else
      { print '.'; 
      }; 
    };
  };
  Timely::XPrint(0, "Errors=$ERR, $ANOMALIES anomalies\n\n"); 
}  

#  - <Section 198> - 
sub ImplementExit #
{ my($code) = @_; 

if($code)
  { $code = 2; # if non-zero [nasty, $code can be text [hmm] explore]
  } else
  { my($qc) = "COMMIT"; 
    my($fail) = Timely::DoSQL($DATABASES{$BASEDATABASE}, $qc, 'commit'); 
    &Print(0, "\n  Result of commit: $fail"); 
  if($fail)
    { $code = $fail;
    }; 
  }; 

  my(@WARNS) = Timely::ListWarnings(); 
  Timely::XPrint(0, "\nWarning counts: \n -\t*\t**\t***\n " . join("\t",@WARNS) ); 

  my($db);
foreach $db (keys(%DATABASES)) 
  { DoClose( $db ); 
    &Print(2, "\n  Closed $db"); 
  }; 
  print "\n Goodbye($code). \n";

  Timely::EndTimely(); 

  exit($code);   
}

#  - <Section 199> - 
sub DoClose #
{ my($dbname);
    ($dbname)=@_;

  $DATABASES{$dbname}->disconnect(); 

  delete($DATABASES{$dbname}); # remove associative entry
  &Print(2, " : ODBC, Closed $dbname");
}

#  - <Section 200> - 
sub Sign # 
{ my($n) = @_;
if($n < 0)
  { return('-');
  };
  return('+'); 
}

#  - <Section 201> - 
sub DoWarn #
{ my($level, $msg) = @_;
  Timely::Warn($level, $msg); 
}

#  - <Section 202> - 
sub Print #
{ my($level, $msg) = @_;
  Timely::XPrint($level, $msg); 
}

#  - <Section 203> - 
sub Aagh # 
{ my($msg, $line, $foo);
    ($msg, $line, $foo)=@_;
  Timely::Aagh($msg, $line, $foo); 
}

#  - <Section 204> - 
sub ClearNewWarnings #
{ $LOCALS{'wArnings'} = Timely::GetNewWarnings(); 
  Timely::ClearWarnings(); 
}

#  - <Section 205> - 
sub PreArgs
{ 
foreach my $arg (@ARGV) 
  { ParseOneArg($arg);
  }; 
}

#  - <Section 206> - 
sub ParseOneArg # 
{ my ($arg) = @_;

  # Extract specific pairs, first database: 
if($arg =~ s/db=(\w+),?//) 
{  $BASEDATABASE = $1;
   # print "\nDebug: TARGET DATABASE set to $BASEDATABASE\n";
}
  
if($arg =~ s/user=(\d+),?//) # Extract User ID
  { $USERID = $1;
    # print "\nDebug: User set to $USERID\n";
  }

if($arg =~ s/leapseconds=(\d+),?//)   # Extract Leapseconds
  { $LEAPSECONDS = $1;
    # print "\nDebug: LEAPSECOND COUNT = $LEAPSECONDS\n";
  }
  
if($arg =~ s/topyear=(\d{4}),?//)   # Extract year maximum
  { $TOPYEAR = $1;
  if($TOPYEAR < 2026)
    { exit(BadTopYear); 
    }; 
    # print "\nDebug: TOP YEAR = $TOPYEAR\n";
  }

if($arg =~ /--help/) 
  { print "\nCommand-line examples:\n user=2000 db=fehr leapseconds=27"
        . "\n";
    exit(OnlyHelp); # 
  }

if($arg =~ /^\s*$/) # nothing of consequence
  { return; 
  }; 

  print("Unused residual command-line argument: '$arg'\n"); 
}
#  -END OF FILE- 
